{"answers": [{"answer_votes": "951", "answer_comments": [" As someone who has had a great deal of problems understanding monads, I can say that this answer helped.. a little. However, there's still some things that I don't understand. In what way is the list comprehension a monad? Is there an expanded form of that example? Another thing that really bothers me about most monad explanations, including this one- Is that they keep mixing up \"what is a monad?\" with \"what is a monad good for?\" and \"How is a monad implemented?\".  you jumped that shark when you wrote \"A monad is basically just a type that supports the >>= operator.\" Which just had me... \u2013 Breton  Aug 10 '09 at 2:00 ", " Also I disagree with your conclusion about why monads are hard. If monads themselves aren't complex, then you should be able to explain what they are without a bunch of baggage. I don't want to know about the implementation when I ask the question \"What is a monad\", I want to know what itch it's meant to be scratching. So far it seems like the answer is \"Because the authors of haskell are sadomasochists and decided that you should do something stupidly complex to accomplish simple things, so you HAVE to learn monads to use haskell, not because they're in any way useful in themselves\"... \u2013 Breton  Aug 10 '09 at 2:08 ", " But.. that can't be right, can it? I think monads are hard because nobody can seem to figure out how to explain them without getting caught up in confusing implementation details. I mean.. what is a school bus? It's a metal platform with a device in the front which consumes a refined petroleum product to drive in a cycle some metallic pistons, which in turn rotate a crank shaft attached to some gears which drive some wheels. The wheels have inflated rubber bags around them which interface with an ashphalt surface to cause a collection of seats to move forward. The seats move forward because... \u2013 Breton  Aug 10 '09 at 2:12 ", " I read all of this and still don't know what a monad is, aside from the fact that it's something Haskell programmers don't understand well enough to explain. The examples don't help much, given that these are all things one can do without monads, and this answer doesn't make it clear how monads make them any easier, only more confusing. The one part of this answer that came close to being useful was where the syntactic sugar of example #2 was removed. I say came close because, aside from the first line, the expansion doesn't bear any real resemblance to the original. \u2013 Laurence Gonsalves  Dec 19 '11 at 4:44 ", " Another problem that seems to be endemic to explanations of monads is that it's written in Haskell. I'm not saying Haskell is a bad language -- I'm saying it's a bad language for explaining monads. If I knew Haskell I'd already understand monads, so if you want to explain monads, start by using a language that people who don't know monads are more likely to understand. If you must use Haskell, don't use the syntactic sugar at all -- use the smallest, simplest subset of the language you can, and don't assume an understanding of Haskell IO. \u2013 Laurence Gonsalves  Dec 19 '11 at 4:50 "], "answer_body": " First: The term monad is a bit vacuous if you are not a mathematician. An alternative term is computation builder which is a bit more descriptive of what they are actually useful for.  You ask for practical examples:  Example 1: List comprehension :  [x*2 | x<-[1..10], odd x]  This expression returns the doubles of all odd numbers in the range from 1 to 10. Very useful!  It turns out this is really just syntactic sugar for some operations within the List monad. The same list comprehension can be written as:  do\n   x <- [1..10]\n   if odd x \n       then [x * 2] \n       else []  Or even:  [1..10] >>= (\\x -> if odd x then [x*2] else [])  Example 2: Input/Output :  do\n   putStrLn \"What is your name?\"\n   name <- getLine\n   putStrLn (\"Welcome, \" ++ name ++ \"!\")  Both examples use monads, AKA computation builders. The common theme is that the monad chains operations in some specific, useful way. In the list comprehension, the operations are chained such that if an operation returns a list, then the following operations are performed on every item in the list. The IO monad on the other hand performs the operations sequentially, but passes a \"hidden variable\" along, which represents \"the state of the world\", which allows us to write I/O code in a pure functional manner.  It turns out the pattern of chaining operations is quite useful and is used for lots of different things in Haskell.  Another example is exceptions: Using the Error monad, operations are chained such that they are performed sequentially, except if an error is thrown, in which case the rest of the chain is abandoned.  Both the list-comprehension syntax and the do-notation are syntactic sugar for chaining operations using the >>= operator. A monad is basically just a type that supports the >>= operator.  Example 3: A parser  This is a very simple parser which parses either a quoted string or a number:  parseExpr = parseString <|> parseNumber\n\nparseString = do\n        char '\"'\n        x <- many (noneOf \"\\\"\")\n        char '\"'\n        return (StringValue x)\n\nparseNumber = do\n    num <- many1 digit\n    return (NumberValue (read num))  The operations char , digit , etc. are pretty simple. They either match or don't match. The magic is the monad which manages the control flow: The operations are performed sequentially until a match fails, in which case the monad backtracks to the latest <|> and tries the next option. Again, a way of chaining operations with some additional, useful semantics.  Example 4: Asynchronous programming  The above examples are in Haskell, but it turns out F# also supports monads. This example is stolen from Don Syme :  let AsyncHttp(url:string) =\n    async {  let req = WebRequest.Create(url)\n             let! rsp = req.GetResponseAsync()\n             use stream = rsp.GetResponseStream()\n             use reader = new System.IO.StreamReader(stream)\n             return reader.ReadToEnd() }  This method fetches a web page. The punch line is the use of GetResponseAsync - it actually waits for the response on a separate thread, while the main thread returns from the function. The last three lines are executed on the spawned thread when the response have been received.  In most other languages you would have to explicitly create a separate function for the lines that handle the response. The async monad is able to \"split\" the block on its own and postpone the execution of the latter half. (The async {} syntax indicates that the control flow in the block is defined by the async monad.)  How they work  So how can a monad do all these fancy control-flow thing? What actually happens in a do-block (or a computation expression as they are called in F#), is that every operation (basically every line) is wrapped in a separate anonymous function. These functions are then combined using the bind operator (spelled >>= in Haskell). Since the bind operation combines functions, it can execute them as it sees fit: sequentially, multiple times, in reverse, discard some, execute some on a separate thread when it feels like it and so on.  As an example, this is the expanded version of the IO-code from example 2:  putStrLn \"What is your name?\"\n>>= (\\_ -> getLine)\n>>= (\\name -> putStrLn (\"Welcome, \" ++ name ++ \"!\"))  This is uglier, but it's also more obvious what is actually going on. The >>= operator is the magic ingredient: It takes a value (on the left side) and combines it with a function (on the right side), to produce a new value. This new value is then taken by the next >>= operator and again combined with a function to produce a new value. >>= can be viewed as a mini-evaluator.  Note that >>= is overloaded for different types, so every monad has its own implementation of >>= . (All the operations in the chain have to be of the type of the same monad though, otherwise the >>= operator won't work.)  The simplest possible implementation of >>= just takes the value on the left and applies it to the function on the right and returns the result, but as said before, what makes the whole pattern useful is when there is something extra going on in the monad's implementation of >>= .  There is some additional cleverness in how the values are passed from one operation to the next, but this requires a deeper explanation of the Haskell type system.  Summing up  In Haskell-terms a monad is a parameterized type which is an instance of the Monad type class, which defines >>= along with a few other operators. In layman's terms, a monad is just a type for which the >>= operation is defined.  In itself >>= is just a cumbersome way of chaining functions, but with the presence of the do-notation which hides the \"plumbing\", the monadic operations turns out to be a very nice and useful abstraction, useful many places in the language, and useful for creating your own mini-languages in the language.  Why are monads hard?  For many Haskell-learners, monads are an obstacle they hit like a brick wall. It's not that monads themselves are complex, but that the implementation relies on many other advanced Haskell features like parameterized types, type classes, and so on. The problem is that Haskell I/O is based on monads, and I/O is probably one of the first things you want to understand when learning a new language - after all, it's not much fun to create programs which don't produce any output. I have no immediate solution for this chicken-and-egg problem, except treating I/O like \"magic happens here\" until you have enough experience with other parts of language. Sorry.  Excellent blog on monads: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html ", "question_id": 44965}, {"answer_votes": "625", "answer_comments": [" I appreciate your answer\u2014especially the final concession that all of this is of course possible too without monads. One point to be made is that it's mostly easier with monads, but it's often not as efficient as doing it without them. Once you need to involve transformers, the extra layering of function calls (and function objects created) has a cost that's hard to see and control, rendered invisible by clever syntax. \u2013 seh  Apr 20 '12 at 16:35 ", " In Haskell at least, most of the overhead of monads gets stripped away by the optimiser. So the only real \"cost\" is in brain power required. (This is not insignificant if \"maintainability\" is something you care about.) But usually, monads make things easier , not harder. (Otherwise, why would you bother?) \u2013 MathematicalOrchid  Apr 21 '12 at 18:40 ", " I'm not sure whether or not Haskell supports this but mathematically you can define a monad either in terms of >>= and return or join and ap. >>= and return are what make monads practically useful but join and ap give a more intuitive understanding of what a monad is. \u2013 Jeremy List  Apr 2 '14 at 10:57 ", " Coming from a non-math, non-functional programming background, this answer made the most sense to me. \u2013 jrahhali  Aug 2 '17 at 23:55 ", " This is the first answer that actually gave me some idea of what the hell a monad is. Thank you for finding a way to explain it! \u2013 robotmay  Aug 14 '17 at 23:48 "], "answer_body": " Explaining \"what is a monad\" is a bit like saying \"what is a number?\" We use numbers all the time. But imagine you met someone who didn't know anything about numbers. How the heck would you explain what numbers are? And how would you even begin to describe why that might be useful?  What is a monad? The short answer: It's a specific way of chaining operations together.  In essence, you're writing execution steps and linking them together with the \"bind function\". (In Haskell, it's named >>= .) You can write the calls to the bind operator yourself, or you can use syntax sugar which makes the compiler insert those function calls for you. But either way, each step is separated by a call to this bind function.  So the bind function is like a semicolon; it separates the steps in a process. The bind function's job is to take the output from the previous step, and feed it into the next step.  That doesn't sound too hard, right? But there is more than one kind of monad. Why? How?  Well, the bind function can just take the result from one step, and feed it to the next step. But if that's \"all\" the monad does... that actually isn't very useful. And that's important to understand: Every useful monad does something else in addition to just being a monad. Every useful monad has a \"special power\", which makes it unique.  (A monad that does nothing special is called the \"identity monad\". Rather like the identity function, this sounds like an utterly pointless thing, yet turns out not to be... But that's another story\u2122.)  Basically, each monad has its own implementation of the bind function. And you can write a bind function such that it does hoopy things between execution steps. For example:   If each step returns a success/failure indicator, you can have bind execute the next step only if the previous one succeeded. In this way, a failing step aborts the whole sequence \"automatically\", without any conditional testing from you. (The Failure Monad .)  Extending this idea, you can implement \"exceptions\". (The Error Monad or Exception Monad .) Because you're defining them yourself rather than it being a language feature, you can define how they work. (E.g., maybe you want to ignore the first two exceptions and only abort when a third exception is thrown.)  You can make each step return multiple results , and have the bind function loop over them, feeding each one into the next step for you. In this way, you don't have to keep writing loops all over the place when dealing with multiple results. The bind function \"automatically\" does all that for you. (The List Monad .)  As well as passing a \"result\" from one step to another, you can have the bind function pass extra data around as well. This data now doesn't show up in your source code, but you can still access it from anywhere, without having to manually pass it to every function. (The Reader Monad .)  You can make it so that the \"extra data\" can be replaced. This allows you to simulate destructive updates , without actually doing destructive updates. (The State Monad and its cousin the Writer Monad .)  Because you're only simulating destructive updates, you can trivially do things that would be impossible with real destructive updates. For example, you can undo the last update , or revert to an older version .  You can make a monad where calculations can be paused , so you can pause your program, go in and tinker with internal state data, and then resume it.  You can implement \"continuations\" as a monad. This allows you to break people's minds!   All of this and more is possible with monads. Of course, all of this is also perfectly possible without monads too. It's just drastically easier using monads. ", "question_id": 44965}, {"answer_votes": "162", "answer_comments": [" \u2026best way not only on the internet, but anywhere. (Wadler's original paper Monads for functional programming that I mentioned in my answer below is also good.) None of the zillions of tutorials-by-analogy come close. \u2013 ShreevatsaR  Apr 30 '11 at 15:14 ", " This JavaScript translation of Sigfpe's post is the new best way to learn monads, for people who don't already grok advanced Haskell! \u2013 Sam Watkins  Jan 6 '14 at 2:55  ", " This is how I learned what a monad is. Walking the reader through the process of inventing a concept is often the best way to teach the concept. \u2013 Jordan  Mar 8 '15 at 5:58 ", " However, a function accepting the screen object as argument and returning its copy with text modified would be pure. \u2013 Dmitri Zaitsev  May 20 '16 at 12:09 "], "answer_body": " But, You could have invented Monads!   sigfpe says:   But all of these introduce monads as something esoteric in need of explanation. But what I want to argue is that they aren't esoteric at all. In fact, faced with various problems in functional programming you would have been led, inexorably, to certain solutions, all of which are examples of monads. In fact, I hope to get you to invent them now if you haven't already. It's then a small step to notice that all of these solutions are in fact the same solution in disguise. And after reading this, you might be in a better position to understand other documents on monads because you'll recognise everything you see as something you've already invented.  Many of the problems that monads try to solve are related to the issue of side effects. So we'll start with them. (Note that monads let you do more than handle side-effects, in particular many types of container object can be viewed as monads. Some of the introductions to monads find it hard to reconcile these two different uses of monads and concentrate on just one or the other.)  In an imperative programming language such as C++, functions behave nothing like the functions of mathematics. For example, suppose we have a C++ function that takes a single floating point argument and returns a floating point result. Superficially it might seem a little like a mathematical function mapping reals to reals, but a C++ function can do more than just return a number that depends on its arguments. It can read and write the values of global variables as well as writing output to the screen and receiving input from the user. In a pure functional language, however, a function can only read what is supplied to it in its arguments and the only way it can have an effect on the world is through the values it returns.   ", "question_id": 44965}, {"answer_votes": "162", "answer_comments": [" -> is right-associative, mirroring function application, which is left-associative, so leaving the parentheses out doesn't make a difference here. \u2013 Matthias Benkard  Oct 11 '08 at 16:06 ", " Your explanation did the trick for me. I would have added though a limited summing of some standard monads (reader, state, maybe, ...) to illustrate some practical uses and wrappings \u2013 Rabarberski  Apr 27 '09 at 8:36 ", " I don't think this is a very good explanation at all. Monads are simply A way? okay, which way? Why wouldn't I encapsulate using a class instead of a monad? \u2013 Breton  Nov 6 '10 at 22:14 ", " A longer explanation of this idea: blog.sigfpe.com/2007/04/trivial-monad.html \u2013 sdcvvc  Jan 25 '12 at 16:26  ", " @mb21: In case you're just pointing out that there are too many brackets, note that a->b->c is actually only short for a->(b->c). Writing this particular example as (a -> b) -> (Ta -> Tb) is strictly speaking just adding unncessary characters, but it's morally \"the right thing to do\" as it emphasises that fmap maps a function of type a -> b to a function of type Ta -> Tb. And originally, that's what functors do in category theory and that's where monads come from. \u2013 Nikolaj-K  Jul 21 '14 at 14:36  "], "answer_body": " Actually, contrary to common understanding of Monads, they have nothing to do with state. Monads are simply a way to wrapping things and provide methods to do operations on the wrapped stuff without unwrapping it.  For example, you can create a type to wrap another one, in Haskell:  data Wrapped a = Wrap a  To wrap stuff we define  return :: a -> Wrapped a\nreturn x = Wrap x  To perform operations without unwrapping, say you have a function f :: a -> b , then you can do this to lift that function to act on wrapped values:  fmap :: (a -> b) -> (Wrapped a -> Wrapped b)\nfmap f (Wrap x) = Wrap (f x)  That's about all there is to understand. However, it turns out that there is a more general function to do this lifting , which is bind :  bind :: (a -> Wrapped b) -> (Wrapped a -> Wrapped b)\nbind f (Wrap x) = f x  bind can do a bit more than fmap , but not vice versa. Actually, fmap can be defined only in terms of bind and return . So, when defining a monad.. you give its type (here it was Wrapped a ) and then say how its return and bind operations work.  The cool thing is that this turns out to be such a general pattern that it pops up all over the place, encapsulating state in a pure way is only one of them.  For a good article on how monads can be used to introduce functional dependencies and thus control order of evaluation, like it is used in Haskell's IO monad, check out IO Inside .  As for understanding monads, don't worry too much about it. Read about them what you find interesting and don't worry if you don't understand right away. Then just diving in a language like Haskell is the way to go. Monads are one of these things where understanding trickles into your brain by practice, one day you just suddenly realize you understand them. ", "question_id": 44965}, {"answer_votes": "77", "answer_comments": [" What exactly do you mean by \"maps a function over it\"? \u2013 Casebash  Mar 14 '10 at 6:24 ", " Casebash, I'm being deliberately informal in the introduction. See the examples near the end to get a sense of what \"mapping a function\" entails. \u2013 Chris Conway  Mar 14 '10 at 14:54 ", " Monad is not a datatype. It is a rule of composing functions: stackoverflow.com/a/37345315/1614973 \u2013 Dmitri Zaitsev  May 20 '16 at 12:16 "], "answer_body": " A monad is a datatype that has two operations: >>= (aka bind ) and return (aka unit ). return takes an arbitrary value and creates an instance of the monad with it. >>= takes an instance of the monad and maps a function over it. (You can see already that a monad is a strange kind of datatype, since in most programming languages you couldn't write a function that takes an arbitrary value and creates a type from it. Monads use a kind of parametric polymorphism .)  In Haskell notation, the monad interface is written  class Monad m where\n  return :: a -> m a\n  (>>=) :: forall a b . m a -> (a -> m b) -> m b  These operations are supposed to obey certain \"laws\", but that's not terrifically important: the \"laws\" just codify the way sensible implementations of the operations ought to behave (basically, that >>= and return ought to agree about how values get transformed into monad instances and that >>= is associative).  Monads are not just about state and I/O: they abstract a common pattern of computation that includes working with state, I/O, exceptions, and non-determinism. Probably the simplest monads to understand are lists and option types:  instance Monad [ ] where\n    []     >>= k = []\n    (x:xs) >>= k = k x ++ (xs >>= k)\n    return x     = [x]\n\ninstance Monad Maybe where\n    Just x  >>= k = k x\n    Nothing >>= k = Nothing\n    return x      = Just x  where [] and : are the list constructors, ++ is the concatenation operator, and Just and Nothing are the Maybe constructors. Both of these monads encapsulate common and useful patterns of computation on their respective data types (note that neither has anything to do with side effects or I/O).  You really have to play around writing some non-trivial Haskell code to appreciate what monads are about and why they are useful. ", "question_id": 44965}, {"answer_votes": "69", "answer_comments": [" slight addition to def of 'higher order function': they can take OR RETURN functions. That's why they are 'higher' 'cos they do things with themselves. \u2013 Kevin Won  Jan 30 '10 at 6:31  ", " By that definition, addition is a higher-order function. It takes a number and returns a function that adds that number to another. So no, higher order functions are strictly functions whose domain consists of functions. \u2013 Apocalisp  Jan 30 '10 at 16:58  ", " The video ' Brian Beckman: Don't fear the Monad ' follows this same line of logic. \u2013 icc97  Oct 10 '16 at 5:29 "], "answer_body": " You should first understand what a functor is. Before that, understand higher-order functions.  A higher-order function is simply a function that takes a function as an argument.  A functor is any type construction T for which there exists a higher-order function, call it map , that transforms a function of type a -> b (given any two types a and b ) into a function T a -> T b . This map function must also obey the laws of identity and composition such that the following expressions return true for all x , p , and q (Haskell notation):  map id = id\nmap (p . q) = map p . map q  For example, a type constructor called List is a functor if it comes equipped with a function of type (a -> b) -> List a -> List b which obeys the laws above. The only practical implementation is obvious. The resulting List a -> List b function iterates over the given list, calling the (a -> b) function for each element, and returns the list of the results.  A monad is essentially just a functor T with two extra methods, join , of type T (T a) -> T a , and unit (sometimes called return , fork , or pure ) of type a -> T a . For lists in Haskell:  join :: [[a]] -> [a]\npure :: a -> [a]  Why is that useful? Because you could, for example, map over a list with a function that returns a list. Join takes the resulting list of lists and concatenates them. List is a monad because this is possible.  You can write a function that does map , then join . This function is called bind , or flatMap , or (>>=) , or (=<<) . This is normally how a monad instance is given in Haskell.  A monad has to satisfy certain laws, namely that join must be associative. This means that if you have a value x of type [[[a]]] then join (join x) should equal join (map join x) . And pure must be an identity for join such that join (pure x) == x . ", "question_id": 44965}, {"answer_votes": "43", "answer_comments": [" Sometimes an explanation from a \"learner\" (like you) is more relevant to another learner than an explanation coming from an expert. Learners think alike :) \u2013 Adrian  Dec 7 '10 at 18:48 ", " What makes something a monad is the existence of a function with type M (M a) -> M a . The fact that you can turn that into one of type M a -> (a -> M b) -> M b is what makes them useful. \u2013 Jeremy List  Aug 19 '14 at 5:58 ", " \"monad\" roughly means \"pattern\" ... no. \u2013 user633183  May 19 '16 at 5:55 "], "answer_body": " [Disclaimer: I am still trying to fully grok monads. The following is just what I have understood so far. If it\u2019s wrong, hopefully someone knowledgeable will call me on the carpet.]  Arnar wrote:   Monads are simply a way to wrapping things and provide methods to do operations on the wrapped stuff without unwrapping it.   That\u2019s precisely it. The idea goes like this:   You take some kind of value and wrap it with some additional information. Just like the value is of a certain kind (eg. an integer or a string), so the additional information is of a certain kind.  E.g., that extra information might be a Maybe or an IO .  Then you have some operators that allow you to operate on the wrapped data while carrying along that additional information. These operators use the additional information to decide how to change the behaviour of the operation on the wrapped value.  E.g., a Maybe Int can be a Just Int or Nothing . Now, if you add a Maybe Int to a Maybe Int , the operator will check to see if they are both Just Int s inside, and if so, will unwrap the Int s, pass them the addition operator, re-wrap the resulting Int into a new Just Int (which is a valid Maybe Int ), and thus return a Maybe Int . But if one of them was a Nothing inside, this operator will just immediately return Nothing , which again is a valid Maybe Int . That way, you can pretend that your Maybe Int s are just normal numbers and perform regular math on them. If you were to get a Nothing , your equations will still produce the right result \u2013 without you having to litter checks for Nothing everywhere .   But the example is just what happens for Maybe . If the extra information was an IO , then that special operator defined for IO s would be called instead, and it could do something totally different before performing the addition. (OK, adding two IO Int s together is probably nonsensical \u2013 I\u2019m not sure yet.) (Also, if you paid attention to the Maybe example, you have noticed that \u201cwrapping a value with extra stuff\u201d is not always correct. But it\u2019s hard to be exact, correct and precise without being inscrutable.)  Basically, \u201cmonad\u201d roughly means \u201cpattern\u201d . But instead of a book full of informally explained and specifically named Patterns, you now have a language construct \u2013 syntax and all \u2013 that allows you to declare new patterns as things in your program . (The imprecision here is all the patterns have to follow a particular form, so a monad is not quite as generic as a pattern. But I think that\u2019s the closest term that most people know and understand.)  And that is why people find monads so confusing: because they are such a generic concept. To ask what makes something a monad is similarly vague as to ask what makes something a pattern.  But think of the implications of having syntactic support in the language for the idea of a pattern: instead of having to read the Gang of Four book and memorise the construction of a particular pattern, you just write code that implements this pattern in an agnostic, generic way once and then you are done! You can then reuse this pattern, like Visitor or Strategy or Fa\u00e7ade or whatever, just by decorating the operations in your code with it, without having to re-implement it over and over!  So that is why people who understand monads find them so useful : it\u2019s not some ivory tower concept that intellectual snobs pride themselves on understanding (OK, that too of course, teehee), but actually makes code simpler. ", "question_id": 44965}, {"answer_votes": "36", "answer_comments": [" Sequencing isn't the only reason to define a monad.  A monad is just any functor which has bind and return.  Bind and return give you sequencing.  But they give other things as well.  Also, note that your favorite imperative language is effectively a fancy IO monad with OO classes.  Making it easy to define monads means it's easy to use the interpreter pattern -- define a dsl as a monad and interpret it! \u2013 nomen  May 17 '14 at 16:40  ", " Here is an implementation: github.com/brianspinos777/Programming_cheat_sheets/blob/master/\u2026 \u2013 Brian Joseph Spinos  Dec 21 '17 at 21:20  "], "answer_body": " After much striving, I think I finally understand the monad. After rereading my own lengthy critique of the overwhelmingly top voted answer, I will offer this explanation.  There are three questions that need to be answered to understand monads:   Why do you need a monad?  What is a monad?  How is a monad implemented?   As I noted in my original comments, too many monad explanations get caught up in question number 3, without, and before really adequately covering question 2, or question 1.  Why do you need a monad?  Pure functional languages like Haskell are different from imperative languages like C, or Java in that, a pure functional program is not necessarily executed in a specific order, one step at a time. A Haskell program is more akin to a mathematical function, in which you may solve the \"equation\" in any number of potential orders. This confers a number of benefits, among which is that it eliminates the possibility of certain kinds of bugs, particularly those relating to things like \"state\".  However, there are certain problems that are not so straightforward to solve with this style of programming. Some things, like console programming, and file i/o, need things to happen in a particular order, or need to maintain state. One way to deal with this problem is to create a kind of object that represents the state of a computation, and a series of functions that take a state object as input, and return a new modified state object.  So let's create a hypothetical \"state\" value, that represents the state of a console screen. exactly how this value is constructed is not important, but let's say it's an array of byte length ascii characters that represents what is currently visible on the screen, and an array that represents the last line of input entered by the user, in pseudocode. We've defined some functions that take console state, modify it, and return a new console state.  consolestate MyConsole = new consolestate;  So to do console programming, but in a pure functional manner, you would need to nest a lot of function calls inside eachother.  consolestate FinalConsole = print(input(print(myconsole, \"Hello, what's your name?\")),\"hello, %inputbuffer%!\");  Programming in this way keeps the \"pure\" functional style, while forcing changes to the console to happen in a particular order. But, we'll probably want to do more than just a few operations at a time like in the above example. Nesting functions in that way will start to become ungainly. What we want, is code that does essentially the same thing as above, but is written a bit more like this:  consolestate FinalConsole = myconsole:\n                            print(\"Hello, what's your name?\"):\n                            input():\n                            print(\"hello, %inputbuffer%!\");  This would indeed be a more convenient way to write it. How do we do that though?  What is a monad?  Once you have a type (such as consolestate ) that you define along with a bunch of functions designed specifically to operate on that type, you can turn the whole package of these things into a \"monad\" by defining an operator like : (bind) that automatically feeds return values on its left, into function parameters on its right, and a lift operator that turns normal functions, into functions that work with that specific kind of bind operator.  How is a monad implemented?  See other answers, that seem quite free to jump into the details of that. ", "question_id": 44965}, {"answer_votes": "34", "answer_comments": [" The only problem with Wadler's paper is the notation is different but I agree that the paper is pretty compelling and a clear concise motivation for applying monads. \u2013 Jared Updike  Jul 31 '09 at 22:34 ", " +1 for the \"monad tutorial fallacy\". Tutorials on monads are akin to having several tutorials trying to explain the concept of integer numbers. One tutorial would say, \"1 is similar to an apple\"; another tutorial says, \"2 is like a pear\"; a third one says, \"3 is basically an orange\". But you never get the whole picture from any single tutorial. What I've taken from that is that monads are an abstract concept which can be used for many quite different purposes. \u2013 stakx  Jan 14 '11 at 7:30  ", " @stakx: Yes, true. But I didn't mean that monads are an abstraction that you cannot learn or shouldn't learn; only that it's best to learn it after you've seen enough concrete examples to perceive a single underlying abstraction. See my other answer here . \u2013 ShreevatsaR  Jan 14 '11 at 12:22 ", " Sometimes I feel that there are so many tutorials that try to convince the reader that monads are useful by using code that do complicated or useful stuff. That hindered my understanding for months. I don't learn that way. I prefer to see extremely simple code, doing something stupid that I can mentally go through and I couldn't find this kind of example. I can't learn if the first example is a monad to parse a complicate grammar. I can learn if it's a monad to sum integers. \u2013 Rafael S. Calsaverini  Jan 23 '11 at 23:11  ", " Mentioning only type constructor is incomplete: stackoverflow.com/a/37345315/1614973 \u2013 Dmitri Zaitsev  May 20 '16 at 12:18 "], "answer_body": " (See also the answers at What is a monad? )  A good motivation to Monads is sigfpe (Dan Piponi)'s You Could Have Invented Monads! (And Maybe You Already Have) . There are a LOT of other monad tutorials , many of which misguidedly try to explain monads in \"simple terms\" using various analogies: this is the monad tutorial fallacy ; avoid them.  As DR MacIver says in Tell us why your language sucks :   So, things I hate about Haskell:   Let\u2019s start with the obvious. Monad tutorials. No, not monads. Specifically the tutorials. They\u2019re endless, overblown and dear god are they tedious. Further, I\u2019ve never seen any convincing evidence that they actually help. Read the class definition, write some code, get over the scary name.  You say you understand the Maybe monad? Good, you're on your way. Just start using other monads and sooner or later you'll understand what monads are in general.  [If you are mathematically oriented, you might want to ignore the dozens of tutorials and learn the definition, or follow lectures in category theory :)\nThe main part of the definition is that a Monad M involves a \"type constructor\" that defines for each existing type \"T\" a new type \"M T\", and some ways for going back and forth between \"regular\" types and \"M\" types.]  Also, surprisingly enough, one of the best introductions to monads is actually one of the early academic papers introducing monads, Philip Wadler's Monads for functional programming . It actually has practical, non-trivial motivating examples, unlike many of the artificial tutorials out there. ", "question_id": 44965}, {"answer_votes": "30", "answer_comments": [" Monads weren't 'designed', they were applied from one domain (category theory) to another (I/O in purely functional programming languages). Did Newton 'design' the calculus? \u2013 Jared Updike  Jul 31 '09 at 22:40 ", " Point 1 and 2 above are correct and useful. Points 4 and 5 are sort of ad hominem, even if more or less true. They don't really help explain monads. \u2013 Jared Updike  Jul 31 '09 at 22:42 ", " Re: 4, 5: The \"Secret handshake\" thing is a red herring. Programming is full of jargon. Haskell just happens to call stuff what it is without pretending to rediscover something. If it exists in mathematics already, why make up a new name for it? The name is really not the reason people don't get monads; they are a subtle concept. The average person probably understands addition and multiplication, why don't they get the concept of an Abelian Group? Because it is more abstract and general and that person hasn't done the work to wrap their head around the concept. A name change wouldn't help. \u2013 Jared Updike  Jul 31 '09 at 22:53 ", " Sigh... I'm not making an attack on Haskell ... I was making a joke.  So, I don't really get the bit about being \"ad hominem\".  Yes, the calculus was \"designed\". That's why, for example, calculus students are taught the Leibniz notation, rather than the icky stuff Netwton used. Better design.  Good names help understanding a lot. If I called Abelian Groups \"distended wrinkle pods\", you may have trouble understanding me.  You might be saying \"but that name is nonsense\", no one would ever call them that.  To people who have never heard of category theory \"monad\" sounds like nonsense. \u2013 Scott Wisniewski  Aug 1 '09 at 1:21 ", " @Scott: sorry if my extensive comments made it seem I was getting defensive about Haskell. I enjoy your humor about the secret handshake and you will note I said it is more or less true. :-) If you called Abelian Groups \"distended wrinkle pods\" you would be making the same mistake of trying to give monads a \"better name\" (cf. F# \"computation expressions\"): the term exists and people who care know what monads are, but not what \"warm fuzzy things\" are (or \"computation expressions\"). If I understand your use of the term \"type operator\" correctly there are lots of other type operators than monads. \u2013 Jared Updike  Aug 3 '09 at 23:27 "], "answer_body": " A monad is, effectively, a form of \"type operator\". It will do three things. First it will \"wrap\" (or otherwise convert) a value of one type into another type (typically called a \"monadic type\"). Secondly it will make all the operations (or functions) available on the underlying type available on the monadic type. Finally it will provide support for combining its self with another monad to produce a composite monad.  The \"maybe monad\" is essentially the equivalent of \"nullable types\" in Visual Basic / C#. It takes a non nullable type \"T\" and converts it into a \"Nullable<T>\", and then defines what all the binary operators mean on a Nullable<T>.  Side effects are represented simillarly. A structure is created that holds descriptions of side effects alongside a function's return value. The \"lifted\" operations then copy around side effects as values are passed between functions.  They are called \"monads\" rather than the easier-to-grasp name of \"type operators\" for several reasons:   Monads have restrictions on what they can do (see the definiton for details).  Those restrictions, along with the fact that there are three operations involved, conform to the structure of something called a monad in Category Theory, which is an obscure branch of mathematics.  They were designed by proponents of \"pure\" functional languages  Proponents of pure functional languages like obscure branches of mathematics  Because the math is obscure, and monads are associated with particular styles of programming, people tend to use the word monad as a sort of secret handshake. Because of this no one has bothered to invest in a better name.  ", "question_id": 44965}, {"answer_votes": "28", "answer_comments": [" \"...but I hope others find it useful\" it was indeed useful for me, despite of all the emphasized sentences :D \u2013 ftor  Oct 19 '16 at 17:50 ", " This is the most concise and clear explanation of monads I've ever read/watched/heard.  Thank you! \u2013 James  Nov 7 '16 at 2:04 ", " There is important difference between Monad and Monoid. Monad is a rule to \"compose\" functions between different types, so they do not form a binary operation as required for Monoids, see here for more details: stackoverflow.com/questions/2704652/\u2026 \u2013 Dmitri Zaitsev  Nov 18 '16 at 16:51 ", " Yes. You are correct. Your article was over my head :). However, I found this treatment very helpful (and added it to mine as a direction to others). Thanks your the heads up: stackoverflow.com/a/7829607/1612190 \u2013 George  Nov 21 '16 at 7:44 ", " You might have confused Algebraic group theory with Category theory where Monad is coming from. The former is the theory of algebraic groups, which is unrelated. \u2013 Dmitri Zaitsev  Mar 1 '17 at 12:19 "], "answer_body": " I wrote this mostly for me but I hope others find it useful :)  In Summary  A monad is merely custom function composition utilizing a wrapping type to hold stateful/meta information that guides the composition. Interestingly, imperative execution is itself function composition wherein the wrapping type holds whether an exception has occurred, the presence of which aborts further composition. The monadic laws serve to ensure a monad only performs the equivalent of function composition over the wrapped value.  A Little Context  Imperative code is a sequence of instructions performed consecutively while functional code is actually an expression whose order of evaluation is ultimately on an as needed basis. Consequently, an imperative program evaluates each statement fully before proceeding to the next one while a functional program catalogs any preceding subexpression then evaluates the last one to generate a result, at which point any necessary preceding subexpressions are evaluated. (Most functional languages do resolve subexpressions into values as they are encountered with a few, notably Haskell, being the exception).  What Does That Have To Do With Monads  It turns out that imperative evaluation and \"expression\" evaluation are equivalent. Namely, the performance of an evaluation of an expression at any specific time can be described as the sequential evaluation of its subexpressions. Similarly, any sequential execution of statements can be considered an instance of such an expression being evaluated especially if you generalize the notion of return value to be any modification to the application state as oppose to merely formal return values. To the point, all imperative code can be considered a specific ordered evaluation of some equivalent expression (over the application state).  Still, What Does All That Have To Do With Monads  An expression is a composition of functions and a monad is a technique for customizing the composition of functions. Per convention, it is a function called, bind , that composes (binds) two functions ( bind f g = (x) => g(f x) ) within some umbrella type that holds a context or state guiding the binding process. This context allows the associated implementation of bind to massage the composition. In the case of, Result 'a , context that hold an error message or a actual value it would permit the bind to log errors of the preceding result and aborts or continue the composition with a default value, depending on design. Selective application of the subsequent function to be composed is the key facility of monads in that the application process is not blind, unlike silly imperative code. :)  In a monad, the functions to be composed are defined to receive a non-monadic or unwrapped value but return a monadic or wrapped value. An example of one such naturally occurring function is the division operator ( / ) which accepts numbers but may return undefined if the divisor is 0 . Since undefined is not a number, \\ , actually returns a type whose value range is large than a number since it includes all numbers plus undefined .  I suspect this asymmetry, where operators require valid values but may return invalid ones, is a key pragmatic aspect of monads that make them useful but difficult to explain and justify; while imperative coders accept constant result checking as a necessary evil, functional coders use bind over a suitable wrapper type to detect and manage exceptions or invalid results  While being a composition function, nonetheless, for pragmatic reasons bind is described as receiving the result of the first function, a wrapped value, that it then selectively applies to the second function whose result it then collects and returns as its result. Consequently, binds can themselves be composed.  For a complex example, a monad can take a sequence of asynchronous results as a preceding value and apply each to the provided composing function in parallel with respect to the available processors, then collect and return their results as they occur, for instance. All this functionality is in that specific implementation of that monad's bind function; however, there are typically ancillary functions that cooperate, in particular lift with wraps a value into a default instance of the monadic type such as, lift 1 = Just 1 in the case of the Maybe monad, for participation in monadic expressions. (In Haskell, a monad is strongly associated with the wrapper type because monads are implemented using its type class mechanisms whereas in F# the implementation uses defined computations expression instances)  Are you saying that...  ...a monad is just custom function composition using a wrapping type to hold stateful information that the bind or composing function or operator uses in determining whether and how to perform the application of the next function. Yep.  What About The Monadic Laws?  The monadic laws only seek to ensure that a monad implementation only performs the equivalent of function composition over the wrapped type. It does that by ensuring certain equivalences hold per the expectation of composing those two functions over the wrapped type.  That's it I think. Hope it helps some.  I believe this is nice a nice treatment in another StackOverflow of response . ", "question_id": 44965}, {"answer_votes": "24", "answer_comments": null, "answer_body": " Monads are to control flow what abstract data types are to data.  In other words, many developers are comfortable with the idea of Sets, Lists, Dictionaries (or Hashes, or Maps), and Trees. Within those data types there are many special cases (for instance InsertionOrderPreservingIdentityHashMap).  However, when confronted with program \"flow\" many developers haven't been exposed to many more constructs than if, switch/case, do, while, goto (grr), and (maybe) closures.  So, a monad is simply a control flow construct. A better phrase to replace monad would be 'control type'.  As such, a monad has slots for control logic, or statements, or functions - the equivalent in data structures would be to say that some data structures allow you to add data, and remove it.  For example, the \"if\" monad:  if( clause ) then block  at its simplest has two slots - a clause, and a block. The if monad is usually built to evaluate the result of the clause, and if not false, evaluate the block. Many developers are not introduced to monads when they learn 'if', and it just isn't necessary to understand monads to write effective logic.  Monads can become more complicated, in the same way that data structures can become more complicated, but there are many broad categories of monad that may have similar semantics, but differing implementations and syntax.  Of course, in the same way that data structures may be iterated over, or traversed, monads may be evaluated.  Compilers may or may not have support for user-defined monads. Haskell certainly does. Ioke has some similar capabilities, although the term monad is not used in the language. ", "question_id": 44965}, {"answer_votes": "14", "answer_comments": null, "answer_body": " My favorite Monad tutorial:  http://www.haskell.org/haskellwiki/All_About_Monads  (out of 170,000 hits on a Google search for \"monad tutorial\"!)  @Stu: The point of monads is to allow you to add (usually) sequential semantics to otherwise pure code; you can even compose monads (using Monad Transformers) and get more interesting and complicated combined semantics, like parsing with error handling, shared state, and logging, for example. All of this is possible in pure code, monads just allow you to abstract it away and reuse it in modular libraries (always good in programming), as well as providing convenient syntax to make it look imperative.  Haskell already has operator overloading[1]: it uses type classes much the way one might use interfaces in Java or C# but Haskell just happens to also allow non-alphanumeric tokens like + && and > as infix identifiers. It's only operator overloading in your way of looking at it if you mean \"overloading the semicolon\" [2]. It sounds like black magic and asking for trouble to \"overload the semicolon\" (picture enterprising Perl hackers getting wind of this idea) but the point is that without monads there is no semicolon, since purely functional code does not require or allow explicit sequencing.  This all sounds much more complicated than it needs to. sigfpe's article is pretty cool but uses Haskell to explain it, which sort of fails to break the chicken and egg problem of understanding Haskell to grok Monads and understanding Monads to grok Haskell.  [1] This is a separate issue from monads but monads use Haskell's operator overloading feature.  [2] This is also an oversimplification since the operator for chaining monadic actions is >>= (pronounced \"bind\") but there is syntactic sugar (\"do\") that lets you use braces and semicolons and/or indentation and newlines. ", "question_id": 44965}, {"answer_votes": "9", "answer_comments": null, "answer_body": " I've been thinking of Monads in a different way, lately. I've been thinking of them as abstracting out execution order in a mathematical way, which makes new kinds of polymorphism possible.  If you're using an imperative language, and you write some expressions in order, the code ALWAYS runs exactly in that order.  And in the simple case, when you use a monad, it feels the same -- you define a list of expressions that happen in order. Except that, depending on which monad you use, your code might run in order (like in IO monad), in parallel over several items at once (like in the List monad), it might halt partway through (like in the Maybe monad), it might pause partway through to be resumed later (like in a Resumption monad), it might rewind and start from the beginning (like in a Transaction monad), or it might rewind partway to try other options (like in a Logic monad).  And because monads are polymorphic, it's possible to run the same code in different monads, depending on your needs.  Plus, in some cases, it's possible to combine monads together (with monad transformers) to get multiple features at the same time. ", "question_id": 44965}, {"answer_votes": "9", "answer_comments": [" The python examples made it easy to comprehend! Thanks for sharing. \u2013 Ryan Efendy  Mar 2 at 17:50 "], "answer_body": " I am still new to monads, but I thought I would share a link I found that felt really good to read (WITH PICTURES!!): http://www.matusiak.eu/numerodix/blog/2012/3/11/monads-for-the-layman/ (no affiliation)  Basically, the warm and fuzzy concept that I got from the article was the concept that monads are basically adapters that allow disparate functions to work in a composable fashion, i.e. be able to string up multiple functions and mix and match them without worrying about inconsistent return types and such. So the BIND function is in charge of keeping apples with apples and oranges with oranges when we're trying to make these adapters. And the LIFT function is in charge of taking \"lower level\" functions and \"upgrading\" them to work with BIND functions and be composable as well.  I hope I got it right, and more importantly, hope that the article has a valid view on monads. If nothing else, this article helped whet my appetite for learning more about monads. ", "question_id": 44965}, {"answer_votes": "8", "answer_comments": [" If you use jQuery, this explanation can be very helpful, especially if your Haskell isn't strong \u2013 byteclub  Dec 15 '10 at 16:16 ", " JQuery is emphatically not a monad. The linked article is wrong. \u2013 Tony Morris  Jun 19 '12 at 8:13 ", " Being \"emphatic\" isn't very convincing.  For some useful discussion on the topic, see Is jQuery a monad - Stack Overflow \u2013 nealmcb  Mar 25 '13 at 4:23 ", " See also Douglas Crackford's Google Talk Monads and Gonads and his Javascript code for doing modads, expanding on the similar behavior of AJAX libraries and Promises: douglascrockford/monad \u00b7 GitHub \u2013 nealmcb  Mar 25 '13 at 5:10 "], "answer_body": " In addition to the excellent answers above, let me offer you a link to the following article (by Patrick Thomson) which explains monads by relating the concept to the JavaScript library jQuery (and its way of using \"method chaining\" to manipulate the DOM): jQuery is a Monad  The jQuery documentation itself doesn't refer to the term \"monad\" but talks about the \"builder pattern\" which is probably more familiar.  This doesn't change the fact that you have a proper monad there maybe without even realizing it. ", "question_id": 44965}, {"answer_votes": "8", "answer_comments": null, "answer_body": " Monads Are Not Metaphors , but a practically useful abstraction emerging from a common pattern, as Daniel Spiewak explains. ", "question_id": 44965}, {"answer_votes": "6", "answer_comments": [" That is more like Applicative than Monad.  With Monads, you have to get data from the pipes before you can choose the next pipe to connect. \u2013 Peaker  Jul 22 '10 at 23:33 "], "answer_body": " A monad is a way of combining computations together that share a common context.  It is like building a network of pipes.  When constructing the network, there is no data flowing through it.  But when I have finished piecing all the bits together with 'bind' and 'return' then I invoke something like runMyMonad monad data and the data flows through the pipes. ", "question_id": 44965}, {"answer_votes": "5", "answer_comments": null, "answer_body": " The two things that helped me best when learning about there were:  Chapter 8, \"Functional Parsers,\" from Graham Hutton's book Programming in Haskell . This doesn't mention monads at all, actually, but if you can work through chapter and really understand everything in it, particularly how a sequence of bind operations is evaluated, you'll understand the internals of monads. Expect this to take several tries.  The tutorial All About Monads . This gives several good examples of their use, and I have to say that the analogy in Appendex I worked for me. ", "question_id": 44965}, {"answer_votes": "5", "answer_comments": null, "answer_body": " Monoid appears to be something that ensures that all operations defined on a Monoid and a supported type will always return a supported type inside the Monoid. Eg, Any number + Any number = A number, no errors.  Whereas division accepts two fractionals, and returns a fractional, which defined division by zero as Infinity in haskell somewhy(which happens to be a fractional somewhy)...  In any case, it appears Monads are just a way to ensure that your chain of operations behaves in a predictable way, and a function that claims to be Num -> Num, composed with another function of Num->Num called with x does not say, fire the missiles.  On the other hand, if we have a function which does fire the missiles, we can compose it with other functions which also fire the missiles, because our intent is clear -- we want to fire the missiles -- but it won't try printing \"Hello World\" for some odd reason.  In Haskell, main is of type IO (), or IO [()], the distiction is strange and I will not discuss it but here's what I think happens:  If I have main, I want it to do a chain of actions, the reason I run the program is to produce an effect -- usually though IO. Thus I can chain IO operations together in main in order to -- do IO, nothing else.  If I try to do something which does not \"return IO\", the program will complain that the chain does not flow, or basically \"How does this relate to what we are trying to do -- an IO action\", it appears to force the programmer to keep their train of thought, without straying off and thinking about firing the missiles, while creating algorithms for sorting -- which does not flow.  Basically, Monads appear to be a tip to the compiler that \"hey, you know this function that returns a number here, it doesn't actually always work, it can sometimes produce a Number, and sometimes Nothing at all, just keep this in mind\". Knowing this, if you try to assert a monadic action, the monadic action may act as a compile time exception saying \"hey, this isn't actually a number, this CAN be a number, but you can't assume this, do something to ensure that the flow is acceptable.\" which prevents unpredictable program behavior -- to a fair extent.  It appears monads are not about purity, nor control, but about maintaining an identity of a category on which all behavior is predictable and defined, or does not compile. You cannot do nothing when you are expected to do something, and you cannot do something if you are expected to do nothing (visible).  The biggest reason I could think of for Monads is -- go look at Procedural/OOP code, and you will notice that you do not know where the program starts, nor ends, all you see is a lot of jumping and a lot of math,magic,and missiles. You will not be able to maintain it, and if you can, you will spend quite a lot of time wrapping your mind around the whole program before you can understand any part of it, because modularity in this context is based on interdependant \"sections\" of code, where code is optimized to be as related as possible for promise of efficiency/inter-relation. Monads are very concrete, and well defined by definition, and ensure that the flow of program is possible to analyze, and isolate parts which are hard to analyze -- as they themselves are monads. A monad appears to be a \"comprehensible unit which is predictable upon its full understanding\" -- If you understand \"Maybe\" monad, there's no possible way it will do anything except be \"Maybe\", which appears trivial, but in most non monadic code, a simple function \"helloworld\" can fire the missiles, do nothing, or destroy the universe or even distort time -- we have no idea nor have any guarantees that IT IS WHAT IT IS. A monad GUARANTEES that IT IS WHAT IT IS. which is very powerful.  All things in \"real world\" appear to be monads, in the sense that it is bound by definite observable laws preventing confusion. This does not mean we have to mimic all the operations of this object to create classes, instead we can simply say \"a square is a square\", nothing but a square, not even a rectangle nor a circle, and \"a square has area of the length of one of it's existing dimensions multiplied by itself. No matter what square you have, if it's a square in 2D space, it's area absolutely cannot be anything but its length squared, it's almost trivial to prove. This is very powerful because we do not need to make assertions to make sure that our world is the way it is, we just use implications of reality to prevent our programs from falling off track.  Im pretty much guaranteed to be wrong but I think this could help somebody out there, so hopefully it helps somebody. ", "question_id": 44965}, {"answer_votes": "5", "answer_comments": null, "answer_body": " In the context of Scala you will find the following to be the simplest definition. Basically flatMap (or bind) is 'associative' and there exists an identity.  trait M[+A] {\n  def flatMap[B](f: A => M[B]): M[B] // AKA bind\n\n  // Pseudo Meta Code\n  def isValidMonad: Boolean = {\n    // for every parameter the following holds\n    def isAssociativeOn[X, Y, Z](x: M[X], f: X => M[Y], g: Y => M[Z]): Boolean =\n      x.flatMap(f).flatMap(g) == x.flatMap(f(_).flatMap(g))\n\n    // for every parameter X and x, there exists an id\n    // such that the following holds\n    def isAnIdentity[X](x: M[X], id: X => M[X]): Boolean =\n      x.flatMap(id) == x\n  }\n}  E.g.  // These could be any functions\nval f: Int => Option[String] = number => if (number == 7) Some(\"hello\") else None\nval g: String => Option[Double] = string => Some(3.14)\n\n// Observe these are identical. Since Option is a Monad \n// they will always be identical no matter what the functions are\nscala> Some(7).flatMap(f).flatMap(g)\nres211: Option[Double] = Some(3.14)\n\nscala> Some(7).flatMap(f(_).flatMap(g))\nres212: Option[Double] = Some(3.14)\n\n\n// As Option is a Monad, there exists an identity:\nval id: Int => Option[Int] = x => Some(x)\n\n// Observe these are identical\nscala> Some(7).flatMap(id)\nres213: Option[Int] = Some(7)\n\nscala> Some(7)\nres214: Some[Int] = Some(7)  NOTE Strictly speaking the definition of a Monad in functional programming is not the same as the definition of a Monad in Category Theory , which is defined in turns of map and flatten .  Though they are kind of equivalent under certain mappings.  This presentations is very good: http://www.slideshare.net/samthemonad/monad-presentation-scala-as-a-category ", "question_id": 44965}, {"answer_votes": "5", "answer_comments": null, "answer_body": " In practice, monad is a custom implementation of function composition operator that takes care of side effects and incompatible input and return values (for chaining). ", "question_id": 44965}, {"answer_votes": "5", "answer_comments": null, "answer_body": " This answer begins with a motivating example, works through the example, derives an example of a monad, and formally defines \"monad\".  Consider these three functions in pseudocode:  f(<x, messages>) := <x, messages \"called f. \">\ng(<x, messages>) := <x, messages \"called g. \">\nwrap(x)          := <x, \"\">  f takes an ordered pair of the form <x, messages> and returns an ordered pair. It leaves the first item untouched and appends \"called f. \" to the second item. Same with g .  You can compose these functions and get your original value, along with a string that shows which order the functions were called in:  f(g(wrap(x)))\n= f(g(<x, \"\">))\n= f(<x, \"called g. \">)\n= <x, \"called g. called f. \">  You dislike the fact that f and g are responsible for appending their own log messages to the previous logging information. (Just imagine for the sake of argument that instead of appending strings, f and g must perform complicated logic on the second item of the pair. It would be a pain to repeat that complicated logic in two -- or more -- different functions.)  You prefer to write simpler functions:  f(x)    := <x, \"called f. \">\ng(x)    := <x, \"called g. \">\nwrap(x) := <x, \"\">  But look at what happens when you compose them:  f(g(wrap(x)))\n= f(g(<x, \"\">))\n= f(<<x, \"\">, \"called g. \">)\n= <<<x, \"\">, \"called g. \">, \"called f. \">  The problem is that passing a pair into a function does not give you what you want. But what if you could feed a pair into a function:  feed(f, feed(g, wrap(x)))\n= feed(f, feed(g, <x, \"\">))\n= feed(f, <x, \"called g. \">)\n= <x, \"called g. called f. \">  Read feed(f, m) as \"feed m into f \". To feed a pair <x, messages> into a function f is to pass  x into f , get <y, message> out of f , and return <y, messages message> .  feed(f, <x, messages>) := let <y, message> = f(x)\n                          in  <y, messages message>  Notice what happens when you do three things with your functions:  First: if you wrap a value and then feed the resulting pair into a function:  feed(f, wrap(x))\n= feed(f, <x, \"\">)\n= let <y, message> = f(x)\n  in  <y, \"\" message>\n= let <y, message> = <x, \"called f. \">\n  in  <y, \"\" message>\n= <x, \"\" \"called f. \">\n= <x, \"called f. \">\n= f(x)  That is the same as passing the value into the function.  Second: if you feed a pair into wrap :  feed(wrap, <x, messages>)\n= let <y, message> = wrap(x)\n  in  <y, messages message>\n= let <y, message> = <x, \"\">\n  in  <y, messages message>\n= <x, messages \"\">\n= <x, messages>  That does not change the pair.  Third: if you define a function that takes x and feeds g(x) into f :  h(x) := feed(f, g(x))  and feed a pair into it:  feed(h, <x, messages>)\n= let <y, message> = h(x)\n  in  <y, messages message>\n= let <y, message> = feed(f, g(x))\n  in  <y, messages message>\n= let <y, message> = feed(f, <x, \"called g. \">)\n  in  <y, messages message>\n= let <y, message> = let <z, msg> = f(x)\n                     in  <z, \"called g. \" msg>\n  in <y, messages message>\n= let <y, message> = let <z, msg> = <x, \"called f. \">\n                     in  <z, \"called g. \" msg>\n  in <y, messages message>\n= let <y, message> = <x, \"called g. \" \"called f. \">\n  in <y, messages message>\n= <x, messages \"called g. \" \"called f. \">\n= feed(f, <x, messages \"called g. \">)\n= feed(f, feed(g, <x, messages>))  That is the same as feeding the pair into g and feeding the resulting pair into f .  You have most of a monad. Now you just need to know about the data types in your program.  What type of value is <x, \"called f. \"> ? Well, that depends on what type of value x is. If x is of type t , then your pair is a value of type \"pair of t and string\". Call that type M t .  M is a type constructor: M alone does not refer to a type, but M _ refers to a type once you fill in the blank with a type. An M int is a pair of an int and a string. An M string is a pair of a string and a string. Etc.  Congratulations, you have created a monad!  Formally, your monad is the tuple <M, feed, wrap> .  A monad is a tuple <M, feed, wrap> where:   M is a type constructor.  feed takes a (function that takes a t and returns an M u ) and an M t and returns an M u .  wrap takes a v and returns an M v .   t , u , and v are any three types that may or may not be the same. A monad satisfies the three properties you proved for your specific monad:   Feeding a wrapped t into a function is the same as passing the unwrapped t into the function.  Formally: feed(f, wrap(x)) = f(x)  Feeding an M t into wrap does nothing to the M t .  Formally: feed(wrap, m) = m  Feeding an M t (call it m ) into a function that   passes the t into g  gets an M u (call it n ) from g  feeds n into f   is the same as   feeding m into g  getting n from g  feeding n into f   Formally: feed(h, m) = feed(f, feed(g, m)) where h(x) := feed(f, g(x))   Typically, feed is called bind (AKA >>= in Haskell) and wrap is called return . ", "question_id": 44965}, {"answer_votes": "4", "answer_comments": null, "answer_body": " If I've understood correctly, IEnumerable is derived from monads. I wonder if that might be an interesting angle of approach for those of us from the C# world?  For what it's worth, here are some links to tutorials that helped me (and no, I still haven't understood what monads are).   http://osteele.com/archives/2007/12/overloading-semicolon  http://spbhug.folding-maps.org/wiki/MonadsEn  http://www.loria.fr/~kow/monads/  ", "question_id": 44965}, {"answer_votes": "3", "answer_comments": [" The course doesn't exist on Coursera any more \u2013 icc97  Dec 15 '16 at 13:26 ", " That's a surprising - and v poor - reflection on Coursera. \u2013 javadba  Dec 5 '17 at 1:30 "], "answer_body": " In the Coursera \"Principles of Reactive Programming\" training - Erik Meier describes them as:  \"Monads are return types that guide you through the happy path.\" -Erik Meijer ", "question_id": 44965}, {"answer_votes": "3", "answer_comments": [" Do you mean \"what the world doesn't need ...\"? Nice analogy though! \u2013 groverboy  Jan 6 '15 at 1:36 ", " @groverboy I think there was a hint of sarcasm \u2013 icc97  Mar 7 '17 at 8:35 ", " @icc97 you're right - the meaning is clear enough. Sarcasm unintended, apologies to the author. \u2013 groverboy  Mar 14 '17 at 2:29 ", " What the world needs is another comment thread confirming a sarcasm, but if read carefully I've written but so that should make it clear. \u2013 Eugene Yokota  Mar 21 '17 at 3:26 "], "answer_body": " What the world needs is another monad blog post, but I think this is useful in identifying existing monads in the wild.   monads are fractals     The above is a fractal called Sierpinski triangle, the only fractal I can remember to draw. Fractals are self-similar structure like the above triangle, in which the parts are similar to the whole (in this case exactly half the scale as parent triangle).  Monads are fractals. Given a monadic data structure, its values can be composed to form another value of the data structure. This is why it's useful to programming, and this is why it occurrs in many situations.  ", "question_id": 44965}, {"answer_votes": "3", "answer_comments": [" See if this helps projects.tmorris.net/public/what-does-monad-mean/artifacts/1.1/\u2026 \u2013 Tony Morris  Sep 9 '10 at 22:17  ", " Google Code is going to be closed down on 2016-01-15. Most projects are now read-only, as of 2015-08-24. \u2013 Peter Mortensen  Aug 28 '15 at 17:37 "], "answer_body": " http://code.google.com/p/monad-tutorial/ is a work in progress to address exactly this question. ", "question_id": 44965}, {"answer_votes": "3", "answer_comments": null, "answer_body": " tl;dr  {-# LANGUAGE InstanceSigs #-}\n\nnewtype Id t = Id t\n\ninstance Monad Id where\n   return :: t -> Id t\n   return = Id\n\n   (=<<) :: (a -> Id b) -> Id a -> Id b\n   f =<< (Id x) = f x  Prologue  The application operator $ of functions  forall a b. a -> b  is canonically defined  ($) :: (a -> b) -> a -> b\nf $ x = f x\n\ninfixr 0 $  in terms of Haskell-primitive function application f x ( infixl 10 ). Composition . is defined in terms of $ as  (.) :: (b -> c) -> (a -> b) -> (a -> c)\nf . g = \\ x -> f $ g x\n\ninfixr 9 .  and satisfies the equivalences forall f g h.  f . id  =  f            :: c -> d   Right identity\n     id . g  =  g            :: b -> c   Left identity\n(f . g) . h  =  f . (g . h)  :: a -> d   Associativity  . is associative, and id is its right and left identity.  The Kleisli triple  In programming, a monad is functor type constructor with an instance of the monad type class. There are several equivalent variants of definition and implementation, each carrying slightly different intuitions about the monad abstraction.  A functor is a type constructor f of kind * -> * with an instance of the functor type class.  {-# LANGUAGE KindSignatures #-}\n\nclass Functor (f :: * -> *) where\n   map :: (a -> b) -> (f a -> f b)  In addition to following statically enforced type protocol, instances of the functor type class must obey the algebraic functor laws  forall f g.  map id  =  id           :: f t -> f t   Identity\nmap f . map g  =  map (f . g)  :: f a -> f c   Composition / short cut fusion  Functor computations have the type  forall f t. Functor f => f t  A computation c r consists in results  r within context  c .  Unary monadic functions or Kleisli arrows have the type  forall m a b. Functor m => a -> m b  Kleisi arrows are functions that take one argument a and return a monadic computation m b .  Monads are canonically defined in terms of the Kleisli triple  forall m. Functor m =>  (m, return, (=<<))  implemented as the type class  class Functor m => Monad m where\n   return :: t -> m t\n   (=<<)  :: (a -> m b) -> m a -> m b\n\ninfixr 1 =<<  The Kleisli identity  return is a Kleisli arrow that promotes a value t into monadic context m . Extension or Kleisli application  =<< applies a Kleisli arrow a -> m b to results of a computation m a .  Kleisli composition  <=< is defined in terms of extension as  (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)\nf <=< g = \\ x -> f =<< g x\n\ninfixr 1 <=<  <=< composes two Kleisli arrows, applying the left arrow to results of the right arrow\u2019s application.  Instances of the monad type class must obey the monad laws , most elegantly stated in terms of Kleisli composition: forall f g h.  return <=< g  =  g                :: b -> m c   Left identity\n   f <=< return  =  f                :: c -> m d   Right identity\n(f <=< g) <=< h  =  f <=< (g <=< h)  :: a -> m d   Associativity  <=< is associative, and return is its right and left identity.  Identity  The identity type  type Id t = t  is the identity function on types  Id :: * -> *  Interpreted as a functor,  return :: t -> Id t\n=      id :: t ->    t\n\n    (=<<) :: (a -> Id b) -> Id a -> Id b\n=     ($) :: (a ->    b) ->    a ->    b\n\n    (<=<) :: (b -> Id c) -> (a -> Id b) -> (a -> Id c)\n=     (.) :: (b ->    c) -> (a ->    b) -> (a ->    c)  In canonical Haskell, the identity monad is defined  newtype Id t = Id t\n\ninstance Functor Id where\n   map :: (a -> b) -> Id a -> Id b\n   map f (Id x) = Id (f x)\n\ninstance Monad Id where\n   return :: t -> Id t\n   return = Id\n\n   (=<<) :: (a -> Id b) -> Id a -> Id b\n   f =<< (Id x) = f x  Option  An option type  data Maybe t = Nothing | Just t  encodes computation Maybe t that may not yield a result t , computation that may \u201cfail\u201d. The option monad is defined  instance Functor Maybe where\n   map :: (a -> b) -> (Maybe a -> Maybe b)\n   map f (Just x) = Just (f x)\n   map _ Nothing  = Nothing\n\ninstance Monad Maybe where\n   return :: t -> Maybe t\n   return = Just\n\n   (=<<) :: (a -> Maybe b) -> Maybe a -> Maybe b\n   f =<< (Just x) = f x\n   _ =<< Nothing  = Nothing  a -> Maybe b is applied only if Maybe a yields a result.  newtype Nat = Nat Int  The natural numbers can be encoded as those integers greater than or equal to zero.  toNat :: Int -> Maybe Nat\ntoNat i | i >= 0    = Just (Nat i)\n        | otherwise = Nothing  The natural numbers are not closed under subtraction.  (-?) :: Nat -> Nat -> Maybe Nat\n(Nat n) -? (Nat m) = toNat (n - m)\n\ninfixl 6 -?  The option monad covers a basic form of exception handling.  (-? 20) <=< toNat :: Int -> Maybe Nat  List  The list monad, over the list type  data [] t = [] | t : [t]\n\ninfixr 5 :  and its additive monoid operation \u201cappend\u201d  (++) :: [t] -> [t] -> [t]\n(x : xs) ++ ys = x : xs ++ ys\n[]       ++ ys = ys\n\ninfixr 5 ++  encodes nonlinear computation [t] yielding a natural amount 0, 1, ... of results t .  instance Functor [] where\n   map :: (a -> b) -> ([a] -> [b])\n   map f (x : xs) = f x : map f xs\n   map _ []       = []\n\ninstance Monad [] where\n   return :: t -> [t]\n   return = (: [])\n\n   (=<<) :: (a -> [b]) -> [a] -> [b]\n   f =<< (x : xs) = f x ++ f =<< xs\n   _ =<< []       = []  Extension concatenates ++ all result lists [b] from applications f x of a Kleisli arrow a -> [b] to elements of [a] into a single result list [b] .  Let the proper divisors of a positive integer n be  divisors :: Integral t => t -> [t]\ndivisors n = filter (`divides` n) [2 .. n - 1]\n\ndivides :: Integral t => t -> t -> Bool\n(`divides` n) = (== 0) . (n `rem`)  then  forall n.  let f = f <=< divisors in f n  =  []  In defining the monad type class, instead of extension =<< , the Haskell standard uses its flip, the bind operator >>= .  class Applicative m => Monad m where\n   (>>=) :: forall a b. m a -> (a -> m b) -> m b\n\n   (>>) :: forall a b. m a -> m b -> m b\n   m >> k = m >>= \\ _ -> k\n   {-# INLINE (>>) #-}\n\n   return :: a -> m a\n   return = pure\n\n   fail :: String -> m a\n   fail s = errorWithoutStackTrace s  For simplicitys sake, this explanation uses the type class hierarchy  class              Functor f\nclass Functor m => Monad m  In Haskell, the current standard hierarchy is  class                  Functor f\nclass Functor p     => Applicative p\nclass Applicative m => Monad m  because not only is every monad a functor, but every applicative is a functor and every monad an applicative, too.  Using the list monad, the imperative pseudocode  for a in (1, ..., 10)\n   for b in (1, ..., 10)\n      p <- a * b\n      if even(p)\n         yield p  roughly translates to the do block  do a <- [1 .. 10]\n   b <- [1 .. 10]\n   let p = a * b\n   guard (even p)\n   return p  the equivalent monad comprehension  [p | a <- [1 .. 10], b <- [1 .. 10], let p = a * b, even p]  and the expression  [1 .. 10] >>= (\\ a ->\n   [1 .. 10] >>= (\\ b ->\n      let p = a * b in\n         guard (even p) >>\n            return p\n   )\n)  Do notation and monad comprehensions are syntactic sugar for nested bind expressions. The bind operator is used for local name binding of monadic results.  let x = v in e  =  (\\ x -> e) $ v    =  v & (\\ x -> e)\n  do r <- m; c  =  (\\ r -> c) =<< m  =  m >>= (\\ r -> c)  where  (&) :: a -> (a -> b) -> b\n(&) = flip ($)\n\ninfixl 0 &  The guard function is defined  guard :: Additive m => Bool -> m ()\nguard True  = return ()\nguard False = fail  where the unit type or \u201cempty tuple\u201d  data () = ()  Additive monads that support choice and failure can be abstracted over using a type class  class Monad m => Additive m where\n   fail  :: m t\n   (<|>) :: m t -> m t -> m t\n\ninfixl 3 <|>\n\ninstance Additive Maybe where\n   fail = Nothing\n\n   Nothing <|> m = m\n   m       <|> _ = m\n\ninstance Additive [] where\n   fail = []\n   (<|>) = (++)  where fail and <|> form a monoid forall k l m.  fail <|> l  =  l\n     k <|> fail  =  k\n(k <|> l) <|> m  =  k <|> (l <|> m)  and fail is the absorbing/annihilating zero element of additive monads  _ =<< fail  =  fail  If in  guard (even p) >> return p  even p is true, then the guard produces [()] , and, by the definition of >> , the local constant function  \\ _ -> return p  is applied to the result () . If false, then the guard produces the list monad\u2019s fail  [] , which yields no result for a Kleisli arrow to be applied >> to.  State  Infamously, monads are used to encode stateful computation.  A state processor is a function  forall st t. st -> (t, st)  that transitions a state st and yields a result t . The state  st can be anything. Nothing, flag, count, array, handle, machine, world.  The type of state processors is usually called  type State st t = st -> (t, st)  The state processor monad is the kinded * -> * functor State st . Kleisli arrows of the state processor monad are functions  forall st a b. a -> (State st) b  In canonical Haskell, the lazy version of the state processor monad is defined  newtype State st t = State { stateProc :: st -> (t, st) }\n\ninstance Functor (State st) where\n   map :: (a -> b) -> ((State st) a -> (State st) b)\n   map f (State p) = State $ \\ s0 -> let (x, s1) = p s0\n                                     in  (f x, s1)\n\ninstance Monad (State st) where\n   return :: t -> (State st) t\n   return x = State $ \\ s -> (x, s)\n\n   (=<<) :: (a -> (State st) b) -> (State st) a -> (State st) b\n   f =<< (State p) = State $ \\ s0 -> let (x, s1) = p s0\n                                     in  stateProc (f x) s1  A state processor is run by supplying an initial state:  run :: State st t -> st -> (t, st)\nrun = stateProc\n\neval :: State st t -> st -> t\neval = fst . run\n\nexec :: State st t -> st -> st\nexec = snd . run  State access is provided by primitives get and put , methods of abstraction over stateful monads:  {-# LANGUAGE MultiParamTypeClasses, FunctionalDependencies #-}\n\nclass Monad m => Stateful m st |\u00a0m -> st where\n   get :: m st\n   put :: st -> m ()  m -> st declares a functional dependency of the state type st on the monad m ; that a State t , for example, will determine the state type to be t uniquely.  instance Stateful (State st) st where\n   get :: State st st\n   get = State $ \\ s -> (s, s)\n\n   put :: st -> State st ()\n   put s = State $ \\ _ -> ((), s)  with the unit type used analogously to void in C.  modify :: Stateful m st => (st -> st) -> m ()\nmodify f = do\n   s <- get\n   put (f s)\n\ngets :: Stateful m st => (st -> t) -> m t\ngets f = do\n   s <- get\n   return (f s)  gets is often used with record field accessors.  The state monad equivalent of the variable threading  let s0 = 34\n    s1 = (+ 1) s0\n    n = (* 12) s1\n    s2 = (+ 7) s1\nin  (show n, s2)  where s0 :: Int , is the equally referentially transparent, but infinitely more elegant and practical  (flip run) 34\n   (do\n      modify (+ 1)\n      n <- gets (* 12)\n      modify (+ 7)\n      return (show n)\n   )  modify (+ 1) is a computation of type State Int () , except for its effect equivalent to return () .  (flip run) 34\n   (modify (+ 1) >>\n      gets (* 12) >>= (\\ n ->\n         modify (+ 7) >>\n            return (show n)\n      )\n   )  The monad law of associativity can be written in terms of >>=  forall m f g.  (m >>= f) >>= g  =  m >>= (\\ x -> f x >>= g)  or  do {                 do {                   do {\n   r1 <- do {           x <- m;                r0 <- m;\n      r0 <- m;   =      do {            =      r1 <- f r0;\n      f r0                 r1 <- f x;          g r1\n   };                      g r1             }\n   g r1                 }\n}                    }  Like in expression-oriented programming (e.g. Rust), the last statement of a block represents its yield. The bind operator is sometimes called a \u201cprogrammable semicolon\u201d.  Iteration control structure primitives from structured imperative programming are emulated monadically  for :: Monad m => (a -> m b) -> [a] -> m ()\nfor f = foldr ((>>) . f) (return ())\n\nwhile :: Monad m => m Bool -> m t -> m ()\nwhile c m = do\n   b <- c\n   if b then m >> while c m\n        else return ()\n\nforever :: Monad m => m t\nforever m = m >> forever m  Input/Output  data World  The I/O world state processor monad is a reconciliation of pure Haskell and the real world, of functional denotative and imperative operational semantics. A close analogue of the actual strict implementation:  type IO t = World -> (t, World)  Interaction is facilitated by impure primitives  getChar         :: IO Char\nputChar         :: Char -> IO ()\nreadFile        :: FilePath -> IO String\nwriteFile       :: FilePath -> String -> IO ()\nhSetBuffering   :: Handle -> BufferMode -> IO ()\nhTell           :: Handle -> IO Integer\n. . .              . . .  The impurity of code that uses IO primitives is permanently protocolized by the type system. Because purity is awesome, what happens in IO , stays in IO .  unsafePerformIO :: IO t -> t  Or, at least, should.  The type signature of a Haskell program  main :: IO ()\nmain = putStrLn \"Hello, World!\"  expands to  World -> ((), World)  A function that transforms a world.  Epilogue  The category whiches objects are Haskell types and whiches morphisms are functions between Haskell types is, \u201cfast and loose\u201d, the category Hask .  A functor T is a mapping from a category C to a category D ; for each object in C an object in D  Tobj :  Obj(C) -> Obj(D)\n   f :: *      -> *  and for each morphism in C a morphism in D  Tmor :  HomC(X, Y) -> HomD(Tobj(X), Tobj(Y))\n map :: (a -> b)   -> (f a -> f b)  where X , Y are objects in C . HomC(X, Y) is the homomorphism class of all morphisms X -> Y in C . The functor must preserve morphism identity and composition, the \u201cstructure\u201d of C , in D .  Tmor    Tobj\n\n      T(id)  =  id        : T(X) -> T(X)   Identity\nT(f) . T(g)  =  T(f . g)  : T(X) -> T(Z)   Composition  The Kleisli category of a category C is given by a Kleisli triple  <T, eta, _*>  of an endofunctor  T : C -> C  ( f ), an identity morphism eta ( return ), and an extension operator * ( =<< ).  Each Kleisli morphism in Hask  f :  X -> T(Y)\n      f :: a -> m b  by the extension operator  (_)* :  Hom(X, T(Y)) -> Hom(T(X), T(Y))\n  (=<<) :: (a -> m b)   -> (m a -> m b)  is given a morphism in Hask \u2019s Kleisli category  f* :  T(X) -> T(Y)\n(f =<<) :: m a  -> m b  Composition in the Kleisli category .T is given in terms of extension  f .T g  =  f* . g       :  X -> T(Z)\nf <=< g  =  (f =<<) . g  :: a -> m c  and satisfies the category axioms  eta .T g  =  g                :  Y -> T(Z)   Left identity\n   return <=< g  =  g                :: b -> m c\n\n       f .T eta  =  f                :  Z -> T(U)   Right identity\n   f <=< return  =  f                :: c -> m d\n\n  (f .T g) .T h  =  f .T (g .T h)    :  X -> T(U)   Associativity\n(f <=< g) <=< h  =  f <=< (g <=< h)  :: a -> m d  which, applying the equivalence transformations  eta .T g  =  g\n     eta* . g  =  g               By definition of .T\n     eta* . g  =  id . g          forall f.  id . f  =  f\n         eta*  =  id              forall f g h.  f . h  =  g . h  ==>  f  =  g\n\n(f .T g) .T h  =  f .T (g .T h)\n(f* . g)* . h  =  f* . (g* . h)   By definition of .T\n(f* . g)* . h  =  f* . g* . h     . is associative\n    (f* . g)*  =  f* . g*         forall f g h.  f . h  =  g . h  ==>  f  =  g  in terms of extension are canonically given  eta*  =  id                 :  T(X) -> T(X)   Left identity\n       (return =<<)  =  id                 :: m t -> m t\n\n           f* . eta  =  f                  :  Z -> T(U)      Right identity\n   (f =<<) . return  =  f                  :: c -> m d\n\n          (f* . g)*  =  f* . g*            :  T(X) -> T(Z)   Associativity\n(((f =<<) . g) =<<)  =  (f =<<) . (g =<<)  :: m a -> m c  Monads can also be defined in terms not of Kleislian extension, but a natural transformation mu , in programming called join . A monad is defined in terms of mu as a triple over a category C , of an endofunctor  T :  C -> C\n     f :: * -> *  and two natural tranformations  eta :  Id -> T\nreturn :: t  -> f t\n\n    mu :  T . T   -> T\n  join :: f (f t) -> f t  satisfying the equivalences  mu . T(mu)  =  mu . mu               :  T . T . T -> T . T   Associativity\n  join . map join  =  join . join           :: f (f (f t)) -> f t\n\n      mu . T(eta)  =  mu . eta       =  id  :  T -> T               Identity\njoin . map return  =  join . return  =  id  :: f t -> f t  The monad type class is then defined  class Functor m => Monad m where\n   return :: t -> m t\n   join   :: m (m t) -> m t  The canonical mu implementation of the option monad:  instance Monad Maybe where\n   return = Just\n\n   join (Just m) = m\n   join Nothing  = Nothing  The concat function  concat :: [[a]] -> [a]\nconcat (x : xs) = x ++ concat xs\nconcat []       = []  is the join of the list monad.  instance Monad [] where\n   return :: t -> [t]\n   return = (: [])\n\n   (=<<) :: (a -> [b]) -> ([a] -> [b])\n   (f =<<) = concat . map f  Implementations of join can be translated from extension form using the equivalence  mu  =  id*           :  T . T -> T\n   join  =  (id =<<)      :: m (m t) -> m t  The reverse translation from mu to extension form is given by  f*  =  mu . T(f)     :  T(X) -> T(Y)\n(f =<<)  =  join . map f  :: m a -> m b    Philip Wadler: Monads for functional programming  Simon L Peyton Jones, Philip Wadler: Imperative functional programming  Jonathan M. D. Hill, Keith Clarke: An introduction to category theory, category theory monads, and their relationship to functional programming \u00b4  Kleisli category  Eugenio Moggi: Notions of computation and monads  What a monad is not    But why should a theory so abstract be of any use for programming?  The answer is simple: as computer scientists, we value abstraction ! When we design the interface to a software component, we want it to reveal as little as possible about the implementation. We want to be able to replace the implementation with many alternatives, many other \u2018instances\u2019 of the same \u2018concept\u2019. When we design a generic interface to many program libraries, it is even more important that the interface we choose have a variety of implementations. It is the generality of the monad concept which we value so highly, it is because category theory is so abstract that its concepts are so useful for programming.  It is hardly suprising, then, that the generalisation of monads that we present below also has a close connection to category theory. But we stress that our purpose is very practical: it is not to \u2018implement category theory\u2019, it is to find a more general way to structure combinator libraries. It is simply our good fortune that mathematicians have already done much of the work for us!   from Generalising Monads to Arrows by John Hughes ", "question_id": 44965}, {"answer_votes": "2", "answer_comments": [" Lenses, not Monads, are a way for functional programmers to use imperative code without actually admitting it. \u2013 OleTraveler  Oct 18 '12 at 19:31 "], "answer_body": " Explaining monads seems to be like explaining control-flow statements. Imagine that a non-programmer asks you to explain them?  You can give them an explanation involving the theory - Boolean Logic, register values, pointers, stacks, and frames. But that would be crazy.  You could explain them in terms of the syntax. Basically all control-flow statements in C have curly brackets, and you can distinguish the condition and the conditional code by where they are relative to the brackets. That may be even crazier.  Or you could also explain loops, if statements, routines, subroutines, and possibly co-routines.  Monads can replace a fairly large number of programming techniques. There's a specific syntax in languages that support them, and some theories about them.  They are also a way for functional programmers to use imperative code without actually admitting it, but that's not their only use. ", "question_id": 44965}, {"answer_votes": "2", "answer_comments": [" You seem to be the only one who finally addressed my main problem with understanding Monads. Nobody ever talks about HOW can the value be extracted. Is it implementation dependant? \u2013 Vinicius Seufitele  Aug 22 '12 at 16:39 ", " @ViniciusSeufitele, thanks for your comment. I'm afraid that my understanding hasn't advanced a great deal since I wrote this answer, so I can't really add much. The value extraction logically has to exist, so maybe that's why nobody bothers to mention it. \u2013 Benjol  Aug 23 '12 at 5:45 ", " I have a discussion that treats the monad as a type expansion where the original type, b, is converted to an expanded type M<b> and the associated operators are wrapped to now service M<b>. These wrappers are what will handle the peculiarities of the monad. In particular, extracting the original type from the expanded type and passing it to it's wrapped operator and subsequently promoting the result. The benefit of the monad is that you retain simple declarative expressions. In my treatment I discussed expanding the numeric types system to include a DivByZero value to obviate the need to check \u2013 George  Oct 13 '14 at 16:45 ", " @ViniciusSeufitele , yes it is implementation dependent. The person writing the function >>= has access to the internals of the monad. For example see Maybe Monad and look for instance Monad Maybe . You'll see that when the left hand side is Just x then we return k x . The pattern matching does the unwrap for you. Something analogous happens in every monad implementation. \u2013 Michael Welch  Feb 3 '15 at 16:59  "], "answer_body": " Princess 's explanation of F# Computation Expressions helped me, though I still can't say I've really understood.  EDIT : this series - explaining monads with javascript - is the one that 'tipped the balance' for me.   http://blog.jcoglan.com/2011/03/05/translation-from-haskell-to-javascript-of-selected-portions-of-the-best-introduction-to-monads-ive-ever-read/  http://blog.jcoglan.com/2011/03/06/monad-syntax-for-javascript/  http://blog.jcoglan.com/2011/03/11/promises-are-the-monad-of-asynchronous-programming/   I think that understanding monads is something that creeps up on you. In that sense, reading as many 'tutorials' as you can is a good idea, but often strange stuff (unfamiliar language or syntax) prevents your brain from concentrating on the essential.  Some things that I had difficulty understanding:   Rules-based explanations never worked for me, because most practical examples actually require more than just return/bind.  Also, calling them rules didn't help. It is more a case of \"there are these things that have something in common, let's call the things 'monads', and the bits in common 'rules'\".  Return ( a -> M<a> ) and Bind ( M<a> -> (a -> M<b>) -> M<b> ) are great, but what I could never understand is HOW Bind could extract the a from M<a> in order to pass it into a -> M<b> . I don't think I've ever read anywhere (maybe it's obvious to everyone else), that the reverse of Return ( M<a> -> a ) has to exist inside the monad, it just doesn't need to be exposed.  ", "question_id": 44965}, {"answer_votes": "2", "answer_comments": null, "answer_body": " I'm trying to understand monads as well. It's my version:  Monads are about making abstractions about repetitive things. \nFirstly, monad itself is a typed interface (like an abstract generic class), that has two functions: bind and return that have defined signatures. And then, we can create concrete monads based on that abstract monad, of course with specific implementations of bind and return. Additionally, bind and return must fulfill a few invariants in order to make it possible to compose/chain concrete monads.  Why create the monad concept while we have interfaces, types, classes and other tools to create abstractions? Because monads give more: they enforce rethinking problems in a way that enables to compose data without any boilerplate. ", "question_id": 44965}, {"answer_votes": "2", "answer_comments": [" As I understand, monads are more than that. Encapsulating mutable state in a \"pure\" functional languages is only one application of monads. \u2013 thSoft  Dec 30 '10 at 2:17 "], "answer_body": " A monad is a thing used to encapsulate objects that have changing state. It is most often encountered in languages that otherwise do not allow you to have modifiable state (e.g., Haskell).  An example would be for file I/O.  You would be able to use a monad for file I/O to isolate the changing state nature to just the code that used the Monad. The code inside the Monad can effectively ignore the changing state of the world outside the Monad - this makes it a lot easier to reason about the overall effect of your program. ", "question_id": 44965}, {"answer_votes": "2", "answer_comments": null, "answer_body": " A very simple answer is:  Monads are an abstraction that provide an interface for encapsulating values, for computing new encapsulated values, and for unwrapping the encapsulated value.  What's convenient about them in practice is that they provide a uniform interface for creating data types that model state while not being stateful .  It's important to understand that a Monad is an abstraction , that is, an abstract interface for dealing with a certain kind of data structure. That interface is then used to build data types that have monadic behavior.  You can find a very good and practical introduction in Monads in Ruby, Part 1: Introduction . ", "question_id": 44965}, {"answer_votes": "2", "answer_comments": null, "answer_body": " Essentially , and Practically , monads allow callback nesting (with a mutually-recursively-threaded state (pardon the hyphens)) (in a composable (or decomposable) fashion) (with type safety (sometimes (depending on the language))) )))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))  E.G. this is NOT a monad:  //JavaScript is 'Practical'\nvar getAllThree = \n         bind(getFirst, function(first){  \n  return bind(getSecond,function(second){  \n  return bind(getThird, function(third){  \n    var fancyResult = // And now make do fancy \n                      // with first, second,\n                      // and third \n    return RETURN(fancyResult);\n  });});});  But monads enable such code. The monad is actually the set of types for:  {bind,RETURN,maybe others I don't know...} . Which is essentially inessential, and practically impractical.  So now I can use it:  var fancyResultReferenceOutsideOfMonad =  \n  getAllThree(someKindOfInputAcceptableToOurGetFunctionsButProbablyAString);  \n\n//Ignore this please, throwing away types, yay JavaScript:\n//  RETURN = K\n//  bind = \\getterFn,cb -> \n//    \\in -> let(result,newState) = getterFn(in) in cb(result)(newState)  Or Break it up:  var getFirstTwo = \n           bind(getFirst, function(first){  \n    return bind(getSecond,function(second){  \n      var fancyResult2 = // And now make do fancy \n                         // with first and second\n      return RETURN(fancyResult2);\n    });})\n  , getAllThree = \n           bind(getFirstTwo, function(fancyResult2){  \n    return bind(getThird,    function(third){  \n      var fancyResult3 = // And now make do fancy \n                         // with fancyResult2,\n                         // and third \n      return RETURN(fancyResult3);\n    });});  Or ignore certain results:  var getFirstTwo = \n           bind(getFirst, function(first){  \n    return bind(getSecond,function(second){  \n      var fancyResult2 = // And now make do fancy \n                         // with first and second\n      return RETURN(fancyResult2);\n    });})\n  , getAllThree = \n           bind(getFirstTwo, function(____dontCare____NotGonnaUse____){  \n    return bind(getThird,    function(three){  \n      var fancyResult3 = // And now make do fancy \n                         // with `three` only!\n      return RETURN(fancyResult3);\n    });});  Or simplify a trivial case from:  var getFirstTwo = \n           bind(getFirst, function(first){  \n    return bind(getSecond,function(second){  \n      var fancyResult2 = // And now make do fancy \n                         // with first and second\n      return RETURN(fancyResult2);\n    });})\n  , getAllThree = \n           bind(getFirstTwo, function(_){  \n    return bind(getThird,    function(three){  \n      return RETURN(three);\n    });});  To (using \"Right Identity\" ):  var getFirstTwo = \n           bind(getFirst, function(first){  \n    return bind(getSecond,function(second){  \n      var fancyResult2 = // And now make do fancy \n                         // with first and second\n      return RETURN(fancyResult2);\n    });})\n  , getAllThree = \n           bind(getFirstTwo, function(_){  \n    return getThird;\n    });  Or jam them back together:  var getAllThree = \n           bind(getFirst, function(first_dontCareNow){  \n    return bind(getSecond,function(second_dontCareNow){  \n    return getThird;\n    });});  The practicality of these abilities doesn't really emerge, or become clear until you try to solve really messy problems like parsing, or module/ajax/resource loading.  Can you imagine thousands of lines of indexOf/subString logic? What if frequent parsing steps were contained in little functions? Functions like chars , spaces , upperChars , or digits ? And what if those functions gave you the result in a callback, without having to mess with Regex groups, and arguments.slice? And what if their composition/decomposition was well understood? Such that you could build big parsers from the bottom up?  So the ability to manage nested callback scopes is incredibly practical , especially when working with monadic parser combinator libraries. (that is to say, in my experience)  DON'T GET HUNG UP ON: - CATEGORY-THEORY - MAYBE-MONADS - MONAD LAWS - HASKELL - !!!! ", "question_id": 44965}, {"answer_votes": "2", "answer_comments": null, "answer_body": " Another attempt at explaining monads, using just Python lists and the map function. I fully accept this isn't a full explanation, but I hope it gets at the core concepts.  I got the basis of this from the funfunfunction video on Monads and the Learn You A Haskell chapter 'For a Few Monads More' . I highly recommend watching the funfunfunction video.  At it's very simplest, Monads are objects that have a map and flatMap functions ( bind in Haskell). There are some extra required properties , but these are the core ones.  flatMap 'flattens' the output of map, for lists this just concatenates the values of the list e.g.  concat([[1], [4], [9]]) = [1, 4, 9]  So in Python we can very basically implement a Monad with just these two functions:  def flatMap(func, lst):\n    return concat(map(func, lst))\n\ndef concat(lst):\n    return sum(lst, [])  func is any function that takes a value and returns a list e.g.  lambda x: [x*x]  Explanation  For clarity I created the concat function in Python via a simple function , which sums the lists i.e. [] + [1] + [4] + [9] = [1, 4, 9] (Haskell has a native concat method).  I'm assuming you know what the map function is e.g.:  >>> list(map(lambda x: [x*x], [1,2,3]))\n[[1], [4], [9]]  Flattening is the key concept of Monads and for each object which is a Monad this flattening allows you to get at the value that is wrapped in the Monad.  Now we can call:  >>> flatMap(lambda x: [x*x], [1,2,3])\n[1, 4, 9]  This lambda is taking a value x and putting it into a list. A monad works with any function that goes from a value to a type of the monad, so a list in this case.  That's your monad defined .  I think the question of why they're useful has been answered in other questions.  More explanation  Other examples that aren't lists are JavaScript Promises, which have the then method and JavaScript Streams which have a flatMap method.  So Promises and Streams use a slightly different function which flattens out a Stream or a Promise and returns the value from within.  The Haskell list monad has the following definition:  instance Monad [] where  \n    return x = [x]  \n    xs >>= f = concat (map f xs)  \n    fail _ = []  i.e. there are three functions return (not to be confused with return in most other languages), >>= (the flatMap ) and fail .  Hopefully you can see the similarity between:  xs >>= f = concat (map f xs)  and:  def flatMap(f, xs):\n    return concat(map(f, xs)) ", "question_id": 44965}, {"answer_votes": "2", "answer_comments": [" here is an implementation: github.com/brianspinos777/Programming_cheat_sheets/blob/master/\u2026 \u2013 Brian Joseph Spinos  Dec 21 '17 at 21:23 ", " IOW, Monad is generalized function call protocol. \u2013 Will Ness  Jan 28 at 16:09 ", " You answer is the most helpful in my opinion. Although I have to say that I think the emphasis needs to be on the fact that the functions you're refering to don't just involve values in contexts, they actively put values in contexts.  So for example, a function, f :: m a -> m b would very easily compose with another function, g :: m b -> m c.  But monads (bind specifically) allows us to perpetually compose functions which put their input in the same context, without us needing to take the value out of that context first (which would effectively remove information from the value) \u2013 James  Mar 23 at 18:41  ", " @James I think that should be the emphasis for functors? \u2013 Jonas  Mar 24 at 5:03 ", " @Jonas I guess I didn't explain propperly.   When I say that the functions put values in contexts, I mean that they have type (a -> m b). These are very useful since putting a value into a context adds new information to it but it would usually be difficult to chain a (a -> m b) and a (b -> m c) together since we can't just take the value out of the context. So we would have to use some convoluted process to chain these functions together in a sensible way depending on the specific context and monads just allow us to do this in a consistent way, regardless of the context. \u2013 James  Mar 24 at 16:23 "], "answer_body": " I will try to explain Monad in the context of Haskell.  In functional programming, function composition is important. It allows our program to consist of small, easy-to-read functions.  Let's say we have two functions: g :: Int -> String and f :: String -> Bool .  We can do (f . g) x , which is just the same as f (g x) , where x is an Int value.  When doing composition/applying the result of one function to another, having the types match up is important. In the above case, the type of the result returned by g must be the same as the type accepted by f .  But sometimes values are in contexts, and this makes it a bit less easy to line up types. (Having values in contexts is very useful. For example, the Maybe Int type represents an Int value that may not be there, the IO String type represents a String value that is there as a result of performing some side effects.)  Let's say we now have g1 :: Int -> Maybe String and f1 :: String -> Maybe Bool . g1 and f1 are very similar to g and f respectively.  We can't do (f1 . g1) x or f1 (g1 x) , where x is an Int value. The type of the result returned by g1 is not what f1 expects.  We could compose f and g with the . operator, but now we can't compose f1 and g1 with . . The problem is that we can't straightforwardly pass a value in a context to a function that expects a value that is not in a context.  Wouldn't it be nice if we introduce an operator to compose g1 and f1 , such that we can write (f1 OPERATOR g1) x ? g1 returns a value in a context. The value will be taken out of context and applied to f1 . And yes, we have such an operator. It's <=< .  We also have the >>= operator that does for us the exact same thing, though in a slightly different syntax.  We write: g1 x >>= f1 . g1 x is a Maybe Int value. The >>= operator helps take that Int value out of the \"perhaps-not-there\" context, and apply it to f1 . The result of f1 , which is a Maybe Bool , will be the result of the entire >>= operation.  And finally, why is Monad useful? Because Monad is the type class that defines the >>= operator, very much the same as the Eq type class that defines the == and /= operators.  To conclude, the Monad type class defines the >>= operator that allows us to pass values in a context (we call these monadic values) to functions that don't expect values in a context. The context will be taken care of.  If there is one thing to remember here, it is that Monad s allow function composition that involves values in contexts . ", "question_id": 44965}, {"answer_votes": "1", "answer_comments": null, "answer_body": " http://mikehadlow.blogspot.com/2011/02/monads-in-c-8-video-of-my-ddd9-monad.html  This is the video you are looking for.  Demonstrating in C# what the problem is with composition and aligning the types, and then implementing them properly in C#. \nTowards the end he displays how the same C# code looks in F# and finally in Haskell. ", "question_id": 44965}, {"answer_votes": "0", "answer_comments": null, "answer_body": " Let the below \" {| a |m} \" represent some piece of monadic data. A data type which advertises an a :  (I got an a!)\n          /        \n    {| a |m}  Function, f , knows how to create a monad, if only it had an a :  (Hi f! What should I be?)\n                      /\n(You?. Oh, you'll be /\n that data there.)  /\n /                 /  (I got a b.)\n|    --------------      |\n|  /                     |\nf a                      |\n  |--later->       {| b |m}  Here we see function, f , tries to evaluate a monad but gets rebuked.  (Hmm, how do I get that a?)\n o       (Get lost buddy.\no         Wrong type.)\no       /\nf {| a |m}  Funtion, f , finds a way to extract the a by using >>= .  (Muaahaha. How you \n         like me now!?)       \n    (Better.)      \\\n        |     (Give me that a.)\n(Fine, well ok.)    |\n         \\          |\n   {| a |m}   >>=   f  Little does f know, the monad and >>= are in collusion.  (Yah got an a for me?)       \n(Yeah, but hey    | \n listen. I got    |\n something to     |\n tell you first   |\n ...)   \\        /\n         |      /\n   {| a |m}   >>=   f  But what do they actually talk about? Well, that depends on the monad. Talking solely in the abstract has limited use; you have to have some experience with particular monads to flesh out the understanding.  For instance, the data type Maybe  data Maybe a = Nothing | Just a  has a monad instance which will acts like the following...  Wherein, if the case is Just a  (Yah what is it?)       \n(... hm? Oh,      |\nforget about it.  |\nHey a, yr up.)    | \n            \\     |\n(Evaluation  \\    |\ntime already? \\   |\nHows my hair?) |  |\n      |       /   |\n      |  (It's    |\n      |  fine.)  /\n      |   /     /    \n   {| a |m}   >>=   f  But for the case of Nothing  (Yah what is it?)       \n(... There      |\nis no a. )      |\n  |        (No a?)\n(No a.)         |\n  |        (Ok, I'll deal\n  |         with this.)\n   \\            |\n    \\      (Hey f, get lost.) \n     \\          |   ( Where's my a? \n      \\         |     I evaluate a)\n       \\    (Not any more  |\n        \\    you don't.    |\n         |   We're returning\n         |   Nothing.)   /\n         |      |       /\n         |      |      /\n         |      |     /\n   {| a |m}   >>=   f      (I got a b.)\n                    |  (This is   \\\n                    |   such a     \\\n                    |   sham.) o o  \\\n                    |               o|\n                    |--later-> {| b |m}  So the Maybe monad lets a computation continue if it actually contains the a it advertises, but aborts the computation if it doesn't. The result, however is still a piece of monadic data, though not the output of f . For this reason, the Maybe monad is used to represent the context of failure.  Different monads behave differently. Lists are other types of data with monadic instances. They behave like the following:  (Ok, here's your a. Well, its\n a bunch of them, actually.)\n  |\n  |    (Thanks, no problem. Ok\n  |     f, here you go, an a.)\n  |       |\n  |       |        (Thank's. See\n  |       |         you later.)\n  |  (Whoa. Hold up f,      |\n  |   I got another         |\n  |   a for you.)           |\n  |       |      (What? No, sorry.\n  |       |       Can't do it. I \n  |       |       have my hands full\n  |       |       with all these \"b\" \n  |       |       I just made.) \n  |  (I'll hold those,      |\n  |   you take this, and   /\n  |   come back for more  /\n  |   when you're done   / \n  |   and we'll do it   / \n  |   again.)          /\n   \\      |  ( Uhhh. All right.)\n    \\     |       /    \n     \\    \\      /\n{| a |m}   >>=  f  In this case, the function knew how to make a list from it's input, but didn't know what to do with extra input and extra lists. The bind >>= , helped f out by combining the multiple outputs. I include this example to show that while >>= is responsible for extracting a , it also has access to the eventual bound output of f . Indeed, it will never extract any a unless it knows the eventual output has the same type of context.  There are other monads which are used to represent different contexts. Here's some characterizations of a few more. The IO monad doesn't actually have an a , but it knows a guy and will get that a for you. The State st monad has a secret stash of st that it will pass to f under the table, even though f just came asking for an a . The Reader r monad is similar to State st , although it only lets f look at r .  The point in all this is that any type of data which is declared itself to be a Monad is declaring some sort of context around extracting a value from the monad. The big gain from all this? Well, its easy enough to couch a calculation with some sort of context. It can get messy, however, when stringing together multiple context laden calculations. The monad operations take care of resolving the interactions of context so that the programmer doesn't have to.  Note, that use of the >>= eases a mess by by taking some of the autonomy away from f . That is, in the above case of Nothing for instance, f no longer gets to decide what to do in the case of Nothing ; it's encoded in >>= . This is the trade off. If it was necessary for f to decide what to do in the case of Nothing , then f should have been a function from Maybe a to Maybe b . In this case, Maybe being a monad is irrelevant.  Note, however, that sometimes a data type does not export it's constructors (looking at you IO), and if we want to work with the advertised value we have little choice but to work with it's monadic interface. ", "question_id": 44965}, {"answer_votes": "0", "answer_comments": null, "answer_body": " If you are asking for a succinct, practical explanation for something so abstract, then you can only hope for an abstract answer:  a -> b  is one way of representing a computation from a s to b s. You can chain computations, aka compose them together:  (b -> c) -> (a -> b) -> (a -> c)  More complex computations demand more complex types, e.g.:  a -> f b  is the type of computations from a s to b s that are into f s. You can also compose them:  (b -> f c) -> (a -> f b) -> (a -> f c)  It turns out this pattern appears literally everywhere and has the same properties as the first composition above (associativity, right- and left-identity).  One had to give this pattern a name, but then would it help to know that the first composition is formally characterised as a Semigroupoid ?  \"Monads are just as interesting and important as parentheses\" (Oleg Kiselyov) ", "question_id": 44965}, {"answer_votes": "-1", "answer_comments": [" Big Mistake : monad computation can be triggerred wo. main. \u2013 Titou  Jul 13 '15 at 13:28 "], "answer_body": " Mathematial thinking  For short: An Algebraic Structure for Combining Computations.  return data : create a computation who just simply generate a data in monad world.  (return data) >>= (return func) : The second parameter accept first parameter as a data generator and create a new computations which concatenate them.  You can think that (>>=) and return won't do any computation itself. They just simply combine and create computations.  Any monad computation will be compute if and only if main trigs it. ", "question_id": 44965}, {"answer_votes": "-1", "answer_comments": null, "answer_body": " Explanation  It's quite simple, when explained in C#/Java terms:   A monad is a function that takes arguments and returns a special type.  The special type that this monad returns is also called monad. (A monad is a combination of #1 and #2)  There's some syntactic sugar to make calling this function and conversion of types easier.   Example  A monad is useful to make the life of the functional programmer easier. The typical example: The Maybe monad takes two parameters, a value and a function. It returns null if the passed value is null . Otherwise it evaluates the function. If we needed a special return type, we would call this return type Maybe as well. A very crude implementation would look like this:  object Maybe(object value, Func<object,object> function)\n{\n    if(value==null)\n        return null;\n\n    return function(value);\n}  This is spectacularly useless in C# because this language lacks the required syntactic sugar to make monads useful. But monads allow you to write more concise code in functional programming languages.  Oftentimes programmers call monads in chains, like so:  var x = Maybe(x, x2 => Maybe(y, y2 => Add(x2, y2)));  In this example the Add method would only be called if x and y are both non- null , otherwise null will be returned.  Answer  To answer the original question: A monad is a function AND a type. Like an implementation of a special interface . ", "question_id": 44965}], "K_means_clustering_result": [[[{"answer_votes": "43", "answer_comments": [" Sometimes an explanation from a \"learner\" (like you) is more relevant to another learner than an explanation coming from an expert. Learners think alike :) \u2013 Adrian  Dec 7 '10 at 18:48 ", " What makes something a monad is the existence of a function with type M (M a) -> M a . The fact that you can turn that into one of type M a -> (a -> M b) -> M b is what makes them useful. \u2013 Jeremy List  Aug 19 '14 at 5:58 ", " \"monad\" roughly means \"pattern\" ... no. \u2013 user633183  May 19 '16 at 5:55 "], "answer_body": " [Disclaimer: I am still trying to fully grok monads. The following is just what I have understood so far. If it\u2019s wrong, hopefully someone knowledgeable will call me on the carpet.]  Arnar wrote:   Monads are simply a way to wrapping things and provide methods to do operations on the wrapped stuff without unwrapping it.   That\u2019s precisely it. The idea goes like this:   You take some kind of value and wrap it with some additional information. Just like the value is of a certain kind (eg. an integer or a string), so the additional information is of a certain kind.  E.g., that extra information might be a Maybe or an IO .  Then you have some operators that allow you to operate on the wrapped data while carrying along that additional information. These operators use the additional information to decide how to change the behaviour of the operation on the wrapped value.  E.g., a Maybe Int can be a Just Int or Nothing . Now, if you add a Maybe Int to a Maybe Int , the operator will check to see if they are both Just Int s inside, and if so, will unwrap the Int s, pass them the addition operator, re-wrap the resulting Int into a new Just Int (which is a valid Maybe Int ), and thus return a Maybe Int . But if one of them was a Nothing inside, this operator will just immediately return Nothing , which again is a valid Maybe Int . That way, you can pretend that your Maybe Int s are just normal numbers and perform regular math on them. If you were to get a Nothing , your equations will still produce the right result \u2013 without you having to litter checks for Nothing everywhere .   But the example is just what happens for Maybe . If the extra information was an IO , then that special operator defined for IO s would be called instead, and it could do something totally different before performing the addition. (OK, adding two IO Int s together is probably nonsensical \u2013 I\u2019m not sure yet.) (Also, if you paid attention to the Maybe example, you have noticed that \u201cwrapping a value with extra stuff\u201d is not always correct. But it\u2019s hard to be exact, correct and precise without being inscrutable.)  Basically, \u201cmonad\u201d roughly means \u201cpattern\u201d . But instead of a book full of informally explained and specifically named Patterns, you now have a language construct \u2013 syntax and all \u2013 that allows you to declare new patterns as things in your program . (The imprecision here is all the patterns have to follow a particular form, so a monad is not quite as generic as a pattern. But I think that\u2019s the closest term that most people know and understand.)  And that is why people find monads so confusing: because they are such a generic concept. To ask what makes something a monad is similarly vague as to ask what makes something a pattern.  But think of the implications of having syntactic support in the language for the idea of a pattern: instead of having to read the Gang of Four book and memorise the construction of a particular pattern, you just write code that implements this pattern in an agnostic, generic way once and then you are done! You can then reuse this pattern, like Visitor or Strategy or Fa\u00e7ade or whatever, just by decorating the operations in your code with it, without having to re-implement it over and over!  So that is why people who understand monads find them so useful : it\u2019s not some ivory tower concept that intellectual snobs pride themselves on understanding (OK, that too of course, teehee), but actually makes code simpler. ", "question_id": 44965}, "0.25753384456038475", 0], [{"answer_votes": "14", "answer_comments": null, "answer_body": " My favorite Monad tutorial:  http://www.haskell.org/haskellwiki/All_About_Monads  (out of 170,000 hits on a Google search for \"monad tutorial\"!)  @Stu: The point of monads is to allow you to add (usually) sequential semantics to otherwise pure code; you can even compose monads (using Monad Transformers) and get more interesting and complicated combined semantics, like parsing with error handling, shared state, and logging, for example. All of this is possible in pure code, monads just allow you to abstract it away and reuse it in modular libraries (always good in programming), as well as providing convenient syntax to make it look imperative.  Haskell already has operator overloading[1]: it uses type classes much the way one might use interfaces in Java or C# but Haskell just happens to also allow non-alphanumeric tokens like + && and > as infix identifiers. It's only operator overloading in your way of looking at it if you mean \"overloading the semicolon\" [2]. It sounds like black magic and asking for trouble to \"overload the semicolon\" (picture enterprising Perl hackers getting wind of this idea) but the point is that without monads there is no semicolon, since purely functional code does not require or allow explicit sequencing.  This all sounds much more complicated than it needs to. sigfpe's article is pretty cool but uses Haskell to explain it, which sort of fails to break the chicken and egg problem of understanding Haskell to grok Monads and understanding Monads to grok Haskell.  [1] This is a separate issue from monads but monads use Haskell's operator overloading feature.  [2] This is also an oversimplification since the operator for chaining monadic actions is >>= (pronounced \"bind\") but there is syntactic sugar (\"do\") that lets you use braces and semicolons and/or indentation and newlines. ", "question_id": 44965}, "0.25753384456038475", 0], [{"answer_votes": "9", "answer_comments": null, "answer_body": " I've been thinking of Monads in a different way, lately. I've been thinking of them as abstracting out execution order in a mathematical way, which makes new kinds of polymorphism possible.  If you're using an imperative language, and you write some expressions in order, the code ALWAYS runs exactly in that order.  And in the simple case, when you use a monad, it feels the same -- you define a list of expressions that happen in order. Except that, depending on which monad you use, your code might run in order (like in IO monad), in parallel over several items at once (like in the List monad), it might halt partway through (like in the Maybe monad), it might pause partway through to be resumed later (like in a Resumption monad), it might rewind and start from the beginning (like in a Transaction monad), or it might rewind partway to try other options (like in a Logic monad).  And because monads are polymorphic, it's possible to run the same code in different monads, depending on your needs.  Plus, in some cases, it's possible to combine monads together (with monad transformers) to get multiple features at the same time. ", "question_id": 44965}, "0.25753384456038475", 0], [{"answer_votes": "6", "answer_comments": [" That is more like Applicative than Monad.  With Monads, you have to get data from the pipes before you can choose the next pipe to connect. \u2013 Peaker  Jul 22 '10 at 23:33 "], "answer_body": " A monad is a way of combining computations together that share a common context.  It is like building a network of pipes.  When constructing the network, there is no data flowing through it.  But when I have finished piecing all the bits together with 'bind' and 'return' then I invoke something like runMyMonad monad data and the data flows through the pipes. ", "question_id": 44965}, "0.25753384456038475", 0], [{"answer_votes": "3", "answer_comments": [" Do you mean \"what the world doesn't need ...\"? Nice analogy though! \u2013 groverboy  Jan 6 '15 at 1:36 ", " @groverboy I think there was a hint of sarcasm \u2013 icc97  Mar 7 '17 at 8:35 ", " @icc97 you're right - the meaning is clear enough. Sarcasm unintended, apologies to the author. \u2013 groverboy  Mar 14 '17 at 2:29 ", " What the world needs is another comment thread confirming a sarcasm, but if read carefully I've written but so that should make it clear. \u2013 Eugene Yokota  Mar 21 '17 at 3:26 "], "answer_body": " What the world needs is another monad blog post, but I think this is useful in identifying existing monads in the wild.   monads are fractals     The above is a fractal called Sierpinski triangle, the only fractal I can remember to draw. Fractals are self-similar structure like the above triangle, in which the parts are similar to the whole (in this case exactly half the scale as parent triangle).  Monads are fractals. Given a monadic data structure, its values can be composed to form another value of the data structure. This is why it's useful to programming, and this is why it occurrs in many situations.  ", "question_id": 44965}, "0.25753384456038475", 0], [{"answer_votes": "2", "answer_comments": [" Lenses, not Monads, are a way for functional programmers to use imperative code without actually admitting it. \u2013 OleTraveler  Oct 18 '12 at 19:31 "], "answer_body": " Explaining monads seems to be like explaining control-flow statements. Imagine that a non-programmer asks you to explain them?  You can give them an explanation involving the theory - Boolean Logic, register values, pointers, stacks, and frames. But that would be crazy.  You could explain them in terms of the syntax. Basically all control-flow statements in C have curly brackets, and you can distinguish the condition and the conditional code by where they are relative to the brackets. That may be even crazier.  Or you could also explain loops, if statements, routines, subroutines, and possibly co-routines.  Monads can replace a fairly large number of programming techniques. There's a specific syntax in languages that support them, and some theories about them.  They are also a way for functional programmers to use imperative code without actually admitting it, but that's not their only use. ", "question_id": 44965}, "0.25753384456038475", 0], [{"answer_votes": "2", "answer_comments": [" As I understand, monads are more than that. Encapsulating mutable state in a \"pure\" functional languages is only one application of monads. \u2013 thSoft  Dec 30 '10 at 2:17 "], "answer_body": " A monad is a thing used to encapsulate objects that have changing state. It is most often encountered in languages that otherwise do not allow you to have modifiable state (e.g., Haskell).  An example would be for file I/O.  You would be able to use a monad for file I/O to isolate the changing state nature to just the code that used the Monad. The code inside the Monad can effectively ignore the changing state of the world outside the Monad - this makes it a lot easier to reason about the overall effect of your program. ", "question_id": 44965}, "0.25753384456038475", 0], [{"answer_votes": "162", "answer_comments": [" -> is right-associative, mirroring function application, which is left-associative, so leaving the parentheses out doesn't make a difference here. \u2013 Matthias Benkard  Oct 11 '08 at 16:06 ", " Your explanation did the trick for me. I would have added though a limited summing of some standard monads (reader, state, maybe, ...) to illustrate some practical uses and wrappings \u2013 Rabarberski  Apr 27 '09 at 8:36 ", " I don't think this is a very good explanation at all. Monads are simply A way? okay, which way? Why wouldn't I encapsulate using a class instead of a monad? \u2013 Breton  Nov 6 '10 at 22:14 ", " A longer explanation of this idea: blog.sigfpe.com/2007/04/trivial-monad.html \u2013 sdcvvc  Jan 25 '12 at 16:26  ", " @mb21: In case you're just pointing out that there are too many brackets, note that a->b->c is actually only short for a->(b->c). Writing this particular example as (a -> b) -> (Ta -> Tb) is strictly speaking just adding unncessary characters, but it's morally \"the right thing to do\" as it emphasises that fmap maps a function of type a -> b to a function of type Ta -> Tb. And originally, that's what functors do in category theory and that's where monads come from. \u2013 Nikolaj-K  Jul 21 '14 at 14:36  "], "answer_body": " Actually, contrary to common understanding of Monads, they have nothing to do with state. Monads are simply a way to wrapping things and provide methods to do operations on the wrapped stuff without unwrapping it.  For example, you can create a type to wrap another one, in Haskell:  data Wrapped a = Wrap a  To wrap stuff we define  return :: a -> Wrapped a\nreturn x = Wrap x  To perform operations without unwrapping, say you have a function f :: a -> b , then you can do this to lift that function to act on wrapped values:  fmap :: (a -> b) -> (Wrapped a -> Wrapped b)\nfmap f (Wrap x) = Wrap (f x)  That's about all there is to understand. However, it turns out that there is a more general function to do this lifting , which is bind :  bind :: (a -> Wrapped b) -> (Wrapped a -> Wrapped b)\nbind f (Wrap x) = f x  bind can do a bit more than fmap , but not vice versa. Actually, fmap can be defined only in terms of bind and return . So, when defining a monad.. you give its type (here it was Wrapped a ) and then say how its return and bind operations work.  The cool thing is that this turns out to be such a general pattern that it pops up all over the place, encapsulating state in a pure way is only one of them.  For a good article on how monads can be used to introduce functional dependencies and thus control order of evaluation, like it is used in Haskell's IO monad, check out IO Inside .  As for understanding monads, don't worry too much about it. Read about them what you find interesting and don't worry if you don't understand right away. Then just diving in a language like Haskell is the way to go. Monads are one of these things where understanding trickles into your brain by practice, one day you just suddenly realize you understand them. ", "question_id": 44965}, "0.1878245873376727", 1], [{"answer_votes": "77", "answer_comments": [" What exactly do you mean by \"maps a function over it\"? \u2013 Casebash  Mar 14 '10 at 6:24 ", " Casebash, I'm being deliberately informal in the introduction. See the examples near the end to get a sense of what \"mapping a function\" entails. \u2013 Chris Conway  Mar 14 '10 at 14:54 ", " Monad is not a datatype. It is a rule of composing functions: stackoverflow.com/a/37345315/1614973 \u2013 Dmitri Zaitsev  May 20 '16 at 12:16 "], "answer_body": " A monad is a datatype that has two operations: >>= (aka bind ) and return (aka unit ). return takes an arbitrary value and creates an instance of the monad with it. >>= takes an instance of the monad and maps a function over it. (You can see already that a monad is a strange kind of datatype, since in most programming languages you couldn't write a function that takes an arbitrary value and creates a type from it. Monads use a kind of parametric polymorphism .)  In Haskell notation, the monad interface is written  class Monad m where\n  return :: a -> m a\n  (>>=) :: forall a b . m a -> (a -> m b) -> m b  These operations are supposed to obey certain \"laws\", but that's not terrifically important: the \"laws\" just codify the way sensible implementations of the operations ought to behave (basically, that >>= and return ought to agree about how values get transformed into monad instances and that >>= is associative).  Monads are not just about state and I/O: they abstract a common pattern of computation that includes working with state, I/O, exceptions, and non-determinism. Probably the simplest monads to understand are lists and option types:  instance Monad [ ] where\n    []     >>= k = []\n    (x:xs) >>= k = k x ++ (xs >>= k)\n    return x     = [x]\n\ninstance Monad Maybe where\n    Just x  >>= k = k x\n    Nothing >>= k = Nothing\n    return x      = Just x  where [] and : are the list constructors, ++ is the concatenation operator, and Just and Nothing are the Maybe constructors. Both of these monads encapsulate common and useful patterns of computation on their respective data types (note that neither has anything to do with side effects or I/O).  You really have to play around writing some non-trivial Haskell code to appreciate what monads are about and why they are useful. ", "question_id": 44965}, "0.1878245873376727", 1], [{"answer_votes": "5", "answer_comments": null, "answer_body": " In the context of Scala you will find the following to be the simplest definition. Basically flatMap (or bind) is 'associative' and there exists an identity.  trait M[+A] {\n  def flatMap[B](f: A => M[B]): M[B] // AKA bind\n\n  // Pseudo Meta Code\n  def isValidMonad: Boolean = {\n    // for every parameter the following holds\n    def isAssociativeOn[X, Y, Z](x: M[X], f: X => M[Y], g: Y => M[Z]): Boolean =\n      x.flatMap(f).flatMap(g) == x.flatMap(f(_).flatMap(g))\n\n    // for every parameter X and x, there exists an id\n    // such that the following holds\n    def isAnIdentity[X](x: M[X], id: X => M[X]): Boolean =\n      x.flatMap(id) == x\n  }\n}  E.g.  // These could be any functions\nval f: Int => Option[String] = number => if (number == 7) Some(\"hello\") else None\nval g: String => Option[Double] = string => Some(3.14)\n\n// Observe these are identical. Since Option is a Monad \n// they will always be identical no matter what the functions are\nscala> Some(7).flatMap(f).flatMap(g)\nres211: Option[Double] = Some(3.14)\n\nscala> Some(7).flatMap(f(_).flatMap(g))\nres212: Option[Double] = Some(3.14)\n\n\n// As Option is a Monad, there exists an identity:\nval id: Int => Option[Int] = x => Some(x)\n\n// Observe these are identical\nscala> Some(7).flatMap(id)\nres213: Option[Int] = Some(7)\n\nscala> Some(7)\nres214: Some[Int] = Some(7)  NOTE Strictly speaking the definition of a Monad in functional programming is not the same as the definition of a Monad in Category Theory , which is defined in turns of map and flatten .  Though they are kind of equivalent under certain mappings.  This presentations is very good: http://www.slideshare.net/samthemonad/monad-presentation-scala-as-a-category ", "question_id": 44965}, "0.1878245873376727", 1], [{"answer_votes": "5", "answer_comments": null, "answer_body": " This answer begins with a motivating example, works through the example, derives an example of a monad, and formally defines \"monad\".  Consider these three functions in pseudocode:  f(<x, messages>) := <x, messages \"called f. \">\ng(<x, messages>) := <x, messages \"called g. \">\nwrap(x)          := <x, \"\">  f takes an ordered pair of the form <x, messages> and returns an ordered pair. It leaves the first item untouched and appends \"called f. \" to the second item. Same with g .  You can compose these functions and get your original value, along with a string that shows which order the functions were called in:  f(g(wrap(x)))\n= f(g(<x, \"\">))\n= f(<x, \"called g. \">)\n= <x, \"called g. called f. \">  You dislike the fact that f and g are responsible for appending their own log messages to the previous logging information. (Just imagine for the sake of argument that instead of appending strings, f and g must perform complicated logic on the second item of the pair. It would be a pain to repeat that complicated logic in two -- or more -- different functions.)  You prefer to write simpler functions:  f(x)    := <x, \"called f. \">\ng(x)    := <x, \"called g. \">\nwrap(x) := <x, \"\">  But look at what happens when you compose them:  f(g(wrap(x)))\n= f(g(<x, \"\">))\n= f(<<x, \"\">, \"called g. \">)\n= <<<x, \"\">, \"called g. \">, \"called f. \">  The problem is that passing a pair into a function does not give you what you want. But what if you could feed a pair into a function:  feed(f, feed(g, wrap(x)))\n= feed(f, feed(g, <x, \"\">))\n= feed(f, <x, \"called g. \">)\n= <x, \"called g. called f. \">  Read feed(f, m) as \"feed m into f \". To feed a pair <x, messages> into a function f is to pass  x into f , get <y, message> out of f , and return <y, messages message> .  feed(f, <x, messages>) := let <y, message> = f(x)\n                          in  <y, messages message>  Notice what happens when you do three things with your functions:  First: if you wrap a value and then feed the resulting pair into a function:  feed(f, wrap(x))\n= feed(f, <x, \"\">)\n= let <y, message> = f(x)\n  in  <y, \"\" message>\n= let <y, message> = <x, \"called f. \">\n  in  <y, \"\" message>\n= <x, \"\" \"called f. \">\n= <x, \"called f. \">\n= f(x)  That is the same as passing the value into the function.  Second: if you feed a pair into wrap :  feed(wrap, <x, messages>)\n= let <y, message> = wrap(x)\n  in  <y, messages message>\n= let <y, message> = <x, \"\">\n  in  <y, messages message>\n= <x, messages \"\">\n= <x, messages>  That does not change the pair.  Third: if you define a function that takes x and feeds g(x) into f :  h(x) := feed(f, g(x))  and feed a pair into it:  feed(h, <x, messages>)\n= let <y, message> = h(x)\n  in  <y, messages message>\n= let <y, message> = feed(f, g(x))\n  in  <y, messages message>\n= let <y, message> = feed(f, <x, \"called g. \">)\n  in  <y, messages message>\n= let <y, message> = let <z, msg> = f(x)\n                     in  <z, \"called g. \" msg>\n  in <y, messages message>\n= let <y, message> = let <z, msg> = <x, \"called f. \">\n                     in  <z, \"called g. \" msg>\n  in <y, messages message>\n= let <y, message> = <x, \"called g. \" \"called f. \">\n  in <y, messages message>\n= <x, messages \"called g. \" \"called f. \">\n= feed(f, <x, messages \"called g. \">)\n= feed(f, feed(g, <x, messages>))  That is the same as feeding the pair into g and feeding the resulting pair into f .  You have most of a monad. Now you just need to know about the data types in your program.  What type of value is <x, \"called f. \"> ? Well, that depends on what type of value x is. If x is of type t , then your pair is a value of type \"pair of t and string\". Call that type M t .  M is a type constructor: M alone does not refer to a type, but M _ refers to a type once you fill in the blank with a type. An M int is a pair of an int and a string. An M string is a pair of a string and a string. Etc.  Congratulations, you have created a monad!  Formally, your monad is the tuple <M, feed, wrap> .  A monad is a tuple <M, feed, wrap> where:   M is a type constructor.  feed takes a (function that takes a t and returns an M u ) and an M t and returns an M u .  wrap takes a v and returns an M v .   t , u , and v are any three types that may or may not be the same. A monad satisfies the three properties you proved for your specific monad:   Feeding a wrapped t into a function is the same as passing the unwrapped t into the function.  Formally: feed(f, wrap(x)) = f(x)  Feeding an M t into wrap does nothing to the M t .  Formally: feed(wrap, m) = m  Feeding an M t (call it m ) into a function that   passes the t into g  gets an M u (call it n ) from g  feeds n into f   is the same as   feeding m into g  getting n from g  feeding n into f   Formally: feed(h, m) = feed(f, feed(g, m)) where h(x) := feed(f, g(x))   Typically, feed is called bind (AKA >>= in Haskell) and wrap is called return . ", "question_id": 44965}, "0.1878245873376727", 1], [{"answer_votes": "3", "answer_comments": null, "answer_body": " tl;dr  {-# LANGUAGE InstanceSigs #-}\n\nnewtype Id t = Id t\n\ninstance Monad Id where\n   return :: t -> Id t\n   return = Id\n\n   (=<<) :: (a -> Id b) -> Id a -> Id b\n   f =<< (Id x) = f x  Prologue  The application operator $ of functions  forall a b. a -> b  is canonically defined  ($) :: (a -> b) -> a -> b\nf $ x = f x\n\ninfixr 0 $  in terms of Haskell-primitive function application f x ( infixl 10 ). Composition . is defined in terms of $ as  (.) :: (b -> c) -> (a -> b) -> (a -> c)\nf . g = \\ x -> f $ g x\n\ninfixr 9 .  and satisfies the equivalences forall f g h.  f . id  =  f            :: c -> d   Right identity\n     id . g  =  g            :: b -> c   Left identity\n(f . g) . h  =  f . (g . h)  :: a -> d   Associativity  . is associative, and id is its right and left identity.  The Kleisli triple  In programming, a monad is functor type constructor with an instance of the monad type class. There are several equivalent variants of definition and implementation, each carrying slightly different intuitions about the monad abstraction.  A functor is a type constructor f of kind * -> * with an instance of the functor type class.  {-# LANGUAGE KindSignatures #-}\n\nclass Functor (f :: * -> *) where\n   map :: (a -> b) -> (f a -> f b)  In addition to following statically enforced type protocol, instances of the functor type class must obey the algebraic functor laws  forall f g.  map id  =  id           :: f t -> f t   Identity\nmap f . map g  =  map (f . g)  :: f a -> f c   Composition / short cut fusion  Functor computations have the type  forall f t. Functor f => f t  A computation c r consists in results  r within context  c .  Unary monadic functions or Kleisli arrows have the type  forall m a b. Functor m => a -> m b  Kleisi arrows are functions that take one argument a and return a monadic computation m b .  Monads are canonically defined in terms of the Kleisli triple  forall m. Functor m =>  (m, return, (=<<))  implemented as the type class  class Functor m => Monad m where\n   return :: t -> m t\n   (=<<)  :: (a -> m b) -> m a -> m b\n\ninfixr 1 =<<  The Kleisli identity  return is a Kleisli arrow that promotes a value t into monadic context m . Extension or Kleisli application  =<< applies a Kleisli arrow a -> m b to results of a computation m a .  Kleisli composition  <=< is defined in terms of extension as  (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)\nf <=< g = \\ x -> f =<< g x\n\ninfixr 1 <=<  <=< composes two Kleisli arrows, applying the left arrow to results of the right arrow\u2019s application.  Instances of the monad type class must obey the monad laws , most elegantly stated in terms of Kleisli composition: forall f g h.  return <=< g  =  g                :: b -> m c   Left identity\n   f <=< return  =  f                :: c -> m d   Right identity\n(f <=< g) <=< h  =  f <=< (g <=< h)  :: a -> m d   Associativity  <=< is associative, and return is its right and left identity.  Identity  The identity type  type Id t = t  is the identity function on types  Id :: * -> *  Interpreted as a functor,  return :: t -> Id t\n=      id :: t ->    t\n\n    (=<<) :: (a -> Id b) -> Id a -> Id b\n=     ($) :: (a ->    b) ->    a ->    b\n\n    (<=<) :: (b -> Id c) -> (a -> Id b) -> (a -> Id c)\n=     (.) :: (b ->    c) -> (a ->    b) -> (a ->    c)  In canonical Haskell, the identity monad is defined  newtype Id t = Id t\n\ninstance Functor Id where\n   map :: (a -> b) -> Id a -> Id b\n   map f (Id x) = Id (f x)\n\ninstance Monad Id where\n   return :: t -> Id t\n   return = Id\n\n   (=<<) :: (a -> Id b) -> Id a -> Id b\n   f =<< (Id x) = f x  Option  An option type  data Maybe t = Nothing | Just t  encodes computation Maybe t that may not yield a result t , computation that may \u201cfail\u201d. The option monad is defined  instance Functor Maybe where\n   map :: (a -> b) -> (Maybe a -> Maybe b)\n   map f (Just x) = Just (f x)\n   map _ Nothing  = Nothing\n\ninstance Monad Maybe where\n   return :: t -> Maybe t\n   return = Just\n\n   (=<<) :: (a -> Maybe b) -> Maybe a -> Maybe b\n   f =<< (Just x) = f x\n   _ =<< Nothing  = Nothing  a -> Maybe b is applied only if Maybe a yields a result.  newtype Nat = Nat Int  The natural numbers can be encoded as those integers greater than or equal to zero.  toNat :: Int -> Maybe Nat\ntoNat i | i >= 0    = Just (Nat i)\n        | otherwise = Nothing  The natural numbers are not closed under subtraction.  (-?) :: Nat -> Nat -> Maybe Nat\n(Nat n) -? (Nat m) = toNat (n - m)\n\ninfixl 6 -?  The option monad covers a basic form of exception handling.  (-? 20) <=< toNat :: Int -> Maybe Nat  List  The list monad, over the list type  data [] t = [] | t : [t]\n\ninfixr 5 :  and its additive monoid operation \u201cappend\u201d  (++) :: [t] -> [t] -> [t]\n(x : xs) ++ ys = x : xs ++ ys\n[]       ++ ys = ys\n\ninfixr 5 ++  encodes nonlinear computation [t] yielding a natural amount 0, 1, ... of results t .  instance Functor [] where\n   map :: (a -> b) -> ([a] -> [b])\n   map f (x : xs) = f x : map f xs\n   map _ []       = []\n\ninstance Monad [] where\n   return :: t -> [t]\n   return = (: [])\n\n   (=<<) :: (a -> [b]) -> [a] -> [b]\n   f =<< (x : xs) = f x ++ f =<< xs\n   _ =<< []       = []  Extension concatenates ++ all result lists [b] from applications f x of a Kleisli arrow a -> [b] to elements of [a] into a single result list [b] .  Let the proper divisors of a positive integer n be  divisors :: Integral t => t -> [t]\ndivisors n = filter (`divides` n) [2 .. n - 1]\n\ndivides :: Integral t => t -> t -> Bool\n(`divides` n) = (== 0) . (n `rem`)  then  forall n.  let f = f <=< divisors in f n  =  []  In defining the monad type class, instead of extension =<< , the Haskell standard uses its flip, the bind operator >>= .  class Applicative m => Monad m where\n   (>>=) :: forall a b. m a -> (a -> m b) -> m b\n\n   (>>) :: forall a b. m a -> m b -> m b\n   m >> k = m >>= \\ _ -> k\n   {-# INLINE (>>) #-}\n\n   return :: a -> m a\n   return = pure\n\n   fail :: String -> m a\n   fail s = errorWithoutStackTrace s  For simplicitys sake, this explanation uses the type class hierarchy  class              Functor f\nclass Functor m => Monad m  In Haskell, the current standard hierarchy is  class                  Functor f\nclass Functor p     => Applicative p\nclass Applicative m => Monad m  because not only is every monad a functor, but every applicative is a functor and every monad an applicative, too.  Using the list monad, the imperative pseudocode  for a in (1, ..., 10)\n   for b in (1, ..., 10)\n      p <- a * b\n      if even(p)\n         yield p  roughly translates to the do block  do a <- [1 .. 10]\n   b <- [1 .. 10]\n   let p = a * b\n   guard (even p)\n   return p  the equivalent monad comprehension  [p | a <- [1 .. 10], b <- [1 .. 10], let p = a * b, even p]  and the expression  [1 .. 10] >>= (\\ a ->\n   [1 .. 10] >>= (\\ b ->\n      let p = a * b in\n         guard (even p) >>\n            return p\n   )\n)  Do notation and monad comprehensions are syntactic sugar for nested bind expressions. The bind operator is used for local name binding of monadic results.  let x = v in e  =  (\\ x -> e) $ v    =  v & (\\ x -> e)\n  do r <- m; c  =  (\\ r -> c) =<< m  =  m >>= (\\ r -> c)  where  (&) :: a -> (a -> b) -> b\n(&) = flip ($)\n\ninfixl 0 &  The guard function is defined  guard :: Additive m => Bool -> m ()\nguard True  = return ()\nguard False = fail  where the unit type or \u201cempty tuple\u201d  data () = ()  Additive monads that support choice and failure can be abstracted over using a type class  class Monad m => Additive m where\n   fail  :: m t\n   (<|>) :: m t -> m t -> m t\n\ninfixl 3 <|>\n\ninstance Additive Maybe where\n   fail = Nothing\n\n   Nothing <|> m = m\n   m       <|> _ = m\n\ninstance Additive [] where\n   fail = []\n   (<|>) = (++)  where fail and <|> form a monoid forall k l m.  fail <|> l  =  l\n     k <|> fail  =  k\n(k <|> l) <|> m  =  k <|> (l <|> m)  and fail is the absorbing/annihilating zero element of additive monads  _ =<< fail  =  fail  If in  guard (even p) >> return p  even p is true, then the guard produces [()] , and, by the definition of >> , the local constant function  \\ _ -> return p  is applied to the result () . If false, then the guard produces the list monad\u2019s fail  [] , which yields no result for a Kleisli arrow to be applied >> to.  State  Infamously, monads are used to encode stateful computation.  A state processor is a function  forall st t. st -> (t, st)  that transitions a state st and yields a result t . The state  st can be anything. Nothing, flag, count, array, handle, machine, world.  The type of state processors is usually called  type State st t = st -> (t, st)  The state processor monad is the kinded * -> * functor State st . Kleisli arrows of the state processor monad are functions  forall st a b. a -> (State st) b  In canonical Haskell, the lazy version of the state processor monad is defined  newtype State st t = State { stateProc :: st -> (t, st) }\n\ninstance Functor (State st) where\n   map :: (a -> b) -> ((State st) a -> (State st) b)\n   map f (State p) = State $ \\ s0 -> let (x, s1) = p s0\n                                     in  (f x, s1)\n\ninstance Monad (State st) where\n   return :: t -> (State st) t\n   return x = State $ \\ s -> (x, s)\n\n   (=<<) :: (a -> (State st) b) -> (State st) a -> (State st) b\n   f =<< (State p) = State $ \\ s0 -> let (x, s1) = p s0\n                                     in  stateProc (f x) s1  A state processor is run by supplying an initial state:  run :: State st t -> st -> (t, st)\nrun = stateProc\n\neval :: State st t -> st -> t\neval = fst . run\n\nexec :: State st t -> st -> st\nexec = snd . run  State access is provided by primitives get and put , methods of abstraction over stateful monads:  {-# LANGUAGE MultiParamTypeClasses, FunctionalDependencies #-}\n\nclass Monad m => Stateful m st |\u00a0m -> st where\n   get :: m st\n   put :: st -> m ()  m -> st declares a functional dependency of the state type st on the monad m ; that a State t , for example, will determine the state type to be t uniquely.  instance Stateful (State st) st where\n   get :: State st st\n   get = State $ \\ s -> (s, s)\n\n   put :: st -> State st ()\n   put s = State $ \\ _ -> ((), s)  with the unit type used analogously to void in C.  modify :: Stateful m st => (st -> st) -> m ()\nmodify f = do\n   s <- get\n   put (f s)\n\ngets :: Stateful m st => (st -> t) -> m t\ngets f = do\n   s <- get\n   return (f s)  gets is often used with record field accessors.  The state monad equivalent of the variable threading  let s0 = 34\n    s1 = (+ 1) s0\n    n = (* 12) s1\n    s2 = (+ 7) s1\nin  (show n, s2)  where s0 :: Int , is the equally referentially transparent, but infinitely more elegant and practical  (flip run) 34\n   (do\n      modify (+ 1)\n      n <- gets (* 12)\n      modify (+ 7)\n      return (show n)\n   )  modify (+ 1) is a computation of type State Int () , except for its effect equivalent to return () .  (flip run) 34\n   (modify (+ 1) >>\n      gets (* 12) >>= (\\ n ->\n         modify (+ 7) >>\n            return (show n)\n      )\n   )  The monad law of associativity can be written in terms of >>=  forall m f g.  (m >>= f) >>= g  =  m >>= (\\ x -> f x >>= g)  or  do {                 do {                   do {\n   r1 <- do {           x <- m;                r0 <- m;\n      r0 <- m;   =      do {            =      r1 <- f r0;\n      f r0                 r1 <- f x;          g r1\n   };                      g r1             }\n   g r1                 }\n}                    }  Like in expression-oriented programming (e.g. Rust), the last statement of a block represents its yield. The bind operator is sometimes called a \u201cprogrammable semicolon\u201d.  Iteration control structure primitives from structured imperative programming are emulated monadically  for :: Monad m => (a -> m b) -> [a] -> m ()\nfor f = foldr ((>>) . f) (return ())\n\nwhile :: Monad m => m Bool -> m t -> m ()\nwhile c m = do\n   b <- c\n   if b then m >> while c m\n        else return ()\n\nforever :: Monad m => m t\nforever m = m >> forever m  Input/Output  data World  The I/O world state processor monad is a reconciliation of pure Haskell and the real world, of functional denotative and imperative operational semantics. A close analogue of the actual strict implementation:  type IO t = World -> (t, World)  Interaction is facilitated by impure primitives  getChar         :: IO Char\nputChar         :: Char -> IO ()\nreadFile        :: FilePath -> IO String\nwriteFile       :: FilePath -> String -> IO ()\nhSetBuffering   :: Handle -> BufferMode -> IO ()\nhTell           :: Handle -> IO Integer\n. . .              . . .  The impurity of code that uses IO primitives is permanently protocolized by the type system. Because purity is awesome, what happens in IO , stays in IO .  unsafePerformIO :: IO t -> t  Or, at least, should.  The type signature of a Haskell program  main :: IO ()\nmain = putStrLn \"Hello, World!\"  expands to  World -> ((), World)  A function that transforms a world.  Epilogue  The category whiches objects are Haskell types and whiches morphisms are functions between Haskell types is, \u201cfast and loose\u201d, the category Hask .  A functor T is a mapping from a category C to a category D ; for each object in C an object in D  Tobj :  Obj(C) -> Obj(D)\n   f :: *      -> *  and for each morphism in C a morphism in D  Tmor :  HomC(X, Y) -> HomD(Tobj(X), Tobj(Y))\n map :: (a -> b)   -> (f a -> f b)  where X , Y are objects in C . HomC(X, Y) is the homomorphism class of all morphisms X -> Y in C . The functor must preserve morphism identity and composition, the \u201cstructure\u201d of C , in D .  Tmor    Tobj\n\n      T(id)  =  id        : T(X) -> T(X)   Identity\nT(f) . T(g)  =  T(f . g)  : T(X) -> T(Z)   Composition  The Kleisli category of a category C is given by a Kleisli triple  <T, eta, _*>  of an endofunctor  T : C -> C  ( f ), an identity morphism eta ( return ), and an extension operator * ( =<< ).  Each Kleisli morphism in Hask  f :  X -> T(Y)\n      f :: a -> m b  by the extension operator  (_)* :  Hom(X, T(Y)) -> Hom(T(X), T(Y))\n  (=<<) :: (a -> m b)   -> (m a -> m b)  is given a morphism in Hask \u2019s Kleisli category  f* :  T(X) -> T(Y)\n(f =<<) :: m a  -> m b  Composition in the Kleisli category .T is given in terms of extension  f .T g  =  f* . g       :  X -> T(Z)\nf <=< g  =  (f =<<) . g  :: a -> m c  and satisfies the category axioms  eta .T g  =  g                :  Y -> T(Z)   Left identity\n   return <=< g  =  g                :: b -> m c\n\n       f .T eta  =  f                :  Z -> T(U)   Right identity\n   f <=< return  =  f                :: c -> m d\n\n  (f .T g) .T h  =  f .T (g .T h)    :  X -> T(U)   Associativity\n(f <=< g) <=< h  =  f <=< (g <=< h)  :: a -> m d  which, applying the equivalence transformations  eta .T g  =  g\n     eta* . g  =  g               By definition of .T\n     eta* . g  =  id . g          forall f.  id . f  =  f\n         eta*  =  id              forall f g h.  f . h  =  g . h  ==>  f  =  g\n\n(f .T g) .T h  =  f .T (g .T h)\n(f* . g)* . h  =  f* . (g* . h)   By definition of .T\n(f* . g)* . h  =  f* . g* . h     . is associative\n    (f* . g)*  =  f* . g*         forall f g h.  f . h  =  g . h  ==>  f  =  g  in terms of extension are canonically given  eta*  =  id                 :  T(X) -> T(X)   Left identity\n       (return =<<)  =  id                 :: m t -> m t\n\n           f* . eta  =  f                  :  Z -> T(U)      Right identity\n   (f =<<) . return  =  f                  :: c -> m d\n\n          (f* . g)*  =  f* . g*            :  T(X) -> T(Z)   Associativity\n(((f =<<) . g) =<<)  =  (f =<<) . (g =<<)  :: m a -> m c  Monads can also be defined in terms not of Kleislian extension, but a natural transformation mu , in programming called join . A monad is defined in terms of mu as a triple over a category C , of an endofunctor  T :  C -> C\n     f :: * -> *  and two natural tranformations  eta :  Id -> T\nreturn :: t  -> f t\n\n    mu :  T . T   -> T\n  join :: f (f t) -> f t  satisfying the equivalences  mu . T(mu)  =  mu . mu               :  T . T . T -> T . T   Associativity\n  join . map join  =  join . join           :: f (f (f t)) -> f t\n\n      mu . T(eta)  =  mu . eta       =  id  :  T -> T               Identity\njoin . map return  =  join . return  =  id  :: f t -> f t  The monad type class is then defined  class Functor m => Monad m where\n   return :: t -> m t\n   join   :: m (m t) -> m t  The canonical mu implementation of the option monad:  instance Monad Maybe where\n   return = Just\n\n   join (Just m) = m\n   join Nothing  = Nothing  The concat function  concat :: [[a]] -> [a]\nconcat (x : xs) = x ++ concat xs\nconcat []       = []  is the join of the list monad.  instance Monad [] where\n   return :: t -> [t]\n   return = (: [])\n\n   (=<<) :: (a -> [b]) -> ([a] -> [b])\n   (f =<<) = concat . map f  Implementations of join can be translated from extension form using the equivalence  mu  =  id*           :  T . T -> T\n   join  =  (id =<<)      :: m (m t) -> m t  The reverse translation from mu to extension form is given by  f*  =  mu . T(f)     :  T(X) -> T(Y)\n(f =<<)  =  join . map f  :: m a -> m b    Philip Wadler: Monads for functional programming  Simon L Peyton Jones, Philip Wadler: Imperative functional programming  Jonathan M. D. Hill, Keith Clarke: An introduction to category theory, category theory monads, and their relationship to functional programming \u00b4  Kleisli category  Eugenio Moggi: Notions of computation and monads  What a monad is not    But why should a theory so abstract be of any use for programming?  The answer is simple: as computer scientists, we value abstraction ! When we design the interface to a software component, we want it to reveal as little as possible about the implementation. We want to be able to replace the implementation with many alternatives, many other \u2018instances\u2019 of the same \u2018concept\u2019. When we design a generic interface to many program libraries, it is even more important that the interface we choose have a variety of implementations. It is the generality of the monad concept which we value so highly, it is because category theory is so abstract that its concepts are so useful for programming.  It is hardly suprising, then, that the generalisation of monads that we present below also has a close connection to category theory. But we stress that our purpose is very practical: it is not to \u2018implement category theory\u2019, it is to find a more general way to structure combinator libraries. It is simply our good fortune that mathematicians have already done much of the work for us!   from Generalising Monads to Arrows by John Hughes ", "question_id": 44965}, "0.1878245873376727", 1], [{"answer_votes": "2", "answer_comments": null, "answer_body": " Another attempt at explaining monads, using just Python lists and the map function. I fully accept this isn't a full explanation, but I hope it gets at the core concepts.  I got the basis of this from the funfunfunction video on Monads and the Learn You A Haskell chapter 'For a Few Monads More' . I highly recommend watching the funfunfunction video.  At it's very simplest, Monads are objects that have a map and flatMap functions ( bind in Haskell). There are some extra required properties , but these are the core ones.  flatMap 'flattens' the output of map, for lists this just concatenates the values of the list e.g.  concat([[1], [4], [9]]) = [1, 4, 9]  So in Python we can very basically implement a Monad with just these two functions:  def flatMap(func, lst):\n    return concat(map(func, lst))\n\ndef concat(lst):\n    return sum(lst, [])  func is any function that takes a value and returns a list e.g.  lambda x: [x*x]  Explanation  For clarity I created the concat function in Python via a simple function , which sums the lists i.e. [] + [1] + [4] + [9] = [1, 4, 9] (Haskell has a native concat method).  I'm assuming you know what the map function is e.g.:  >>> list(map(lambda x: [x*x], [1,2,3]))\n[[1], [4], [9]]  Flattening is the key concept of Monads and for each object which is a Monad this flattening allows you to get at the value that is wrapped in the Monad.  Now we can call:  >>> flatMap(lambda x: [x*x], [1,2,3])\n[1, 4, 9]  This lambda is taking a value x and putting it into a list. A monad works with any function that goes from a value to a type of the monad, so a list in this case.  That's your monad defined .  I think the question of why they're useful has been answered in other questions.  More explanation  Other examples that aren't lists are JavaScript Promises, which have the then method and JavaScript Streams which have a flatMap method.  So Promises and Streams use a slightly different function which flattens out a Stream or a Promise and returns the value from within.  The Haskell list monad has the following definition:  instance Monad [] where  \n    return x = [x]  \n    xs >>= f = concat (map f xs)  \n    fail _ = []  i.e. there are three functions return (not to be confused with return in most other languages), >>= (the flatMap ) and fail .  Hopefully you can see the similarity between:  xs >>= f = concat (map f xs)  and:  def flatMap(f, xs):\n    return concat(map(f, xs)) ", "question_id": 44965}, "0.1878245873376727", 1], [{"answer_votes": "2", "answer_comments": [" here is an implementation: github.com/brianspinos777/Programming_cheat_sheets/blob/master/\u2026 \u2013 Brian Joseph Spinos  Dec 21 '17 at 21:23 ", " IOW, Monad is generalized function call protocol. \u2013 Will Ness  Jan 28 at 16:09 ", " You answer is the most helpful in my opinion. Although I have to say that I think the emphasis needs to be on the fact that the functions you're refering to don't just involve values in contexts, they actively put values in contexts.  So for example, a function, f :: m a -> m b would very easily compose with another function, g :: m b -> m c.  But monads (bind specifically) allows us to perpetually compose functions which put their input in the same context, without us needing to take the value out of that context first (which would effectively remove information from the value) \u2013 James  Mar 23 at 18:41  ", " @James I think that should be the emphasis for functors? \u2013 Jonas  Mar 24 at 5:03 ", " @Jonas I guess I didn't explain propperly.   When I say that the functions put values in contexts, I mean that they have type (a -> m b). These are very useful since putting a value into a context adds new information to it but it would usually be difficult to chain a (a -> m b) and a (b -> m c) together since we can't just take the value out of the context. So we would have to use some convoluted process to chain these functions together in a sensible way depending on the specific context and monads just allow us to do this in a consistent way, regardless of the context. \u2013 James  Mar 24 at 16:23 "], "answer_body": " I will try to explain Monad in the context of Haskell.  In functional programming, function composition is important. It allows our program to consist of small, easy-to-read functions.  Let's say we have two functions: g :: Int -> String and f :: String -> Bool .  We can do (f . g) x , which is just the same as f (g x) , where x is an Int value.  When doing composition/applying the result of one function to another, having the types match up is important. In the above case, the type of the result returned by g must be the same as the type accepted by f .  But sometimes values are in contexts, and this makes it a bit less easy to line up types. (Having values in contexts is very useful. For example, the Maybe Int type represents an Int value that may not be there, the IO String type represents a String value that is there as a result of performing some side effects.)  Let's say we now have g1 :: Int -> Maybe String and f1 :: String -> Maybe Bool . g1 and f1 are very similar to g and f respectively.  We can't do (f1 . g1) x or f1 (g1 x) , where x is an Int value. The type of the result returned by g1 is not what f1 expects.  We could compose f and g with the . operator, but now we can't compose f1 and g1 with . . The problem is that we can't straightforwardly pass a value in a context to a function that expects a value that is not in a context.  Wouldn't it be nice if we introduce an operator to compose g1 and f1 , such that we can write (f1 OPERATOR g1) x ? g1 returns a value in a context. The value will be taken out of context and applied to f1 . And yes, we have such an operator. It's <=< .  We also have the >>= operator that does for us the exact same thing, though in a slightly different syntax.  We write: g1 x >>= f1 . g1 x is a Maybe Int value. The >>= operator helps take that Int value out of the \"perhaps-not-there\" context, and apply it to f1 . The result of f1 , which is a Maybe Bool , will be the result of the entire >>= operation.  And finally, why is Monad useful? Because Monad is the type class that defines the >>= operator, very much the same as the Eq type class that defines the == and /= operators.  To conclude, the Monad type class defines the >>= operator that allows us to pass values in a context (we call these monadic values) to functions that don't expect values in a context. The context will be taken care of.  If there is one thing to remember here, it is that Monad s allow function composition that involves values in contexts . ", "question_id": 44965}, "0.1878245873376727", 1], [{"answer_votes": "1", "answer_comments": null, "answer_body": " http://mikehadlow.blogspot.com/2011/02/monads-in-c-8-video-of-my-ddd9-monad.html  This is the video you are looking for.  Demonstrating in C# what the problem is with composition and aligning the types, and then implementing them properly in C#. \nTowards the end he displays how the same C# code looks in F# and finally in Haskell. ", "question_id": 44965}, "0.1878245873376727", 1], [{"answer_votes": "0", "answer_comments": null, "answer_body": " Let the below \" {| a |m} \" represent some piece of monadic data. A data type which advertises an a :  (I got an a!)\n          /        \n    {| a |m}  Function, f , knows how to create a monad, if only it had an a :  (Hi f! What should I be?)\n                      /\n(You?. Oh, you'll be /\n that data there.)  /\n /                 /  (I got a b.)\n|    --------------      |\n|  /                     |\nf a                      |\n  |--later->       {| b |m}  Here we see function, f , tries to evaluate a monad but gets rebuked.  (Hmm, how do I get that a?)\n o       (Get lost buddy.\no         Wrong type.)\no       /\nf {| a |m}  Funtion, f , finds a way to extract the a by using >>= .  (Muaahaha. How you \n         like me now!?)       \n    (Better.)      \\\n        |     (Give me that a.)\n(Fine, well ok.)    |\n         \\          |\n   {| a |m}   >>=   f  Little does f know, the monad and >>= are in collusion.  (Yah got an a for me?)       \n(Yeah, but hey    | \n listen. I got    |\n something to     |\n tell you first   |\n ...)   \\        /\n         |      /\n   {| a |m}   >>=   f  But what do they actually talk about? Well, that depends on the monad. Talking solely in the abstract has limited use; you have to have some experience with particular monads to flesh out the understanding.  For instance, the data type Maybe  data Maybe a = Nothing | Just a  has a monad instance which will acts like the following...  Wherein, if the case is Just a  (Yah what is it?)       \n(... hm? Oh,      |\nforget about it.  |\nHey a, yr up.)    | \n            \\     |\n(Evaluation  \\    |\ntime already? \\   |\nHows my hair?) |  |\n      |       /   |\n      |  (It's    |\n      |  fine.)  /\n      |   /     /    \n   {| a |m}   >>=   f  But for the case of Nothing  (Yah what is it?)       \n(... There      |\nis no a. )      |\n  |        (No a?)\n(No a.)         |\n  |        (Ok, I'll deal\n  |         with this.)\n   \\            |\n    \\      (Hey f, get lost.) \n     \\          |   ( Where's my a? \n      \\         |     I evaluate a)\n       \\    (Not any more  |\n        \\    you don't.    |\n         |   We're returning\n         |   Nothing.)   /\n         |      |       /\n         |      |      /\n         |      |     /\n   {| a |m}   >>=   f      (I got a b.)\n                    |  (This is   \\\n                    |   such a     \\\n                    |   sham.) o o  \\\n                    |               o|\n                    |--later-> {| b |m}  So the Maybe monad lets a computation continue if it actually contains the a it advertises, but aborts the computation if it doesn't. The result, however is still a piece of monadic data, though not the output of f . For this reason, the Maybe monad is used to represent the context of failure.  Different monads behave differently. Lists are other types of data with monadic instances. They behave like the following:  (Ok, here's your a. Well, its\n a bunch of them, actually.)\n  |\n  |    (Thanks, no problem. Ok\n  |     f, here you go, an a.)\n  |       |\n  |       |        (Thank's. See\n  |       |         you later.)\n  |  (Whoa. Hold up f,      |\n  |   I got another         |\n  |   a for you.)           |\n  |       |      (What? No, sorry.\n  |       |       Can't do it. I \n  |       |       have my hands full\n  |       |       with all these \"b\" \n  |       |       I just made.) \n  |  (I'll hold those,      |\n  |   you take this, and   /\n  |   come back for more  /\n  |   when you're done   / \n  |   and we'll do it   / \n  |   again.)          /\n   \\      |  ( Uhhh. All right.)\n    \\     |       /    \n     \\    \\      /\n{| a |m}   >>=  f  In this case, the function knew how to make a list from it's input, but didn't know what to do with extra input and extra lists. The bind >>= , helped f out by combining the multiple outputs. I include this example to show that while >>= is responsible for extracting a , it also has access to the eventual bound output of f . Indeed, it will never extract any a unless it knows the eventual output has the same type of context.  There are other monads which are used to represent different contexts. Here's some characterizations of a few more. The IO monad doesn't actually have an a , but it knows a guy and will get that a for you. The State st monad has a secret stash of st that it will pass to f under the table, even though f just came asking for an a . The Reader r monad is similar to State st , although it only lets f look at r .  The point in all this is that any type of data which is declared itself to be a Monad is declaring some sort of context around extracting a value from the monad. The big gain from all this? Well, its easy enough to couch a calculation with some sort of context. It can get messy, however, when stringing together multiple context laden calculations. The monad operations take care of resolving the interactions of context so that the programmer doesn't have to.  Note, that use of the >>= eases a mess by by taking some of the autonomy away from f . That is, in the above case of Nothing for instance, f no longer gets to decide what to do in the case of Nothing ; it's encoded in >>= . This is the trade off. If it was necessary for f to decide what to do in the case of Nothing , then f should have been a function from Maybe a to Maybe b . In this case, Maybe being a monad is irrelevant.  Note, however, that sometimes a data type does not export it's constructors (looking at you IO), and if we want to work with the advertised value we have little choice but to work with it's monadic interface. ", "question_id": 44965}, "0.1878245873376727", 1], [{"answer_votes": "0", "answer_comments": null, "answer_body": " If you are asking for a succinct, practical explanation for something so abstract, then you can only hope for an abstract answer:  a -> b  is one way of representing a computation from a s to b s. You can chain computations, aka compose them together:  (b -> c) -> (a -> b) -> (a -> c)  More complex computations demand more complex types, e.g.:  a -> f b  is the type of computations from a s to b s that are into f s. You can also compose them:  (b -> f c) -> (a -> f b) -> (a -> f c)  It turns out this pattern appears literally everywhere and has the same properties as the first composition above (associativity, right- and left-identity).  One had to give this pattern a name, but then would it help to know that the first composition is formally characterised as a Semigroupoid ?  \"Monads are just as interesting and important as parentheses\" (Oleg Kiselyov) ", "question_id": 44965}, "0.1878245873376727", 1], [{"answer_votes": "34", "answer_comments": [" The only problem with Wadler's paper is the notation is different but I agree that the paper is pretty compelling and a clear concise motivation for applying monads. \u2013 Jared Updike  Jul 31 '09 at 22:34 ", " +1 for the \"monad tutorial fallacy\". Tutorials on monads are akin to having several tutorials trying to explain the concept of integer numbers. One tutorial would say, \"1 is similar to an apple\"; another tutorial says, \"2 is like a pear\"; a third one says, \"3 is basically an orange\". But you never get the whole picture from any single tutorial. What I've taken from that is that monads are an abstract concept which can be used for many quite different purposes. \u2013 stakx  Jan 14 '11 at 7:30  ", " @stakx: Yes, true. But I didn't mean that monads are an abstraction that you cannot learn or shouldn't learn; only that it's best to learn it after you've seen enough concrete examples to perceive a single underlying abstraction. See my other answer here . \u2013 ShreevatsaR  Jan 14 '11 at 12:22 ", " Sometimes I feel that there are so many tutorials that try to convince the reader that monads are useful by using code that do complicated or useful stuff. That hindered my understanding for months. I don't learn that way. I prefer to see extremely simple code, doing something stupid that I can mentally go through and I couldn't find this kind of example. I can't learn if the first example is a monad to parse a complicate grammar. I can learn if it's a monad to sum integers. \u2013 Rafael S. Calsaverini  Jan 23 '11 at 23:11  ", " Mentioning only type constructor is incomplete: stackoverflow.com/a/37345315/1614973 \u2013 Dmitri Zaitsev  May 20 '16 at 12:18 "], "answer_body": " (See also the answers at What is a monad? )  A good motivation to Monads is sigfpe (Dan Piponi)'s You Could Have Invented Monads! (And Maybe You Already Have) . There are a LOT of other monad tutorials , many of which misguidedly try to explain monads in \"simple terms\" using various analogies: this is the monad tutorial fallacy ; avoid them.  As DR MacIver says in Tell us why your language sucks :   So, things I hate about Haskell:   Let\u2019s start with the obvious. Monad tutorials. No, not monads. Specifically the tutorials. They\u2019re endless, overblown and dear god are they tedious. Further, I\u2019ve never seen any convincing evidence that they actually help. Read the class definition, write some code, get over the scary name.  You say you understand the Maybe monad? Good, you're on your way. Just start using other monads and sooner or later you'll understand what monads are in general.  [If you are mathematically oriented, you might want to ignore the dozens of tutorials and learn the definition, or follow lectures in category theory :)\nThe main part of the definition is that a Monad M involves a \"type constructor\" that defines for each existing type \"T\" a new type \"M T\", and some ways for going back and forth between \"regular\" types and \"M\" types.]  Also, surprisingly enough, one of the best introductions to monads is actually one of the early academic papers introducing monads, Philip Wadler's Monads for functional programming . It actually has practical, non-trivial motivating examples, unlike many of the artificial tutorials out there. ", "question_id": 44965}, "0.2782666329294443", 2], [{"answer_votes": "24", "answer_comments": null, "answer_body": " Monads are to control flow what abstract data types are to data.  In other words, many developers are comfortable with the idea of Sets, Lists, Dictionaries (or Hashes, or Maps), and Trees. Within those data types there are many special cases (for instance InsertionOrderPreservingIdentityHashMap).  However, when confronted with program \"flow\" many developers haven't been exposed to many more constructs than if, switch/case, do, while, goto (grr), and (maybe) closures.  So, a monad is simply a control flow construct. A better phrase to replace monad would be 'control type'.  As such, a monad has slots for control logic, or statements, or functions - the equivalent in data structures would be to say that some data structures allow you to add data, and remove it.  For example, the \"if\" monad:  if( clause ) then block  at its simplest has two slots - a clause, and a block. The if monad is usually built to evaluate the result of the clause, and if not false, evaluate the block. Many developers are not introduced to monads when they learn 'if', and it just isn't necessary to understand monads to write effective logic.  Monads can become more complicated, in the same way that data structures can become more complicated, but there are many broad categories of monad that may have similar semantics, but differing implementations and syntax.  Of course, in the same way that data structures may be iterated over, or traversed, monads may be evaluated.  Compilers may or may not have support for user-defined monads. Haskell certainly does. Ioke has some similar capabilities, although the term monad is not used in the language. ", "question_id": 44965}, "0.2782666329294443", 2], [{"answer_votes": "8", "answer_comments": [" If you use jQuery, this explanation can be very helpful, especially if your Haskell isn't strong \u2013 byteclub  Dec 15 '10 at 16:16 ", " JQuery is emphatically not a monad. The linked article is wrong. \u2013 Tony Morris  Jun 19 '12 at 8:13 ", " Being \"emphatic\" isn't very convincing.  For some useful discussion on the topic, see Is jQuery a monad - Stack Overflow \u2013 nealmcb  Mar 25 '13 at 4:23 ", " See also Douglas Crackford's Google Talk Monads and Gonads and his Javascript code for doing modads, expanding on the similar behavior of AJAX libraries and Promises: douglascrockford/monad \u00b7 GitHub \u2013 nealmcb  Mar 25 '13 at 5:10 "], "answer_body": " In addition to the excellent answers above, let me offer you a link to the following article (by Patrick Thomson) which explains monads by relating the concept to the JavaScript library jQuery (and its way of using \"method chaining\" to manipulate the DOM): jQuery is a Monad  The jQuery documentation itself doesn't refer to the term \"monad\" but talks about the \"builder pattern\" which is probably more familiar.  This doesn't change the fact that you have a proper monad there maybe without even realizing it. ", "question_id": 44965}, "0.2782666329294443", 2], [{"answer_votes": "5", "answer_comments": null, "answer_body": " The two things that helped me best when learning about there were:  Chapter 8, \"Functional Parsers,\" from Graham Hutton's book Programming in Haskell . This doesn't mention monads at all, actually, but if you can work through chapter and really understand everything in it, particularly how a sequence of bind operations is evaluated, you'll understand the internals of monads. Expect this to take several tries.  The tutorial All About Monads . This gives several good examples of their use, and I have to say that the analogy in Appendex I worked for me. ", "question_id": 44965}, "0.2782666329294443", 2], [{"answer_votes": "5", "answer_comments": null, "answer_body": " Monoid appears to be something that ensures that all operations defined on a Monoid and a supported type will always return a supported type inside the Monoid. Eg, Any number + Any number = A number, no errors.  Whereas division accepts two fractionals, and returns a fractional, which defined division by zero as Infinity in haskell somewhy(which happens to be a fractional somewhy)...  In any case, it appears Monads are just a way to ensure that your chain of operations behaves in a predictable way, and a function that claims to be Num -> Num, composed with another function of Num->Num called with x does not say, fire the missiles.  On the other hand, if we have a function which does fire the missiles, we can compose it with other functions which also fire the missiles, because our intent is clear -- we want to fire the missiles -- but it won't try printing \"Hello World\" for some odd reason.  In Haskell, main is of type IO (), or IO [()], the distiction is strange and I will not discuss it but here's what I think happens:  If I have main, I want it to do a chain of actions, the reason I run the program is to produce an effect -- usually though IO. Thus I can chain IO operations together in main in order to -- do IO, nothing else.  If I try to do something which does not \"return IO\", the program will complain that the chain does not flow, or basically \"How does this relate to what we are trying to do -- an IO action\", it appears to force the programmer to keep their train of thought, without straying off and thinking about firing the missiles, while creating algorithms for sorting -- which does not flow.  Basically, Monads appear to be a tip to the compiler that \"hey, you know this function that returns a number here, it doesn't actually always work, it can sometimes produce a Number, and sometimes Nothing at all, just keep this in mind\". Knowing this, if you try to assert a monadic action, the monadic action may act as a compile time exception saying \"hey, this isn't actually a number, this CAN be a number, but you can't assume this, do something to ensure that the flow is acceptable.\" which prevents unpredictable program behavior -- to a fair extent.  It appears monads are not about purity, nor control, but about maintaining an identity of a category on which all behavior is predictable and defined, or does not compile. You cannot do nothing when you are expected to do something, and you cannot do something if you are expected to do nothing (visible).  The biggest reason I could think of for Monads is -- go look at Procedural/OOP code, and you will notice that you do not know where the program starts, nor ends, all you see is a lot of jumping and a lot of math,magic,and missiles. You will not be able to maintain it, and if you can, you will spend quite a lot of time wrapping your mind around the whole program before you can understand any part of it, because modularity in this context is based on interdependant \"sections\" of code, where code is optimized to be as related as possible for promise of efficiency/inter-relation. Monads are very concrete, and well defined by definition, and ensure that the flow of program is possible to analyze, and isolate parts which are hard to analyze -- as they themselves are monads. A monad appears to be a \"comprehensible unit which is predictable upon its full understanding\" -- If you understand \"Maybe\" monad, there's no possible way it will do anything except be \"Maybe\", which appears trivial, but in most non monadic code, a simple function \"helloworld\" can fire the missiles, do nothing, or destroy the universe or even distort time -- we have no idea nor have any guarantees that IT IS WHAT IT IS. A monad GUARANTEES that IT IS WHAT IT IS. which is very powerful.  All things in \"real world\" appear to be monads, in the sense that it is bound by definite observable laws preventing confusion. This does not mean we have to mimic all the operations of this object to create classes, instead we can simply say \"a square is a square\", nothing but a square, not even a rectangle nor a circle, and \"a square has area of the length of one of it's existing dimensions multiplied by itself. No matter what square you have, if it's a square in 2D space, it's area absolutely cannot be anything but its length squared, it's almost trivial to prove. This is very powerful because we do not need to make assertions to make sure that our world is the way it is, we just use implications of reality to prevent our programs from falling off track.  Im pretty much guaranteed to be wrong but I think this could help somebody out there, so hopefully it helps somebody. ", "question_id": 44965}, "0.2782666329294443", 2], [{"answer_votes": "4", "answer_comments": null, "answer_body": " If I've understood correctly, IEnumerable is derived from monads. I wonder if that might be an interesting angle of approach for those of us from the C# world?  For what it's worth, here are some links to tutorials that helped me (and no, I still haven't understood what monads are).   http://osteele.com/archives/2007/12/overloading-semicolon  http://spbhug.folding-maps.org/wiki/MonadsEn  http://www.loria.fr/~kow/monads/  ", "question_id": 44965}, "0.2782666329294443", 2], [{"answer_votes": "3", "answer_comments": [" See if this helps projects.tmorris.net/public/what-does-monad-mean/artifacts/1.1/\u2026 \u2013 Tony Morris  Sep 9 '10 at 22:17  ", " Google Code is going to be closed down on 2016-01-15. Most projects are now read-only, as of 2015-08-24. \u2013 Peter Mortensen  Aug 28 '15 at 17:37 "], "answer_body": " http://code.google.com/p/monad-tutorial/ is a work in progress to address exactly this question. ", "question_id": 44965}, "0.2782666329294443", 2], [{"answer_votes": "2", "answer_comments": [" You seem to be the only one who finally addressed my main problem with understanding Monads. Nobody ever talks about HOW can the value be extracted. Is it implementation dependant? \u2013 Vinicius Seufitele  Aug 22 '12 at 16:39 ", " @ViniciusSeufitele, thanks for your comment. I'm afraid that my understanding hasn't advanced a great deal since I wrote this answer, so I can't really add much. The value extraction logically has to exist, so maybe that's why nobody bothers to mention it. \u2013 Benjol  Aug 23 '12 at 5:45 ", " I have a discussion that treats the monad as a type expansion where the original type, b, is converted to an expanded type M<b> and the associated operators are wrapped to now service M<b>. These wrappers are what will handle the peculiarities of the monad. In particular, extracting the original type from the expanded type and passing it to it's wrapped operator and subsequently promoting the result. The benefit of the monad is that you retain simple declarative expressions. In my treatment I discussed expanding the numeric types system to include a DivByZero value to obviate the need to check \u2013 George  Oct 13 '14 at 16:45 ", " @ViniciusSeufitele , yes it is implementation dependent. The person writing the function >>= has access to the internals of the monad. For example see Maybe Monad and look for instance Monad Maybe . You'll see that when the left hand side is Just x then we return k x . The pattern matching does the unwrap for you. Something analogous happens in every monad implementation. \u2013 Michael Welch  Feb 3 '15 at 16:59  "], "answer_body": " Princess 's explanation of F# Computation Expressions helped me, though I still can't say I've really understood.  EDIT : this series - explaining monads with javascript - is the one that 'tipped the balance' for me.   http://blog.jcoglan.com/2011/03/05/translation-from-haskell-to-javascript-of-selected-portions-of-the-best-introduction-to-monads-ive-ever-read/  http://blog.jcoglan.com/2011/03/06/monad-syntax-for-javascript/  http://blog.jcoglan.com/2011/03/11/promises-are-the-monad-of-asynchronous-programming/   I think that understanding monads is something that creeps up on you. In that sense, reading as many 'tutorials' as you can is a good idea, but often strange stuff (unfamiliar language or syntax) prevents your brain from concentrating on the essential.  Some things that I had difficulty understanding:   Rules-based explanations never worked for me, because most practical examples actually require more than just return/bind.  Also, calling them rules didn't help. It is more a case of \"there are these things that have something in common, let's call the things 'monads', and the bits in common 'rules'\".  Return ( a -> M<a> ) and Bind ( M<a> -> (a -> M<b>) -> M<b> ) are great, but what I could never understand is HOW Bind could extract the a from M<a> in order to pass it into a -> M<b> . I don't think I've ever read anywhere (maybe it's obvious to everyone else), that the reverse of Return ( M<a> -> a ) has to exist inside the monad, it just doesn't need to be exposed.  ", "question_id": 44965}, "0.2782666329294443", 2], [{"answer_votes": "951", "answer_comments": [" As someone who has had a great deal of problems understanding monads, I can say that this answer helped.. a little. However, there's still some things that I don't understand. In what way is the list comprehension a monad? Is there an expanded form of that example? Another thing that really bothers me about most monad explanations, including this one- Is that they keep mixing up \"what is a monad?\" with \"what is a monad good for?\" and \"How is a monad implemented?\".  you jumped that shark when you wrote \"A monad is basically just a type that supports the >>= operator.\" Which just had me... \u2013 Breton  Aug 10 '09 at 2:00 ", " Also I disagree with your conclusion about why monads are hard. If monads themselves aren't complex, then you should be able to explain what they are without a bunch of baggage. I don't want to know about the implementation when I ask the question \"What is a monad\", I want to know what itch it's meant to be scratching. So far it seems like the answer is \"Because the authors of haskell are sadomasochists and decided that you should do something stupidly complex to accomplish simple things, so you HAVE to learn monads to use haskell, not because they're in any way useful in themselves\"... \u2013 Breton  Aug 10 '09 at 2:08 ", " But.. that can't be right, can it? I think monads are hard because nobody can seem to figure out how to explain them without getting caught up in confusing implementation details. I mean.. what is a school bus? It's a metal platform with a device in the front which consumes a refined petroleum product to drive in a cycle some metallic pistons, which in turn rotate a crank shaft attached to some gears which drive some wheels. The wheels have inflated rubber bags around them which interface with an ashphalt surface to cause a collection of seats to move forward. The seats move forward because... \u2013 Breton  Aug 10 '09 at 2:12 ", " I read all of this and still don't know what a monad is, aside from the fact that it's something Haskell programmers don't understand well enough to explain. The examples don't help much, given that these are all things one can do without monads, and this answer doesn't make it clear how monads make them any easier, only more confusing. The one part of this answer that came close to being useful was where the syntactic sugar of example #2 was removed. I say came close because, aside from the first line, the expansion doesn't bear any real resemblance to the original. \u2013 Laurence Gonsalves  Dec 19 '11 at 4:44 ", " Another problem that seems to be endemic to explanations of monads is that it's written in Haskell. I'm not saying Haskell is a bad language -- I'm saying it's a bad language for explaining monads. If I knew Haskell I'd already understand monads, so if you want to explain monads, start by using a language that people who don't know monads are more likely to understand. If you must use Haskell, don't use the syntactic sugar at all -- use the smallest, simplest subset of the language you can, and don't assume an understanding of Haskell IO. \u2013 Laurence Gonsalves  Dec 19 '11 at 4:50 "], "answer_body": " First: The term monad is a bit vacuous if you are not a mathematician. An alternative term is computation builder which is a bit more descriptive of what they are actually useful for.  You ask for practical examples:  Example 1: List comprehension :  [x*2 | x<-[1..10], odd x]  This expression returns the doubles of all odd numbers in the range from 1 to 10. Very useful!  It turns out this is really just syntactic sugar for some operations within the List monad. The same list comprehension can be written as:  do\n   x <- [1..10]\n   if odd x \n       then [x * 2] \n       else []  Or even:  [1..10] >>= (\\x -> if odd x then [x*2] else [])  Example 2: Input/Output :  do\n   putStrLn \"What is your name?\"\n   name <- getLine\n   putStrLn (\"Welcome, \" ++ name ++ \"!\")  Both examples use monads, AKA computation builders. The common theme is that the monad chains operations in some specific, useful way. In the list comprehension, the operations are chained such that if an operation returns a list, then the following operations are performed on every item in the list. The IO monad on the other hand performs the operations sequentially, but passes a \"hidden variable\" along, which represents \"the state of the world\", which allows us to write I/O code in a pure functional manner.  It turns out the pattern of chaining operations is quite useful and is used for lots of different things in Haskell.  Another example is exceptions: Using the Error monad, operations are chained such that they are performed sequentially, except if an error is thrown, in which case the rest of the chain is abandoned.  Both the list-comprehension syntax and the do-notation are syntactic sugar for chaining operations using the >>= operator. A monad is basically just a type that supports the >>= operator.  Example 3: A parser  This is a very simple parser which parses either a quoted string or a number:  parseExpr = parseString <|> parseNumber\n\nparseString = do\n        char '\"'\n        x <- many (noneOf \"\\\"\")\n        char '\"'\n        return (StringValue x)\n\nparseNumber = do\n    num <- many1 digit\n    return (NumberValue (read num))  The operations char , digit , etc. are pretty simple. They either match or don't match. The magic is the monad which manages the control flow: The operations are performed sequentially until a match fails, in which case the monad backtracks to the latest <|> and tries the next option. Again, a way of chaining operations with some additional, useful semantics.  Example 4: Asynchronous programming  The above examples are in Haskell, but it turns out F# also supports monads. This example is stolen from Don Syme :  let AsyncHttp(url:string) =\n    async {  let req = WebRequest.Create(url)\n             let! rsp = req.GetResponseAsync()\n             use stream = rsp.GetResponseStream()\n             use reader = new System.IO.StreamReader(stream)\n             return reader.ReadToEnd() }  This method fetches a web page. The punch line is the use of GetResponseAsync - it actually waits for the response on a separate thread, while the main thread returns from the function. The last three lines are executed on the spawned thread when the response have been received.  In most other languages you would have to explicitly create a separate function for the lines that handle the response. The async monad is able to \"split\" the block on its own and postpone the execution of the latter half. (The async {} syntax indicates that the control flow in the block is defined by the async monad.)  How they work  So how can a monad do all these fancy control-flow thing? What actually happens in a do-block (or a computation expression as they are called in F#), is that every operation (basically every line) is wrapped in a separate anonymous function. These functions are then combined using the bind operator (spelled >>= in Haskell). Since the bind operation combines functions, it can execute them as it sees fit: sequentially, multiple times, in reverse, discard some, execute some on a separate thread when it feels like it and so on.  As an example, this is the expanded version of the IO-code from example 2:  putStrLn \"What is your name?\"\n>>= (\\_ -> getLine)\n>>= (\\name -> putStrLn (\"Welcome, \" ++ name ++ \"!\"))  This is uglier, but it's also more obvious what is actually going on. The >>= operator is the magic ingredient: It takes a value (on the left side) and combines it with a function (on the right side), to produce a new value. This new value is then taken by the next >>= operator and again combined with a function to produce a new value. >>= can be viewed as a mini-evaluator.  Note that >>= is overloaded for different types, so every monad has its own implementation of >>= . (All the operations in the chain have to be of the type of the same monad though, otherwise the >>= operator won't work.)  The simplest possible implementation of >>= just takes the value on the left and applies it to the function on the right and returns the result, but as said before, what makes the whole pattern useful is when there is something extra going on in the monad's implementation of >>= .  There is some additional cleverness in how the values are passed from one operation to the next, but this requires a deeper explanation of the Haskell type system.  Summing up  In Haskell-terms a monad is a parameterized type which is an instance of the Monad type class, which defines >>= along with a few other operators. In layman's terms, a monad is just a type for which the >>= operation is defined.  In itself >>= is just a cumbersome way of chaining functions, but with the presence of the do-notation which hides the \"plumbing\", the monadic operations turns out to be a very nice and useful abstraction, useful many places in the language, and useful for creating your own mini-languages in the language.  Why are monads hard?  For many Haskell-learners, monads are an obstacle they hit like a brick wall. It's not that monads themselves are complex, but that the implementation relies on many other advanced Haskell features like parameterized types, type classes, and so on. The problem is that Haskell I/O is based on monads, and I/O is probably one of the first things you want to understand when learning a new language - after all, it's not much fun to create programs which don't produce any output. I have no immediate solution for this chicken-and-egg problem, except treating I/O like \"magic happens here\" until you have enough experience with other parts of language. Sorry.  Excellent blog on monads: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html ", "question_id": 44965}, "0.12691422528587282", 3], [{"answer_votes": "30", "answer_comments": [" Monads weren't 'designed', they were applied from one domain (category theory) to another (I/O in purely functional programming languages). Did Newton 'design' the calculus? \u2013 Jared Updike  Jul 31 '09 at 22:40 ", " Point 1 and 2 above are correct and useful. Points 4 and 5 are sort of ad hominem, even if more or less true. They don't really help explain monads. \u2013 Jared Updike  Jul 31 '09 at 22:42 ", " Re: 4, 5: The \"Secret handshake\" thing is a red herring. Programming is full of jargon. Haskell just happens to call stuff what it is without pretending to rediscover something. If it exists in mathematics already, why make up a new name for it? The name is really not the reason people don't get monads; they are a subtle concept. The average person probably understands addition and multiplication, why don't they get the concept of an Abelian Group? Because it is more abstract and general and that person hasn't done the work to wrap their head around the concept. A name change wouldn't help. \u2013 Jared Updike  Jul 31 '09 at 22:53 ", " Sigh... I'm not making an attack on Haskell ... I was making a joke.  So, I don't really get the bit about being \"ad hominem\".  Yes, the calculus was \"designed\". That's why, for example, calculus students are taught the Leibniz notation, rather than the icky stuff Netwton used. Better design.  Good names help understanding a lot. If I called Abelian Groups \"distended wrinkle pods\", you may have trouble understanding me.  You might be saying \"but that name is nonsense\", no one would ever call them that.  To people who have never heard of category theory \"monad\" sounds like nonsense. \u2013 Scott Wisniewski  Aug 1 '09 at 1:21 ", " @Scott: sorry if my extensive comments made it seem I was getting defensive about Haskell. I enjoy your humor about the secret handshake and you will note I said it is more or less true. :-) If you called Abelian Groups \"distended wrinkle pods\" you would be making the same mistake of trying to give monads a \"better name\" (cf. F# \"computation expressions\"): the term exists and people who care know what monads are, but not what \"warm fuzzy things\" are (or \"computation expressions\"). If I understand your use of the term \"type operator\" correctly there are lots of other type operators than monads. \u2013 Jared Updike  Aug 3 '09 at 23:27 "], "answer_body": " A monad is, effectively, a form of \"type operator\". It will do three things. First it will \"wrap\" (or otherwise convert) a value of one type into another type (typically called a \"monadic type\"). Secondly it will make all the operations (or functions) available on the underlying type available on the monadic type. Finally it will provide support for combining its self with another monad to produce a composite monad.  The \"maybe monad\" is essentially the equivalent of \"nullable types\" in Visual Basic / C#. It takes a non nullable type \"T\" and converts it into a \"Nullable<T>\", and then defines what all the binary operators mean on a Nullable<T>.  Side effects are represented simillarly. A structure is created that holds descriptions of side effects alongside a function's return value. The \"lifted\" operations then copy around side effects as values are passed between functions.  They are called \"monads\" rather than the easier-to-grasp name of \"type operators\" for several reasons:   Monads have restrictions on what they can do (see the definiton for details).  Those restrictions, along with the fact that there are three operations involved, conform to the structure of something called a monad in Category Theory, which is an obscure branch of mathematics.  They were designed by proponents of \"pure\" functional languages  Proponents of pure functional languages like obscure branches of mathematics  Because the math is obscure, and monads are associated with particular styles of programming, people tend to use the word monad as a sort of secret handshake. Because of this no one has bothered to invest in a better name.  ", "question_id": 44965}, "0.12691422528587282", 3], [{"answer_votes": "8", "answer_comments": null, "answer_body": " Monads Are Not Metaphors , but a practically useful abstraction emerging from a common pattern, as Daniel Spiewak explains. ", "question_id": 44965}, "0.12691422528587282", 3], [{"answer_votes": "5", "answer_comments": null, "answer_body": " In practice, monad is a custom implementation of function composition operator that takes care of side effects and incompatible input and return values (for chaining). ", "question_id": 44965}, "0.12691422528587282", 3], [{"answer_votes": "2", "answer_comments": null, "answer_body": " A very simple answer is:  Monads are an abstraction that provide an interface for encapsulating values, for computing new encapsulated values, and for unwrapping the encapsulated value.  What's convenient about them in practice is that they provide a uniform interface for creating data types that model state while not being stateful .  It's important to understand that a Monad is an abstraction , that is, an abstract interface for dealing with a certain kind of data structure. That interface is then used to build data types that have monadic behavior.  You can find a very good and practical introduction in Monads in Ruby, Part 1: Introduction . ", "question_id": 44965}, "0.12691422528587282", 3], [{"answer_votes": "625", "answer_comments": [" I appreciate your answer\u2014especially the final concession that all of this is of course possible too without monads. One point to be made is that it's mostly easier with monads, but it's often not as efficient as doing it without them. Once you need to involve transformers, the extra layering of function calls (and function objects created) has a cost that's hard to see and control, rendered invisible by clever syntax. \u2013 seh  Apr 20 '12 at 16:35 ", " In Haskell at least, most of the overhead of monads gets stripped away by the optimiser. So the only real \"cost\" is in brain power required. (This is not insignificant if \"maintainability\" is something you care about.) But usually, monads make things easier , not harder. (Otherwise, why would you bother?) \u2013 MathematicalOrchid  Apr 21 '12 at 18:40 ", " I'm not sure whether or not Haskell supports this but mathematically you can define a monad either in terms of >>= and return or join and ap. >>= and return are what make monads practically useful but join and ap give a more intuitive understanding of what a monad is. \u2013 Jeremy List  Apr 2 '14 at 10:57 ", " Coming from a non-math, non-functional programming background, this answer made the most sense to me. \u2013 jrahhali  Aug 2 '17 at 23:55 ", " This is the first answer that actually gave me some idea of what the hell a monad is. Thank you for finding a way to explain it! \u2013 robotmay  Aug 14 '17 at 23:48 "], "answer_body": " Explaining \"what is a monad\" is a bit like saying \"what is a number?\" We use numbers all the time. But imagine you met someone who didn't know anything about numbers. How the heck would you explain what numbers are? And how would you even begin to describe why that might be useful?  What is a monad? The short answer: It's a specific way of chaining operations together.  In essence, you're writing execution steps and linking them together with the \"bind function\". (In Haskell, it's named >>= .) You can write the calls to the bind operator yourself, or you can use syntax sugar which makes the compiler insert those function calls for you. But either way, each step is separated by a call to this bind function.  So the bind function is like a semicolon; it separates the steps in a process. The bind function's job is to take the output from the previous step, and feed it into the next step.  That doesn't sound too hard, right? But there is more than one kind of monad. Why? How?  Well, the bind function can just take the result from one step, and feed it to the next step. But if that's \"all\" the monad does... that actually isn't very useful. And that's important to understand: Every useful monad does something else in addition to just being a monad. Every useful monad has a \"special power\", which makes it unique.  (A monad that does nothing special is called the \"identity monad\". Rather like the identity function, this sounds like an utterly pointless thing, yet turns out not to be... But that's another story\u2122.)  Basically, each monad has its own implementation of the bind function. And you can write a bind function such that it does hoopy things between execution steps. For example:   If each step returns a success/failure indicator, you can have bind execute the next step only if the previous one succeeded. In this way, a failing step aborts the whole sequence \"automatically\", without any conditional testing from you. (The Failure Monad .)  Extending this idea, you can implement \"exceptions\". (The Error Monad or Exception Monad .) Because you're defining them yourself rather than it being a language feature, you can define how they work. (E.g., maybe you want to ignore the first two exceptions and only abort when a third exception is thrown.)  You can make each step return multiple results , and have the bind function loop over them, feeding each one into the next step for you. In this way, you don't have to keep writing loops all over the place when dealing with multiple results. The bind function \"automatically\" does all that for you. (The List Monad .)  As well as passing a \"result\" from one step to another, you can have the bind function pass extra data around as well. This data now doesn't show up in your source code, but you can still access it from anywhere, without having to manually pass it to every function. (The Reader Monad .)  You can make it so that the \"extra data\" can be replaced. This allows you to simulate destructive updates , without actually doing destructive updates. (The State Monad and its cousin the Writer Monad .)  Because you're only simulating destructive updates, you can trivially do things that would be impossible with real destructive updates. For example, you can undo the last update , or revert to an older version .  You can make a monad where calculations can be paused , so you can pause your program, go in and tinker with internal state data, and then resume it.  You can implement \"continuations\" as a monad. This allows you to break people's minds!   All of this and more is possible with monads. Of course, all of this is also perfectly possible without monads too. It's just drastically easier using monads. ", "question_id": 44965}, "0.2801442376730847", 4], [{"answer_votes": "162", "answer_comments": [" \u2026best way not only on the internet, but anywhere. (Wadler's original paper Monads for functional programming that I mentioned in my answer below is also good.) None of the zillions of tutorials-by-analogy come close. \u2013 ShreevatsaR  Apr 30 '11 at 15:14 ", " This JavaScript translation of Sigfpe's post is the new best way to learn monads, for people who don't already grok advanced Haskell! \u2013 Sam Watkins  Jan 6 '14 at 2:55  ", " This is how I learned what a monad is. Walking the reader through the process of inventing a concept is often the best way to teach the concept. \u2013 Jordan  Mar 8 '15 at 5:58 ", " However, a function accepting the screen object as argument and returning its copy with text modified would be pure. \u2013 Dmitri Zaitsev  May 20 '16 at 12:09 "], "answer_body": " But, You could have invented Monads!   sigfpe says:   But all of these introduce monads as something esoteric in need of explanation. But what I want to argue is that they aren't esoteric at all. In fact, faced with various problems in functional programming you would have been led, inexorably, to certain solutions, all of which are examples of monads. In fact, I hope to get you to invent them now if you haven't already. It's then a small step to notice that all of these solutions are in fact the same solution in disguise. And after reading this, you might be in a better position to understand other documents on monads because you'll recognise everything you see as something you've already invented.  Many of the problems that monads try to solve are related to the issue of side effects. So we'll start with them. (Note that monads let you do more than handle side-effects, in particular many types of container object can be viewed as monads. Some of the introductions to monads find it hard to reconcile these two different uses of monads and concentrate on just one or the other.)  In an imperative programming language such as C++, functions behave nothing like the functions of mathematics. For example, suppose we have a C++ function that takes a single floating point argument and returns a floating point result. Superficially it might seem a little like a mathematical function mapping reals to reals, but a C++ function can do more than just return a number that depends on its arguments. It can read and write the values of global variables as well as writing output to the screen and receiving input from the user. In a pure functional language, however, a function can only read what is supplied to it in its arguments and the only way it can have an effect on the world is through the values it returns.   ", "question_id": 44965}, "0.2801442376730847", 4], [{"answer_votes": "69", "answer_comments": [" slight addition to def of 'higher order function': they can take OR RETURN functions. That's why they are 'higher' 'cos they do things with themselves. \u2013 Kevin Won  Jan 30 '10 at 6:31  ", " By that definition, addition is a higher-order function. It takes a number and returns a function that adds that number to another. So no, higher order functions are strictly functions whose domain consists of functions. \u2013 Apocalisp  Jan 30 '10 at 16:58  ", " The video ' Brian Beckman: Don't fear the Monad ' follows this same line of logic. \u2013 icc97  Oct 10 '16 at 5:29 "], "answer_body": " You should first understand what a functor is. Before that, understand higher-order functions.  A higher-order function is simply a function that takes a function as an argument.  A functor is any type construction T for which there exists a higher-order function, call it map , that transforms a function of type a -> b (given any two types a and b ) into a function T a -> T b . This map function must also obey the laws of identity and composition such that the following expressions return true for all x , p , and q (Haskell notation):  map id = id\nmap (p . q) = map p . map q  For example, a type constructor called List is a functor if it comes equipped with a function of type (a -> b) -> List a -> List b which obeys the laws above. The only practical implementation is obvious. The resulting List a -> List b function iterates over the given list, calling the (a -> b) function for each element, and returns the list of the results.  A monad is essentially just a functor T with two extra methods, join , of type T (T a) -> T a , and unit (sometimes called return , fork , or pure ) of type a -> T a . For lists in Haskell:  join :: [[a]] -> [a]\npure :: a -> [a]  Why is that useful? Because you could, for example, map over a list with a function that returns a list. Join takes the resulting list of lists and concatenates them. List is a monad because this is possible.  You can write a function that does map , then join . This function is called bind , or flatMap , or (>>=) , or (=<<) . This is normally how a monad instance is given in Haskell.  A monad has to satisfy certain laws, namely that join must be associative. This means that if you have a value x of type [[[a]]] then join (join x) should equal join (map join x) . And pure must be an identity for join such that join (pure x) == x . ", "question_id": 44965}, "0.2801442376730847", 4], [{"answer_votes": "36", "answer_comments": [" Sequencing isn't the only reason to define a monad.  A monad is just any functor which has bind and return.  Bind and return give you sequencing.  But they give other things as well.  Also, note that your favorite imperative language is effectively a fancy IO monad with OO classes.  Making it easy to define monads means it's easy to use the interpreter pattern -- define a dsl as a monad and interpret it! \u2013 nomen  May 17 '14 at 16:40  ", " Here is an implementation: github.com/brianspinos777/Programming_cheat_sheets/blob/master/\u2026 \u2013 Brian Joseph Spinos  Dec 21 '17 at 21:20  "], "answer_body": " After much striving, I think I finally understand the monad. After rereading my own lengthy critique of the overwhelmingly top voted answer, I will offer this explanation.  There are three questions that need to be answered to understand monads:   Why do you need a monad?  What is a monad?  How is a monad implemented?   As I noted in my original comments, too many monad explanations get caught up in question number 3, without, and before really adequately covering question 2, or question 1.  Why do you need a monad?  Pure functional languages like Haskell are different from imperative languages like C, or Java in that, a pure functional program is not necessarily executed in a specific order, one step at a time. A Haskell program is more akin to a mathematical function, in which you may solve the \"equation\" in any number of potential orders. This confers a number of benefits, among which is that it eliminates the possibility of certain kinds of bugs, particularly those relating to things like \"state\".  However, there are certain problems that are not so straightforward to solve with this style of programming. Some things, like console programming, and file i/o, need things to happen in a particular order, or need to maintain state. One way to deal with this problem is to create a kind of object that represents the state of a computation, and a series of functions that take a state object as input, and return a new modified state object.  So let's create a hypothetical \"state\" value, that represents the state of a console screen. exactly how this value is constructed is not important, but let's say it's an array of byte length ascii characters that represents what is currently visible on the screen, and an array that represents the last line of input entered by the user, in pseudocode. We've defined some functions that take console state, modify it, and return a new console state.  consolestate MyConsole = new consolestate;  So to do console programming, but in a pure functional manner, you would need to nest a lot of function calls inside eachother.  consolestate FinalConsole = print(input(print(myconsole, \"Hello, what's your name?\")),\"hello, %inputbuffer%!\");  Programming in this way keeps the \"pure\" functional style, while forcing changes to the console to happen in a particular order. But, we'll probably want to do more than just a few operations at a time like in the above example. Nesting functions in that way will start to become ungainly. What we want, is code that does essentially the same thing as above, but is written a bit more like this:  consolestate FinalConsole = myconsole:\n                            print(\"Hello, what's your name?\"):\n                            input():\n                            print(\"hello, %inputbuffer%!\");  This would indeed be a more convenient way to write it. How do we do that though?  What is a monad?  Once you have a type (such as consolestate ) that you define along with a bunch of functions designed specifically to operate on that type, you can turn the whole package of these things into a \"monad\" by defining an operator like : (bind) that automatically feeds return values on its left, into function parameters on its right, and a lift operator that turns normal functions, into functions that work with that specific kind of bind operator.  How is a monad implemented?  See other answers, that seem quite free to jump into the details of that. ", "question_id": 44965}, "0.2801442376730847", 4], [{"answer_votes": "28", "answer_comments": [" \"...but I hope others find it useful\" it was indeed useful for me, despite of all the emphasized sentences :D \u2013 ftor  Oct 19 '16 at 17:50 ", " This is the most concise and clear explanation of monads I've ever read/watched/heard.  Thank you! \u2013 James  Nov 7 '16 at 2:04 ", " There is important difference between Monad and Monoid. Monad is a rule to \"compose\" functions between different types, so they do not form a binary operation as required for Monoids, see here for more details: stackoverflow.com/questions/2704652/\u2026 \u2013 Dmitri Zaitsev  Nov 18 '16 at 16:51 ", " Yes. You are correct. Your article was over my head :). However, I found this treatment very helpful (and added it to mine as a direction to others). Thanks your the heads up: stackoverflow.com/a/7829607/1612190 \u2013 George  Nov 21 '16 at 7:44 ", " You might have confused Algebraic group theory with Category theory where Monad is coming from. The former is the theory of algebraic groups, which is unrelated. \u2013 Dmitri Zaitsev  Mar 1 '17 at 12:19 "], "answer_body": " I wrote this mostly for me but I hope others find it useful :)  In Summary  A monad is merely custom function composition utilizing a wrapping type to hold stateful/meta information that guides the composition. Interestingly, imperative execution is itself function composition wherein the wrapping type holds whether an exception has occurred, the presence of which aborts further composition. The monadic laws serve to ensure a monad only performs the equivalent of function composition over the wrapped value.  A Little Context  Imperative code is a sequence of instructions performed consecutively while functional code is actually an expression whose order of evaluation is ultimately on an as needed basis. Consequently, an imperative program evaluates each statement fully before proceeding to the next one while a functional program catalogs any preceding subexpression then evaluates the last one to generate a result, at which point any necessary preceding subexpressions are evaluated. (Most functional languages do resolve subexpressions into values as they are encountered with a few, notably Haskell, being the exception).  What Does That Have To Do With Monads  It turns out that imperative evaluation and \"expression\" evaluation are equivalent. Namely, the performance of an evaluation of an expression at any specific time can be described as the sequential evaluation of its subexpressions. Similarly, any sequential execution of statements can be considered an instance of such an expression being evaluated especially if you generalize the notion of return value to be any modification to the application state as oppose to merely formal return values. To the point, all imperative code can be considered a specific ordered evaluation of some equivalent expression (over the application state).  Still, What Does All That Have To Do With Monads  An expression is a composition of functions and a monad is a technique for customizing the composition of functions. Per convention, it is a function called, bind , that composes (binds) two functions ( bind f g = (x) => g(f x) ) within some umbrella type that holds a context or state guiding the binding process. This context allows the associated implementation of bind to massage the composition. In the case of, Result 'a , context that hold an error message or a actual value it would permit the bind to log errors of the preceding result and aborts or continue the composition with a default value, depending on design. Selective application of the subsequent function to be composed is the key facility of monads in that the application process is not blind, unlike silly imperative code. :)  In a monad, the functions to be composed are defined to receive a non-monadic or unwrapped value but return a monadic or wrapped value. An example of one such naturally occurring function is the division operator ( / ) which accepts numbers but may return undefined if the divisor is 0 . Since undefined is not a number, \\ , actually returns a type whose value range is large than a number since it includes all numbers plus undefined .  I suspect this asymmetry, where operators require valid values but may return invalid ones, is a key pragmatic aspect of monads that make them useful but difficult to explain and justify; while imperative coders accept constant result checking as a necessary evil, functional coders use bind over a suitable wrapper type to detect and manage exceptions or invalid results  While being a composition function, nonetheless, for pragmatic reasons bind is described as receiving the result of the first function, a wrapped value, that it then selectively applies to the second function whose result it then collects and returns as its result. Consequently, binds can themselves be composed.  For a complex example, a monad can take a sequence of asynchronous results as a preceding value and apply each to the provided composing function in parallel with respect to the available processors, then collect and return their results as they occur, for instance. All this functionality is in that specific implementation of that monad's bind function; however, there are typically ancillary functions that cooperate, in particular lift with wraps a value into a default instance of the monadic type such as, lift 1 = Just 1 in the case of the Maybe monad, for participation in monadic expressions. (In Haskell, a monad is strongly associated with the wrapper type because monads are implemented using its type class mechanisms whereas in F# the implementation uses defined computations expression instances)  Are you saying that...  ...a monad is just custom function composition using a wrapping type to hold stateful information that the bind or composing function or operator uses in determining whether and how to perform the application of the next function. Yep.  What About The Monadic Laws?  The monadic laws only seek to ensure that a monad implementation only performs the equivalent of function composition over the wrapped type. It does that by ensuring certain equivalences hold per the expectation of composing those two functions over the wrapped type.  That's it I think. Hope it helps some.  I believe this is nice a nice treatment in another StackOverflow of response . ", "question_id": 44965}, "0.2801442376730847", 4], [{"answer_votes": "9", "answer_comments": [" The python examples made it easy to comprehend! Thanks for sharing. \u2013 Ryan Efendy  Mar 2 at 17:50 "], "answer_body": " I am still new to monads, but I thought I would share a link I found that felt really good to read (WITH PICTURES!!): http://www.matusiak.eu/numerodix/blog/2012/3/11/monads-for-the-layman/ (no affiliation)  Basically, the warm and fuzzy concept that I got from the article was the concept that monads are basically adapters that allow disparate functions to work in a composable fashion, i.e. be able to string up multiple functions and mix and match them without worrying about inconsistent return types and such. So the BIND function is in charge of keeping apples with apples and oranges with oranges when we're trying to make these adapters. And the LIFT function is in charge of taking \"lower level\" functions and \"upgrading\" them to work with BIND functions and be composable as well.  I hope I got it right, and more importantly, hope that the article has a valid view on monads. If nothing else, this article helped whet my appetite for learning more about monads. ", "question_id": 44965}, "0.2801442376730847", 4], [{"answer_votes": "3", "answer_comments": [" The course doesn't exist on Coursera any more \u2013 icc97  Dec 15 '16 at 13:26 ", " That's a surprising - and v poor - reflection on Coursera. \u2013 javadba  Dec 5 '17 at 1:30 "], "answer_body": " In the Coursera \"Principles of Reactive Programming\" training - Erik Meier describes them as:  \"Monads are return types that guide you through the happy path.\" -Erik Meijer ", "question_id": 44965}, "0.2801442376730847", 4], [{"answer_votes": "2", "answer_comments": null, "answer_body": " I'm trying to understand monads as well. It's my version:  Monads are about making abstractions about repetitive things. \nFirstly, monad itself is a typed interface (like an abstract generic class), that has two functions: bind and return that have defined signatures. And then, we can create concrete monads based on that abstract monad, of course with specific implementations of bind and return. Additionally, bind and return must fulfill a few invariants in order to make it possible to compose/chain concrete monads.  Why create the monad concept while we have interfaces, types, classes and other tools to create abstractions? Because monads give more: they enforce rethinking problems in a way that enables to compose data without any boilerplate. ", "question_id": 44965}, "0.2801442376730847", 4], [{"answer_votes": "2", "answer_comments": null, "answer_body": " Essentially , and Practically , monads allow callback nesting (with a mutually-recursively-threaded state (pardon the hyphens)) (in a composable (or decomposable) fashion) (with type safety (sometimes (depending on the language))) )))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))  E.G. this is NOT a monad:  //JavaScript is 'Practical'\nvar getAllThree = \n         bind(getFirst, function(first){  \n  return bind(getSecond,function(second){  \n  return bind(getThird, function(third){  \n    var fancyResult = // And now make do fancy \n                      // with first, second,\n                      // and third \n    return RETURN(fancyResult);\n  });});});  But monads enable such code. The monad is actually the set of types for:  {bind,RETURN,maybe others I don't know...} . Which is essentially inessential, and practically impractical.  So now I can use it:  var fancyResultReferenceOutsideOfMonad =  \n  getAllThree(someKindOfInputAcceptableToOurGetFunctionsButProbablyAString);  \n\n//Ignore this please, throwing away types, yay JavaScript:\n//  RETURN = K\n//  bind = \\getterFn,cb -> \n//    \\in -> let(result,newState) = getterFn(in) in cb(result)(newState)  Or Break it up:  var getFirstTwo = \n           bind(getFirst, function(first){  \n    return bind(getSecond,function(second){  \n      var fancyResult2 = // And now make do fancy \n                         // with first and second\n      return RETURN(fancyResult2);\n    });})\n  , getAllThree = \n           bind(getFirstTwo, function(fancyResult2){  \n    return bind(getThird,    function(third){  \n      var fancyResult3 = // And now make do fancy \n                         // with fancyResult2,\n                         // and third \n      return RETURN(fancyResult3);\n    });});  Or ignore certain results:  var getFirstTwo = \n           bind(getFirst, function(first){  \n    return bind(getSecond,function(second){  \n      var fancyResult2 = // And now make do fancy \n                         // with first and second\n      return RETURN(fancyResult2);\n    });})\n  , getAllThree = \n           bind(getFirstTwo, function(____dontCare____NotGonnaUse____){  \n    return bind(getThird,    function(three){  \n      var fancyResult3 = // And now make do fancy \n                         // with `three` only!\n      return RETURN(fancyResult3);\n    });});  Or simplify a trivial case from:  var getFirstTwo = \n           bind(getFirst, function(first){  \n    return bind(getSecond,function(second){  \n      var fancyResult2 = // And now make do fancy \n                         // with first and second\n      return RETURN(fancyResult2);\n    });})\n  , getAllThree = \n           bind(getFirstTwo, function(_){  \n    return bind(getThird,    function(three){  \n      return RETURN(three);\n    });});  To (using \"Right Identity\" ):  var getFirstTwo = \n           bind(getFirst, function(first){  \n    return bind(getSecond,function(second){  \n      var fancyResult2 = // And now make do fancy \n                         // with first and second\n      return RETURN(fancyResult2);\n    });})\n  , getAllThree = \n           bind(getFirstTwo, function(_){  \n    return getThird;\n    });  Or jam them back together:  var getAllThree = \n           bind(getFirst, function(first_dontCareNow){  \n    return bind(getSecond,function(second_dontCareNow){  \n    return getThird;\n    });});  The practicality of these abilities doesn't really emerge, or become clear until you try to solve really messy problems like parsing, or module/ajax/resource loading.  Can you imagine thousands of lines of indexOf/subString logic? What if frequent parsing steps were contained in little functions? Functions like chars , spaces , upperChars , or digits ? And what if those functions gave you the result in a callback, without having to mess with Regex groups, and arguments.slice? And what if their composition/decomposition was well understood? Such that you could build big parsers from the bottom up?  So the ability to manage nested callback scopes is incredibly practical , especially when working with monadic parser combinator libraries. (that is to say, in my experience)  DON'T GET HUNG UP ON: - CATEGORY-THEORY - MAYBE-MONADS - MONAD LAWS - HASKELL - !!!! ", "question_id": 44965}, "0.2801442376730847", 4], [{"answer_votes": "-1", "answer_comments": [" Big Mistake : monad computation can be triggerred wo. main. \u2013 Titou  Jul 13 '15 at 13:28 "], "answer_body": " Mathematial thinking  For short: An Algebraic Structure for Combining Computations.  return data : create a computation who just simply generate a data in monad world.  (return data) >>= (return func) : The second parameter accept first parameter as a data generator and create a new computations which concatenate them.  You can think that (>>=) and return won't do any computation itself. They just simply combine and create computations.  Any monad computation will be compute if and only if main trigs it. ", "question_id": 44965}, "0.2801442376730847", 4], [{"answer_votes": "-1", "answer_comments": null, "answer_body": " Explanation  It's quite simple, when explained in C#/Java terms:   A monad is a function that takes arguments and returns a special type.  The special type that this monad returns is also called monad. (A monad is a combination of #1 and #2)  There's some syntactic sugar to make calling this function and conversion of types easier.   Example  A monad is useful to make the life of the functional programmer easier. The typical example: The Maybe monad takes two parameters, a value and a function. It returns null if the passed value is null . Otherwise it evaluates the function. If we needed a special return type, we would call this return type Maybe as well. A very crude implementation would look like this:  object Maybe(object value, Func<object,object> function)\n{\n    if(value==null)\n        return null;\n\n    return function(value);\n}  This is spectacularly useless in C# because this language lacks the required syntactic sugar to make monads useful. But monads allow you to write more concise code in functional programming languages.  Oftentimes programmers call monads in chains, like so:  var x = Maybe(x, x2 => Maybe(y, y2 => Add(x2, y2)));  In this example the Add method would only be called if x and y are both non- null , otherwise null will be returned.  Answer  To answer the original question: A monad is a function AND a type. Like an implementation of a special interface . ", "question_id": 44965}, "0.2801442376730847", 4]], [[{"answer_votes": "625", "answer_comments": [" I appreciate your answer\u2014especially the final concession that all of this is of course possible too without monads. One point to be made is that it's mostly easier with monads, but it's often not as efficient as doing it without them. Once you need to involve transformers, the extra layering of function calls (and function objects created) has a cost that's hard to see and control, rendered invisible by clever syntax. \u2013 seh  Apr 20 '12 at 16:35 ", " In Haskell at least, most of the overhead of monads gets stripped away by the optimiser. So the only real \"cost\" is in brain power required. (This is not insignificant if \"maintainability\" is something you care about.) But usually, monads make things easier , not harder. (Otherwise, why would you bother?) \u2013 MathematicalOrchid  Apr 21 '12 at 18:40 ", " I'm not sure whether or not Haskell supports this but mathematically you can define a monad either in terms of >>= and return or join and ap. >>= and return are what make monads practically useful but join and ap give a more intuitive understanding of what a monad is. \u2013 Jeremy List  Apr 2 '14 at 10:57 ", " Coming from a non-math, non-functional programming background, this answer made the most sense to me. \u2013 jrahhali  Aug 2 '17 at 23:55 ", " This is the first answer that actually gave me some idea of what the hell a monad is. Thank you for finding a way to explain it! \u2013 robotmay  Aug 14 '17 at 23:48 "], "answer_body": " Explaining \"what is a monad\" is a bit like saying \"what is a number?\" We use numbers all the time. But imagine you met someone who didn't know anything about numbers. How the heck would you explain what numbers are? And how would you even begin to describe why that might be useful?  What is a monad? The short answer: It's a specific way of chaining operations together.  In essence, you're writing execution steps and linking them together with the \"bind function\". (In Haskell, it's named >>= .) You can write the calls to the bind operator yourself, or you can use syntax sugar which makes the compiler insert those function calls for you. But either way, each step is separated by a call to this bind function.  So the bind function is like a semicolon; it separates the steps in a process. The bind function's job is to take the output from the previous step, and feed it into the next step.  That doesn't sound too hard, right? But there is more than one kind of monad. Why? How?  Well, the bind function can just take the result from one step, and feed it to the next step. But if that's \"all\" the monad does... that actually isn't very useful. And that's important to understand: Every useful monad does something else in addition to just being a monad. Every useful monad has a \"special power\", which makes it unique.  (A monad that does nothing special is called the \"identity monad\". Rather like the identity function, this sounds like an utterly pointless thing, yet turns out not to be... But that's another story\u2122.)  Basically, each monad has its own implementation of the bind function. And you can write a bind function such that it does hoopy things between execution steps. For example:   If each step returns a success/failure indicator, you can have bind execute the next step only if the previous one succeeded. In this way, a failing step aborts the whole sequence \"automatically\", without any conditional testing from you. (The Failure Monad .)  Extending this idea, you can implement \"exceptions\". (The Error Monad or Exception Monad .) Because you're defining them yourself rather than it being a language feature, you can define how they work. (E.g., maybe you want to ignore the first two exceptions and only abort when a third exception is thrown.)  You can make each step return multiple results , and have the bind function loop over them, feeding each one into the next step for you. In this way, you don't have to keep writing loops all over the place when dealing with multiple results. The bind function \"automatically\" does all that for you. (The List Monad .)  As well as passing a \"result\" from one step to another, you can have the bind function pass extra data around as well. This data now doesn't show up in your source code, but you can still access it from anywhere, without having to manually pass it to every function. (The Reader Monad .)  You can make it so that the \"extra data\" can be replaced. This allows you to simulate destructive updates , without actually doing destructive updates. (The State Monad and its cousin the Writer Monad .)  Because you're only simulating destructive updates, you can trivially do things that would be impossible with real destructive updates. For example, you can undo the last update , or revert to an older version .  You can make a monad where calculations can be paused , so you can pause your program, go in and tinker with internal state data, and then resume it.  You can implement \"continuations\" as a monad. This allows you to break people's minds!   All of this and more is possible with monads. Of course, all of this is also perfectly possible without monads too. It's just drastically easier using monads. ", "question_id": 44965}, "0.2801442376730847", 4], [{"answer_votes": "162", "answer_comments": [" \u2026best way not only on the internet, but anywhere. (Wadler's original paper Monads for functional programming that I mentioned in my answer below is also good.) None of the zillions of tutorials-by-analogy come close. \u2013 ShreevatsaR  Apr 30 '11 at 15:14 ", " This JavaScript translation of Sigfpe's post is the new best way to learn monads, for people who don't already grok advanced Haskell! \u2013 Sam Watkins  Jan 6 '14 at 2:55  ", " This is how I learned what a monad is. Walking the reader through the process of inventing a concept is often the best way to teach the concept. \u2013 Jordan  Mar 8 '15 at 5:58 ", " However, a function accepting the screen object as argument and returning its copy with text modified would be pure. \u2013 Dmitri Zaitsev  May 20 '16 at 12:09 "], "answer_body": " But, You could have invented Monads!   sigfpe says:   But all of these introduce monads as something esoteric in need of explanation. But what I want to argue is that they aren't esoteric at all. In fact, faced with various problems in functional programming you would have been led, inexorably, to certain solutions, all of which are examples of monads. In fact, I hope to get you to invent them now if you haven't already. It's then a small step to notice that all of these solutions are in fact the same solution in disguise. And after reading this, you might be in a better position to understand other documents on monads because you'll recognise everything you see as something you've already invented.  Many of the problems that monads try to solve are related to the issue of side effects. So we'll start with them. (Note that monads let you do more than handle side-effects, in particular many types of container object can be viewed as monads. Some of the introductions to monads find it hard to reconcile these two different uses of monads and concentrate on just one or the other.)  In an imperative programming language such as C++, functions behave nothing like the functions of mathematics. For example, suppose we have a C++ function that takes a single floating point argument and returns a floating point result. Superficially it might seem a little like a mathematical function mapping reals to reals, but a C++ function can do more than just return a number that depends on its arguments. It can read and write the values of global variables as well as writing output to the screen and receiving input from the user. In a pure functional language, however, a function can only read what is supplied to it in its arguments and the only way it can have an effect on the world is through the values it returns.   ", "question_id": 44965}, "0.2801442376730847", 4], [{"answer_votes": "69", "answer_comments": [" slight addition to def of 'higher order function': they can take OR RETURN functions. That's why they are 'higher' 'cos they do things with themselves. \u2013 Kevin Won  Jan 30 '10 at 6:31  ", " By that definition, addition is a higher-order function. It takes a number and returns a function that adds that number to another. So no, higher order functions are strictly functions whose domain consists of functions. \u2013 Apocalisp  Jan 30 '10 at 16:58  ", " The video ' Brian Beckman: Don't fear the Monad ' follows this same line of logic. \u2013 icc97  Oct 10 '16 at 5:29 "], "answer_body": " You should first understand what a functor is. Before that, understand higher-order functions.  A higher-order function is simply a function that takes a function as an argument.  A functor is any type construction T for which there exists a higher-order function, call it map , that transforms a function of type a -> b (given any two types a and b ) into a function T a -> T b . This map function must also obey the laws of identity and composition such that the following expressions return true for all x , p , and q (Haskell notation):  map id = id\nmap (p . q) = map p . map q  For example, a type constructor called List is a functor if it comes equipped with a function of type (a -> b) -> List a -> List b which obeys the laws above. The only practical implementation is obvious. The resulting List a -> List b function iterates over the given list, calling the (a -> b) function for each element, and returns the list of the results.  A monad is essentially just a functor T with two extra methods, join , of type T (T a) -> T a , and unit (sometimes called return , fork , or pure ) of type a -> T a . For lists in Haskell:  join :: [[a]] -> [a]\npure :: a -> [a]  Why is that useful? Because you could, for example, map over a list with a function that returns a list. Join takes the resulting list of lists and concatenates them. List is a monad because this is possible.  You can write a function that does map , then join . This function is called bind , or flatMap , or (>>=) , or (=<<) . This is normally how a monad instance is given in Haskell.  A monad has to satisfy certain laws, namely that join must be associative. This means that if you have a value x of type [[[a]]] then join (join x) should equal join (map join x) . And pure must be an identity for join such that join (pure x) == x . ", "question_id": 44965}, "0.2801442376730847", 4], [{"answer_votes": "36", "answer_comments": [" Sequencing isn't the only reason to define a monad.  A monad is just any functor which has bind and return.  Bind and return give you sequencing.  But they give other things as well.  Also, note that your favorite imperative language is effectively a fancy IO monad with OO classes.  Making it easy to define monads means it's easy to use the interpreter pattern -- define a dsl as a monad and interpret it! \u2013 nomen  May 17 '14 at 16:40  ", " Here is an implementation: github.com/brianspinos777/Programming_cheat_sheets/blob/master/\u2026 \u2013 Brian Joseph Spinos  Dec 21 '17 at 21:20  "], "answer_body": " After much striving, I think I finally understand the monad. After rereading my own lengthy critique of the overwhelmingly top voted answer, I will offer this explanation.  There are three questions that need to be answered to understand monads:   Why do you need a monad?  What is a monad?  How is a monad implemented?   As I noted in my original comments, too many monad explanations get caught up in question number 3, without, and before really adequately covering question 2, or question 1.  Why do you need a monad?  Pure functional languages like Haskell are different from imperative languages like C, or Java in that, a pure functional program is not necessarily executed in a specific order, one step at a time. A Haskell program is more akin to a mathematical function, in which you may solve the \"equation\" in any number of potential orders. This confers a number of benefits, among which is that it eliminates the possibility of certain kinds of bugs, particularly those relating to things like \"state\".  However, there are certain problems that are not so straightforward to solve with this style of programming. Some things, like console programming, and file i/o, need things to happen in a particular order, or need to maintain state. One way to deal with this problem is to create a kind of object that represents the state of a computation, and a series of functions that take a state object as input, and return a new modified state object.  So let's create a hypothetical \"state\" value, that represents the state of a console screen. exactly how this value is constructed is not important, but let's say it's an array of byte length ascii characters that represents what is currently visible on the screen, and an array that represents the last line of input entered by the user, in pseudocode. We've defined some functions that take console state, modify it, and return a new console state.  consolestate MyConsole = new consolestate;  So to do console programming, but in a pure functional manner, you would need to nest a lot of function calls inside eachother.  consolestate FinalConsole = print(input(print(myconsole, \"Hello, what's your name?\")),\"hello, %inputbuffer%!\");  Programming in this way keeps the \"pure\" functional style, while forcing changes to the console to happen in a particular order. But, we'll probably want to do more than just a few operations at a time like in the above example. Nesting functions in that way will start to become ungainly. What we want, is code that does essentially the same thing as above, but is written a bit more like this:  consolestate FinalConsole = myconsole:\n                            print(\"Hello, what's your name?\"):\n                            input():\n                            print(\"hello, %inputbuffer%!\");  This would indeed be a more convenient way to write it. How do we do that though?  What is a monad?  Once you have a type (such as consolestate ) that you define along with a bunch of functions designed specifically to operate on that type, you can turn the whole package of these things into a \"monad\" by defining an operator like : (bind) that automatically feeds return values on its left, into function parameters on its right, and a lift operator that turns normal functions, into functions that work with that specific kind of bind operator.  How is a monad implemented?  See other answers, that seem quite free to jump into the details of that. ", "question_id": 44965}, "0.2801442376730847", 4], [{"answer_votes": "28", "answer_comments": [" \"...but I hope others find it useful\" it was indeed useful for me, despite of all the emphasized sentences :D \u2013 ftor  Oct 19 '16 at 17:50 ", " This is the most concise and clear explanation of monads I've ever read/watched/heard.  Thank you! \u2013 James  Nov 7 '16 at 2:04 ", " There is important difference between Monad and Monoid. Monad is a rule to \"compose\" functions between different types, so they do not form a binary operation as required for Monoids, see here for more details: stackoverflow.com/questions/2704652/\u2026 \u2013 Dmitri Zaitsev  Nov 18 '16 at 16:51 ", " Yes. You are correct. Your article was over my head :). However, I found this treatment very helpful (and added it to mine as a direction to others). Thanks your the heads up: stackoverflow.com/a/7829607/1612190 \u2013 George  Nov 21 '16 at 7:44 ", " You might have confused Algebraic group theory with Category theory where Monad is coming from. The former is the theory of algebraic groups, which is unrelated. \u2013 Dmitri Zaitsev  Mar 1 '17 at 12:19 "], "answer_body": " I wrote this mostly for me but I hope others find it useful :)  In Summary  A monad is merely custom function composition utilizing a wrapping type to hold stateful/meta information that guides the composition. Interestingly, imperative execution is itself function composition wherein the wrapping type holds whether an exception has occurred, the presence of which aborts further composition. The monadic laws serve to ensure a monad only performs the equivalent of function composition over the wrapped value.  A Little Context  Imperative code is a sequence of instructions performed consecutively while functional code is actually an expression whose order of evaluation is ultimately on an as needed basis. Consequently, an imperative program evaluates each statement fully before proceeding to the next one while a functional program catalogs any preceding subexpression then evaluates the last one to generate a result, at which point any necessary preceding subexpressions are evaluated. (Most functional languages do resolve subexpressions into values as they are encountered with a few, notably Haskell, being the exception).  What Does That Have To Do With Monads  It turns out that imperative evaluation and \"expression\" evaluation are equivalent. Namely, the performance of an evaluation of an expression at any specific time can be described as the sequential evaluation of its subexpressions. Similarly, any sequential execution of statements can be considered an instance of such an expression being evaluated especially if you generalize the notion of return value to be any modification to the application state as oppose to merely formal return values. To the point, all imperative code can be considered a specific ordered evaluation of some equivalent expression (over the application state).  Still, What Does All That Have To Do With Monads  An expression is a composition of functions and a monad is a technique for customizing the composition of functions. Per convention, it is a function called, bind , that composes (binds) two functions ( bind f g = (x) => g(f x) ) within some umbrella type that holds a context or state guiding the binding process. This context allows the associated implementation of bind to massage the composition. In the case of, Result 'a , context that hold an error message or a actual value it would permit the bind to log errors of the preceding result and aborts or continue the composition with a default value, depending on design. Selective application of the subsequent function to be composed is the key facility of monads in that the application process is not blind, unlike silly imperative code. :)  In a monad, the functions to be composed are defined to receive a non-monadic or unwrapped value but return a monadic or wrapped value. An example of one such naturally occurring function is the division operator ( / ) which accepts numbers but may return undefined if the divisor is 0 . Since undefined is not a number, \\ , actually returns a type whose value range is large than a number since it includes all numbers plus undefined .  I suspect this asymmetry, where operators require valid values but may return invalid ones, is a key pragmatic aspect of monads that make them useful but difficult to explain and justify; while imperative coders accept constant result checking as a necessary evil, functional coders use bind over a suitable wrapper type to detect and manage exceptions or invalid results  While being a composition function, nonetheless, for pragmatic reasons bind is described as receiving the result of the first function, a wrapped value, that it then selectively applies to the second function whose result it then collects and returns as its result. Consequently, binds can themselves be composed.  For a complex example, a monad can take a sequence of asynchronous results as a preceding value and apply each to the provided composing function in parallel with respect to the available processors, then collect and return their results as they occur, for instance. All this functionality is in that specific implementation of that monad's bind function; however, there are typically ancillary functions that cooperate, in particular lift with wraps a value into a default instance of the monadic type such as, lift 1 = Just 1 in the case of the Maybe monad, for participation in monadic expressions. (In Haskell, a monad is strongly associated with the wrapper type because monads are implemented using its type class mechanisms whereas in F# the implementation uses defined computations expression instances)  Are you saying that...  ...a monad is just custom function composition using a wrapping type to hold stateful information that the bind or composing function or operator uses in determining whether and how to perform the application of the next function. Yep.  What About The Monadic Laws?  The monadic laws only seek to ensure that a monad implementation only performs the equivalent of function composition over the wrapped type. It does that by ensuring certain equivalences hold per the expectation of composing those two functions over the wrapped type.  That's it I think. Hope it helps some.  I believe this is nice a nice treatment in another StackOverflow of response . ", "question_id": 44965}, "0.2801442376730847", 4], [{"answer_votes": "9", "answer_comments": [" The python examples made it easy to comprehend! Thanks for sharing. \u2013 Ryan Efendy  Mar 2 at 17:50 "], "answer_body": " I am still new to monads, but I thought I would share a link I found that felt really good to read (WITH PICTURES!!): http://www.matusiak.eu/numerodix/blog/2012/3/11/monads-for-the-layman/ (no affiliation)  Basically, the warm and fuzzy concept that I got from the article was the concept that monads are basically adapters that allow disparate functions to work in a composable fashion, i.e. be able to string up multiple functions and mix and match them without worrying about inconsistent return types and such. So the BIND function is in charge of keeping apples with apples and oranges with oranges when we're trying to make these adapters. And the LIFT function is in charge of taking \"lower level\" functions and \"upgrading\" them to work with BIND functions and be composable as well.  I hope I got it right, and more importantly, hope that the article has a valid view on monads. If nothing else, this article helped whet my appetite for learning more about monads. ", "question_id": 44965}, "0.2801442376730847", 4], [{"answer_votes": "3", "answer_comments": [" The course doesn't exist on Coursera any more \u2013 icc97  Dec 15 '16 at 13:26 ", " That's a surprising - and v poor - reflection on Coursera. \u2013 javadba  Dec 5 '17 at 1:30 "], "answer_body": " In the Coursera \"Principles of Reactive Programming\" training - Erik Meier describes them as:  \"Monads are return types that guide you through the happy path.\" -Erik Meijer ", "question_id": 44965}, "0.2801442376730847", 4], [{"answer_votes": "2", "answer_comments": null, "answer_body": " I'm trying to understand monads as well. It's my version:  Monads are about making abstractions about repetitive things. \nFirstly, monad itself is a typed interface (like an abstract generic class), that has two functions: bind and return that have defined signatures. And then, we can create concrete monads based on that abstract monad, of course with specific implementations of bind and return. Additionally, bind and return must fulfill a few invariants in order to make it possible to compose/chain concrete monads.  Why create the monad concept while we have interfaces, types, classes and other tools to create abstractions? Because monads give more: they enforce rethinking problems in a way that enables to compose data without any boilerplate. ", "question_id": 44965}, "0.2801442376730847", 4], [{"answer_votes": "2", "answer_comments": null, "answer_body": " Essentially , and Practically , monads allow callback nesting (with a mutually-recursively-threaded state (pardon the hyphens)) (in a composable (or decomposable) fashion) (with type safety (sometimes (depending on the language))) )))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))  E.G. this is NOT a monad:  //JavaScript is 'Practical'\nvar getAllThree = \n         bind(getFirst, function(first){  \n  return bind(getSecond,function(second){  \n  return bind(getThird, function(third){  \n    var fancyResult = // And now make do fancy \n                      // with first, second,\n                      // and third \n    return RETURN(fancyResult);\n  });});});  But monads enable such code. The monad is actually the set of types for:  {bind,RETURN,maybe others I don't know...} . Which is essentially inessential, and practically impractical.  So now I can use it:  var fancyResultReferenceOutsideOfMonad =  \n  getAllThree(someKindOfInputAcceptableToOurGetFunctionsButProbablyAString);  \n\n//Ignore this please, throwing away types, yay JavaScript:\n//  RETURN = K\n//  bind = \\getterFn,cb -> \n//    \\in -> let(result,newState) = getterFn(in) in cb(result)(newState)  Or Break it up:  var getFirstTwo = \n           bind(getFirst, function(first){  \n    return bind(getSecond,function(second){  \n      var fancyResult2 = // And now make do fancy \n                         // with first and second\n      return RETURN(fancyResult2);\n    });})\n  , getAllThree = \n           bind(getFirstTwo, function(fancyResult2){  \n    return bind(getThird,    function(third){  \n      var fancyResult3 = // And now make do fancy \n                         // with fancyResult2,\n                         // and third \n      return RETURN(fancyResult3);\n    });});  Or ignore certain results:  var getFirstTwo = \n           bind(getFirst, function(first){  \n    return bind(getSecond,function(second){  \n      var fancyResult2 = // And now make do fancy \n                         // with first and second\n      return RETURN(fancyResult2);\n    });})\n  , getAllThree = \n           bind(getFirstTwo, function(____dontCare____NotGonnaUse____){  \n    return bind(getThird,    function(three){  \n      var fancyResult3 = // And now make do fancy \n                         // with `three` only!\n      return RETURN(fancyResult3);\n    });});  Or simplify a trivial case from:  var getFirstTwo = \n           bind(getFirst, function(first){  \n    return bind(getSecond,function(second){  \n      var fancyResult2 = // And now make do fancy \n                         // with first and second\n      return RETURN(fancyResult2);\n    });})\n  , getAllThree = \n           bind(getFirstTwo, function(_){  \n    return bind(getThird,    function(three){  \n      return RETURN(three);\n    });});  To (using \"Right Identity\" ):  var getFirstTwo = \n           bind(getFirst, function(first){  \n    return bind(getSecond,function(second){  \n      var fancyResult2 = // And now make do fancy \n                         // with first and second\n      return RETURN(fancyResult2);\n    });})\n  , getAllThree = \n           bind(getFirstTwo, function(_){  \n    return getThird;\n    });  Or jam them back together:  var getAllThree = \n           bind(getFirst, function(first_dontCareNow){  \n    return bind(getSecond,function(second_dontCareNow){  \n    return getThird;\n    });});  The practicality of these abilities doesn't really emerge, or become clear until you try to solve really messy problems like parsing, or module/ajax/resource loading.  Can you imagine thousands of lines of indexOf/subString logic? What if frequent parsing steps were contained in little functions? Functions like chars , spaces , upperChars , or digits ? And what if those functions gave you the result in a callback, without having to mess with Regex groups, and arguments.slice? And what if their composition/decomposition was well understood? Such that you could build big parsers from the bottom up?  So the ability to manage nested callback scopes is incredibly practical , especially when working with monadic parser combinator libraries. (that is to say, in my experience)  DON'T GET HUNG UP ON: - CATEGORY-THEORY - MAYBE-MONADS - MONAD LAWS - HASKELL - !!!! ", "question_id": 44965}, "0.2801442376730847", 4], [{"answer_votes": "-1", "answer_comments": [" Big Mistake : monad computation can be triggerred wo. main. \u2013 Titou  Jul 13 '15 at 13:28 "], "answer_body": " Mathematial thinking  For short: An Algebraic Structure for Combining Computations.  return data : create a computation who just simply generate a data in monad world.  (return data) >>= (return func) : The second parameter accept first parameter as a data generator and create a new computations which concatenate them.  You can think that (>>=) and return won't do any computation itself. They just simply combine and create computations.  Any monad computation will be compute if and only if main trigs it. ", "question_id": 44965}, "0.2801442376730847", 4], [{"answer_votes": "-1", "answer_comments": null, "answer_body": " Explanation  It's quite simple, when explained in C#/Java terms:   A monad is a function that takes arguments and returns a special type.  The special type that this monad returns is also called monad. (A monad is a combination of #1 and #2)  There's some syntactic sugar to make calling this function and conversion of types easier.   Example  A monad is useful to make the life of the functional programmer easier. The typical example: The Maybe monad takes two parameters, a value and a function. It returns null if the passed value is null . Otherwise it evaluates the function. If we needed a special return type, we would call this return type Maybe as well. A very crude implementation would look like this:  object Maybe(object value, Func<object,object> function)\n{\n    if(value==null)\n        return null;\n\n    return function(value);\n}  This is spectacularly useless in C# because this language lacks the required syntactic sugar to make monads useful. But monads allow you to write more concise code in functional programming languages.  Oftentimes programmers call monads in chains, like so:  var x = Maybe(x, x2 => Maybe(y, y2 => Add(x2, y2)));  In this example the Add method would only be called if x and y are both non- null , otherwise null will be returned.  Answer  To answer the original question: A monad is a function AND a type. Like an implementation of a special interface . ", "question_id": 44965}, "0.2801442376730847", 4], [{"answer_votes": "34", "answer_comments": [" The only problem with Wadler's paper is the notation is different but I agree that the paper is pretty compelling and a clear concise motivation for applying monads. \u2013 Jared Updike  Jul 31 '09 at 22:34 ", " +1 for the \"monad tutorial fallacy\". Tutorials on monads are akin to having several tutorials trying to explain the concept of integer numbers. One tutorial would say, \"1 is similar to an apple\"; another tutorial says, \"2 is like a pear\"; a third one says, \"3 is basically an orange\". But you never get the whole picture from any single tutorial. What I've taken from that is that monads are an abstract concept which can be used for many quite different purposes. \u2013 stakx  Jan 14 '11 at 7:30  ", " @stakx: Yes, true. But I didn't mean that monads are an abstraction that you cannot learn or shouldn't learn; only that it's best to learn it after you've seen enough concrete examples to perceive a single underlying abstraction. See my other answer here . \u2013 ShreevatsaR  Jan 14 '11 at 12:22 ", " Sometimes I feel that there are so many tutorials that try to convince the reader that monads are useful by using code that do complicated or useful stuff. That hindered my understanding for months. I don't learn that way. I prefer to see extremely simple code, doing something stupid that I can mentally go through and I couldn't find this kind of example. I can't learn if the first example is a monad to parse a complicate grammar. I can learn if it's a monad to sum integers. \u2013 Rafael S. Calsaverini  Jan 23 '11 at 23:11  ", " Mentioning only type constructor is incomplete: stackoverflow.com/a/37345315/1614973 \u2013 Dmitri Zaitsev  May 20 '16 at 12:18 "], "answer_body": " (See also the answers at What is a monad? )  A good motivation to Monads is sigfpe (Dan Piponi)'s You Could Have Invented Monads! (And Maybe You Already Have) . There are a LOT of other monad tutorials , many of which misguidedly try to explain monads in \"simple terms\" using various analogies: this is the monad tutorial fallacy ; avoid them.  As DR MacIver says in Tell us why your language sucks :   So, things I hate about Haskell:   Let\u2019s start with the obvious. Monad tutorials. No, not monads. Specifically the tutorials. They\u2019re endless, overblown and dear god are they tedious. Further, I\u2019ve never seen any convincing evidence that they actually help. Read the class definition, write some code, get over the scary name.  You say you understand the Maybe monad? Good, you're on your way. Just start using other monads and sooner or later you'll understand what monads are in general.  [If you are mathematically oriented, you might want to ignore the dozens of tutorials and learn the definition, or follow lectures in category theory :)\nThe main part of the definition is that a Monad M involves a \"type constructor\" that defines for each existing type \"T\" a new type \"M T\", and some ways for going back and forth between \"regular\" types and \"M\" types.]  Also, surprisingly enough, one of the best introductions to monads is actually one of the early academic papers introducing monads, Philip Wadler's Monads for functional programming . It actually has practical, non-trivial motivating examples, unlike many of the artificial tutorials out there. ", "question_id": 44965}, "0.2782666329294443", 2], [{"answer_votes": "24", "answer_comments": null, "answer_body": " Monads are to control flow what abstract data types are to data.  In other words, many developers are comfortable with the idea of Sets, Lists, Dictionaries (or Hashes, or Maps), and Trees. Within those data types there are many special cases (for instance InsertionOrderPreservingIdentityHashMap).  However, when confronted with program \"flow\" many developers haven't been exposed to many more constructs than if, switch/case, do, while, goto (grr), and (maybe) closures.  So, a monad is simply a control flow construct. A better phrase to replace monad would be 'control type'.  As such, a monad has slots for control logic, or statements, or functions - the equivalent in data structures would be to say that some data structures allow you to add data, and remove it.  For example, the \"if\" monad:  if( clause ) then block  at its simplest has two slots - a clause, and a block. The if monad is usually built to evaluate the result of the clause, and if not false, evaluate the block. Many developers are not introduced to monads when they learn 'if', and it just isn't necessary to understand monads to write effective logic.  Monads can become more complicated, in the same way that data structures can become more complicated, but there are many broad categories of monad that may have similar semantics, but differing implementations and syntax.  Of course, in the same way that data structures may be iterated over, or traversed, monads may be evaluated.  Compilers may or may not have support for user-defined monads. Haskell certainly does. Ioke has some similar capabilities, although the term monad is not used in the language. ", "question_id": 44965}, "0.2782666329294443", 2], [{"answer_votes": "8", "answer_comments": [" If you use jQuery, this explanation can be very helpful, especially if your Haskell isn't strong \u2013 byteclub  Dec 15 '10 at 16:16 ", " JQuery is emphatically not a monad. The linked article is wrong. \u2013 Tony Morris  Jun 19 '12 at 8:13 ", " Being \"emphatic\" isn't very convincing.  For some useful discussion on the topic, see Is jQuery a monad - Stack Overflow \u2013 nealmcb  Mar 25 '13 at 4:23 ", " See also Douglas Crackford's Google Talk Monads and Gonads and his Javascript code for doing modads, expanding on the similar behavior of AJAX libraries and Promises: douglascrockford/monad \u00b7 GitHub \u2013 nealmcb  Mar 25 '13 at 5:10 "], "answer_body": " In addition to the excellent answers above, let me offer you a link to the following article (by Patrick Thomson) which explains monads by relating the concept to the JavaScript library jQuery (and its way of using \"method chaining\" to manipulate the DOM): jQuery is a Monad  The jQuery documentation itself doesn't refer to the term \"monad\" but talks about the \"builder pattern\" which is probably more familiar.  This doesn't change the fact that you have a proper monad there maybe without even realizing it. ", "question_id": 44965}, "0.2782666329294443", 2], [{"answer_votes": "5", "answer_comments": null, "answer_body": " The two things that helped me best when learning about there were:  Chapter 8, \"Functional Parsers,\" from Graham Hutton's book Programming in Haskell . This doesn't mention monads at all, actually, but if you can work through chapter and really understand everything in it, particularly how a sequence of bind operations is evaluated, you'll understand the internals of monads. Expect this to take several tries.  The tutorial All About Monads . This gives several good examples of their use, and I have to say that the analogy in Appendex I worked for me. ", "question_id": 44965}, "0.2782666329294443", 2], [{"answer_votes": "5", "answer_comments": null, "answer_body": " Monoid appears to be something that ensures that all operations defined on a Monoid and a supported type will always return a supported type inside the Monoid. Eg, Any number + Any number = A number, no errors.  Whereas division accepts two fractionals, and returns a fractional, which defined division by zero as Infinity in haskell somewhy(which happens to be a fractional somewhy)...  In any case, it appears Monads are just a way to ensure that your chain of operations behaves in a predictable way, and a function that claims to be Num -> Num, composed with another function of Num->Num called with x does not say, fire the missiles.  On the other hand, if we have a function which does fire the missiles, we can compose it with other functions which also fire the missiles, because our intent is clear -- we want to fire the missiles -- but it won't try printing \"Hello World\" for some odd reason.  In Haskell, main is of type IO (), or IO [()], the distiction is strange and I will not discuss it but here's what I think happens:  If I have main, I want it to do a chain of actions, the reason I run the program is to produce an effect -- usually though IO. Thus I can chain IO operations together in main in order to -- do IO, nothing else.  If I try to do something which does not \"return IO\", the program will complain that the chain does not flow, or basically \"How does this relate to what we are trying to do -- an IO action\", it appears to force the programmer to keep their train of thought, without straying off and thinking about firing the missiles, while creating algorithms for sorting -- which does not flow.  Basically, Monads appear to be a tip to the compiler that \"hey, you know this function that returns a number here, it doesn't actually always work, it can sometimes produce a Number, and sometimes Nothing at all, just keep this in mind\". Knowing this, if you try to assert a monadic action, the monadic action may act as a compile time exception saying \"hey, this isn't actually a number, this CAN be a number, but you can't assume this, do something to ensure that the flow is acceptable.\" which prevents unpredictable program behavior -- to a fair extent.  It appears monads are not about purity, nor control, but about maintaining an identity of a category on which all behavior is predictable and defined, or does not compile. You cannot do nothing when you are expected to do something, and you cannot do something if you are expected to do nothing (visible).  The biggest reason I could think of for Monads is -- go look at Procedural/OOP code, and you will notice that you do not know where the program starts, nor ends, all you see is a lot of jumping and a lot of math,magic,and missiles. You will not be able to maintain it, and if you can, you will spend quite a lot of time wrapping your mind around the whole program before you can understand any part of it, because modularity in this context is based on interdependant \"sections\" of code, where code is optimized to be as related as possible for promise of efficiency/inter-relation. Monads are very concrete, and well defined by definition, and ensure that the flow of program is possible to analyze, and isolate parts which are hard to analyze -- as they themselves are monads. A monad appears to be a \"comprehensible unit which is predictable upon its full understanding\" -- If you understand \"Maybe\" monad, there's no possible way it will do anything except be \"Maybe\", which appears trivial, but in most non monadic code, a simple function \"helloworld\" can fire the missiles, do nothing, or destroy the universe or even distort time -- we have no idea nor have any guarantees that IT IS WHAT IT IS. A monad GUARANTEES that IT IS WHAT IT IS. which is very powerful.  All things in \"real world\" appear to be monads, in the sense that it is bound by definite observable laws preventing confusion. This does not mean we have to mimic all the operations of this object to create classes, instead we can simply say \"a square is a square\", nothing but a square, not even a rectangle nor a circle, and \"a square has area of the length of one of it's existing dimensions multiplied by itself. No matter what square you have, if it's a square in 2D space, it's area absolutely cannot be anything but its length squared, it's almost trivial to prove. This is very powerful because we do not need to make assertions to make sure that our world is the way it is, we just use implications of reality to prevent our programs from falling off track.  Im pretty much guaranteed to be wrong but I think this could help somebody out there, so hopefully it helps somebody. ", "question_id": 44965}, "0.2782666329294443", 2], [{"answer_votes": "4", "answer_comments": null, "answer_body": " If I've understood correctly, IEnumerable is derived from monads. I wonder if that might be an interesting angle of approach for those of us from the C# world?  For what it's worth, here are some links to tutorials that helped me (and no, I still haven't understood what monads are).   http://osteele.com/archives/2007/12/overloading-semicolon  http://spbhug.folding-maps.org/wiki/MonadsEn  http://www.loria.fr/~kow/monads/  ", "question_id": 44965}, "0.2782666329294443", 2], [{"answer_votes": "3", "answer_comments": [" See if this helps projects.tmorris.net/public/what-does-monad-mean/artifacts/1.1/\u2026 \u2013 Tony Morris  Sep 9 '10 at 22:17  ", " Google Code is going to be closed down on 2016-01-15. Most projects are now read-only, as of 2015-08-24. \u2013 Peter Mortensen  Aug 28 '15 at 17:37 "], "answer_body": " http://code.google.com/p/monad-tutorial/ is a work in progress to address exactly this question. ", "question_id": 44965}, "0.2782666329294443", 2], [{"answer_votes": "2", "answer_comments": [" You seem to be the only one who finally addressed my main problem with understanding Monads. Nobody ever talks about HOW can the value be extracted. Is it implementation dependant? \u2013 Vinicius Seufitele  Aug 22 '12 at 16:39 ", " @ViniciusSeufitele, thanks for your comment. I'm afraid that my understanding hasn't advanced a great deal since I wrote this answer, so I can't really add much. The value extraction logically has to exist, so maybe that's why nobody bothers to mention it. \u2013 Benjol  Aug 23 '12 at 5:45 ", " I have a discussion that treats the monad as a type expansion where the original type, b, is converted to an expanded type M<b> and the associated operators are wrapped to now service M<b>. These wrappers are what will handle the peculiarities of the monad. In particular, extracting the original type from the expanded type and passing it to it's wrapped operator and subsequently promoting the result. The benefit of the monad is that you retain simple declarative expressions. In my treatment I discussed expanding the numeric types system to include a DivByZero value to obviate the need to check \u2013 George  Oct 13 '14 at 16:45 ", " @ViniciusSeufitele , yes it is implementation dependent. The person writing the function >>= has access to the internals of the monad. For example see Maybe Monad and look for instance Monad Maybe . You'll see that when the left hand side is Just x then we return k x . The pattern matching does the unwrap for you. Something analogous happens in every monad implementation. \u2013 Michael Welch  Feb 3 '15 at 16:59  "], "answer_body": " Princess 's explanation of F# Computation Expressions helped me, though I still can't say I've really understood.  EDIT : this series - explaining monads with javascript - is the one that 'tipped the balance' for me.   http://blog.jcoglan.com/2011/03/05/translation-from-haskell-to-javascript-of-selected-portions-of-the-best-introduction-to-monads-ive-ever-read/  http://blog.jcoglan.com/2011/03/06/monad-syntax-for-javascript/  http://blog.jcoglan.com/2011/03/11/promises-are-the-monad-of-asynchronous-programming/   I think that understanding monads is something that creeps up on you. In that sense, reading as many 'tutorials' as you can is a good idea, but often strange stuff (unfamiliar language or syntax) prevents your brain from concentrating on the essential.  Some things that I had difficulty understanding:   Rules-based explanations never worked for me, because most practical examples actually require more than just return/bind.  Also, calling them rules didn't help. It is more a case of \"there are these things that have something in common, let's call the things 'monads', and the bits in common 'rules'\".  Return ( a -> M<a> ) and Bind ( M<a> -> (a -> M<b>) -> M<b> ) are great, but what I could never understand is HOW Bind could extract the a from M<a> in order to pass it into a -> M<b> . I don't think I've ever read anywhere (maybe it's obvious to everyone else), that the reverse of Return ( M<a> -> a ) has to exist inside the monad, it just doesn't need to be exposed.  ", "question_id": 44965}, "0.2782666329294443", 2], [{"answer_votes": "43", "answer_comments": [" Sometimes an explanation from a \"learner\" (like you) is more relevant to another learner than an explanation coming from an expert. Learners think alike :) \u2013 Adrian  Dec 7 '10 at 18:48 ", " What makes something a monad is the existence of a function with type M (M a) -> M a . The fact that you can turn that into one of type M a -> (a -> M b) -> M b is what makes them useful. \u2013 Jeremy List  Aug 19 '14 at 5:58 ", " \"monad\" roughly means \"pattern\" ... no. \u2013 user633183  May 19 '16 at 5:55 "], "answer_body": " [Disclaimer: I am still trying to fully grok monads. The following is just what I have understood so far. If it\u2019s wrong, hopefully someone knowledgeable will call me on the carpet.]  Arnar wrote:   Monads are simply a way to wrapping things and provide methods to do operations on the wrapped stuff without unwrapping it.   That\u2019s precisely it. The idea goes like this:   You take some kind of value and wrap it with some additional information. Just like the value is of a certain kind (eg. an integer or a string), so the additional information is of a certain kind.  E.g., that extra information might be a Maybe or an IO .  Then you have some operators that allow you to operate on the wrapped data while carrying along that additional information. These operators use the additional information to decide how to change the behaviour of the operation on the wrapped value.  E.g., a Maybe Int can be a Just Int or Nothing . Now, if you add a Maybe Int to a Maybe Int , the operator will check to see if they are both Just Int s inside, and if so, will unwrap the Int s, pass them the addition operator, re-wrap the resulting Int into a new Just Int (which is a valid Maybe Int ), and thus return a Maybe Int . But if one of them was a Nothing inside, this operator will just immediately return Nothing , which again is a valid Maybe Int . That way, you can pretend that your Maybe Int s are just normal numbers and perform regular math on them. If you were to get a Nothing , your equations will still produce the right result \u2013 without you having to litter checks for Nothing everywhere .   But the example is just what happens for Maybe . If the extra information was an IO , then that special operator defined for IO s would be called instead, and it could do something totally different before performing the addition. (OK, adding two IO Int s together is probably nonsensical \u2013 I\u2019m not sure yet.) (Also, if you paid attention to the Maybe example, you have noticed that \u201cwrapping a value with extra stuff\u201d is not always correct. But it\u2019s hard to be exact, correct and precise without being inscrutable.)  Basically, \u201cmonad\u201d roughly means \u201cpattern\u201d . But instead of a book full of informally explained and specifically named Patterns, you now have a language construct \u2013 syntax and all \u2013 that allows you to declare new patterns as things in your program . (The imprecision here is all the patterns have to follow a particular form, so a monad is not quite as generic as a pattern. But I think that\u2019s the closest term that most people know and understand.)  And that is why people find monads so confusing: because they are such a generic concept. To ask what makes something a monad is similarly vague as to ask what makes something a pattern.  But think of the implications of having syntactic support in the language for the idea of a pattern: instead of having to read the Gang of Four book and memorise the construction of a particular pattern, you just write code that implements this pattern in an agnostic, generic way once and then you are done! You can then reuse this pattern, like Visitor or Strategy or Fa\u00e7ade or whatever, just by decorating the operations in your code with it, without having to re-implement it over and over!  So that is why people who understand monads find them so useful : it\u2019s not some ivory tower concept that intellectual snobs pride themselves on understanding (OK, that too of course, teehee), but actually makes code simpler. ", "question_id": 44965}, "0.25753384456038475", 0], [{"answer_votes": "14", "answer_comments": null, "answer_body": " My favorite Monad tutorial:  http://www.haskell.org/haskellwiki/All_About_Monads  (out of 170,000 hits on a Google search for \"monad tutorial\"!)  @Stu: The point of monads is to allow you to add (usually) sequential semantics to otherwise pure code; you can even compose monads (using Monad Transformers) and get more interesting and complicated combined semantics, like parsing with error handling, shared state, and logging, for example. All of this is possible in pure code, monads just allow you to abstract it away and reuse it in modular libraries (always good in programming), as well as providing convenient syntax to make it look imperative.  Haskell already has operator overloading[1]: it uses type classes much the way one might use interfaces in Java or C# but Haskell just happens to also allow non-alphanumeric tokens like + && and > as infix identifiers. It's only operator overloading in your way of looking at it if you mean \"overloading the semicolon\" [2]. It sounds like black magic and asking for trouble to \"overload the semicolon\" (picture enterprising Perl hackers getting wind of this idea) but the point is that without monads there is no semicolon, since purely functional code does not require or allow explicit sequencing.  This all sounds much more complicated than it needs to. sigfpe's article is pretty cool but uses Haskell to explain it, which sort of fails to break the chicken and egg problem of understanding Haskell to grok Monads and understanding Monads to grok Haskell.  [1] This is a separate issue from monads but monads use Haskell's operator overloading feature.  [2] This is also an oversimplification since the operator for chaining monadic actions is >>= (pronounced \"bind\") but there is syntactic sugar (\"do\") that lets you use braces and semicolons and/or indentation and newlines. ", "question_id": 44965}, "0.25753384456038475", 0], [{"answer_votes": "9", "answer_comments": null, "answer_body": " I've been thinking of Monads in a different way, lately. I've been thinking of them as abstracting out execution order in a mathematical way, which makes new kinds of polymorphism possible.  If you're using an imperative language, and you write some expressions in order, the code ALWAYS runs exactly in that order.  And in the simple case, when you use a monad, it feels the same -- you define a list of expressions that happen in order. Except that, depending on which monad you use, your code might run in order (like in IO monad), in parallel over several items at once (like in the List monad), it might halt partway through (like in the Maybe monad), it might pause partway through to be resumed later (like in a Resumption monad), it might rewind and start from the beginning (like in a Transaction monad), or it might rewind partway to try other options (like in a Logic monad).  And because monads are polymorphic, it's possible to run the same code in different monads, depending on your needs.  Plus, in some cases, it's possible to combine monads together (with monad transformers) to get multiple features at the same time. ", "question_id": 44965}, "0.25753384456038475", 0], [{"answer_votes": "6", "answer_comments": [" That is more like Applicative than Monad.  With Monads, you have to get data from the pipes before you can choose the next pipe to connect. \u2013 Peaker  Jul 22 '10 at 23:33 "], "answer_body": " A monad is a way of combining computations together that share a common context.  It is like building a network of pipes.  When constructing the network, there is no data flowing through it.  But when I have finished piecing all the bits together with 'bind' and 'return' then I invoke something like runMyMonad monad data and the data flows through the pipes. ", "question_id": 44965}, "0.25753384456038475", 0], [{"answer_votes": "3", "answer_comments": [" Do you mean \"what the world doesn't need ...\"? Nice analogy though! \u2013 groverboy  Jan 6 '15 at 1:36 ", " @groverboy I think there was a hint of sarcasm \u2013 icc97  Mar 7 '17 at 8:35 ", " @icc97 you're right - the meaning is clear enough. Sarcasm unintended, apologies to the author. \u2013 groverboy  Mar 14 '17 at 2:29 ", " What the world needs is another comment thread confirming a sarcasm, but if read carefully I've written but so that should make it clear. \u2013 Eugene Yokota  Mar 21 '17 at 3:26 "], "answer_body": " What the world needs is another monad blog post, but I think this is useful in identifying existing monads in the wild.   monads are fractals     The above is a fractal called Sierpinski triangle, the only fractal I can remember to draw. Fractals are self-similar structure like the above triangle, in which the parts are similar to the whole (in this case exactly half the scale as parent triangle).  Monads are fractals. Given a monadic data structure, its values can be composed to form another value of the data structure. This is why it's useful to programming, and this is why it occurrs in many situations.  ", "question_id": 44965}, "0.25753384456038475", 0], [{"answer_votes": "2", "answer_comments": [" Lenses, not Monads, are a way for functional programmers to use imperative code without actually admitting it. \u2013 OleTraveler  Oct 18 '12 at 19:31 "], "answer_body": " Explaining monads seems to be like explaining control-flow statements. Imagine that a non-programmer asks you to explain them?  You can give them an explanation involving the theory - Boolean Logic, register values, pointers, stacks, and frames. But that would be crazy.  You could explain them in terms of the syntax. Basically all control-flow statements in C have curly brackets, and you can distinguish the condition and the conditional code by where they are relative to the brackets. That may be even crazier.  Or you could also explain loops, if statements, routines, subroutines, and possibly co-routines.  Monads can replace a fairly large number of programming techniques. There's a specific syntax in languages that support them, and some theories about them.  They are also a way for functional programmers to use imperative code without actually admitting it, but that's not their only use. ", "question_id": 44965}, "0.25753384456038475", 0], [{"answer_votes": "2", "answer_comments": [" As I understand, monads are more than that. Encapsulating mutable state in a \"pure\" functional languages is only one application of monads. \u2013 thSoft  Dec 30 '10 at 2:17 "], "answer_body": " A monad is a thing used to encapsulate objects that have changing state. It is most often encountered in languages that otherwise do not allow you to have modifiable state (e.g., Haskell).  An example would be for file I/O.  You would be able to use a monad for file I/O to isolate the changing state nature to just the code that used the Monad. The code inside the Monad can effectively ignore the changing state of the world outside the Monad - this makes it a lot easier to reason about the overall effect of your program. ", "question_id": 44965}, "0.25753384456038475", 0], [{"answer_votes": "162", "answer_comments": [" -> is right-associative, mirroring function application, which is left-associative, so leaving the parentheses out doesn't make a difference here. \u2013 Matthias Benkard  Oct 11 '08 at 16:06 ", " Your explanation did the trick for me. I would have added though a limited summing of some standard monads (reader, state, maybe, ...) to illustrate some practical uses and wrappings \u2013 Rabarberski  Apr 27 '09 at 8:36 ", " I don't think this is a very good explanation at all. Monads are simply A way? okay, which way? Why wouldn't I encapsulate using a class instead of a monad? \u2013 Breton  Nov 6 '10 at 22:14 ", " A longer explanation of this idea: blog.sigfpe.com/2007/04/trivial-monad.html \u2013 sdcvvc  Jan 25 '12 at 16:26  ", " @mb21: In case you're just pointing out that there are too many brackets, note that a->b->c is actually only short for a->(b->c). Writing this particular example as (a -> b) -> (Ta -> Tb) is strictly speaking just adding unncessary characters, but it's morally \"the right thing to do\" as it emphasises that fmap maps a function of type a -> b to a function of type Ta -> Tb. And originally, that's what functors do in category theory and that's where monads come from. \u2013 Nikolaj-K  Jul 21 '14 at 14:36  "], "answer_body": " Actually, contrary to common understanding of Monads, they have nothing to do with state. Monads are simply a way to wrapping things and provide methods to do operations on the wrapped stuff without unwrapping it.  For example, you can create a type to wrap another one, in Haskell:  data Wrapped a = Wrap a  To wrap stuff we define  return :: a -> Wrapped a\nreturn x = Wrap x  To perform operations without unwrapping, say you have a function f :: a -> b , then you can do this to lift that function to act on wrapped values:  fmap :: (a -> b) -> (Wrapped a -> Wrapped b)\nfmap f (Wrap x) = Wrap (f x)  That's about all there is to understand. However, it turns out that there is a more general function to do this lifting , which is bind :  bind :: (a -> Wrapped b) -> (Wrapped a -> Wrapped b)\nbind f (Wrap x) = f x  bind can do a bit more than fmap , but not vice versa. Actually, fmap can be defined only in terms of bind and return . So, when defining a monad.. you give its type (here it was Wrapped a ) and then say how its return and bind operations work.  The cool thing is that this turns out to be such a general pattern that it pops up all over the place, encapsulating state in a pure way is only one of them.  For a good article on how monads can be used to introduce functional dependencies and thus control order of evaluation, like it is used in Haskell's IO monad, check out IO Inside .  As for understanding monads, don't worry too much about it. Read about them what you find interesting and don't worry if you don't understand right away. Then just diving in a language like Haskell is the way to go. Monads are one of these things where understanding trickles into your brain by practice, one day you just suddenly realize you understand them. ", "question_id": 44965}, "0.1878245873376727", 1], [{"answer_votes": "77", "answer_comments": [" What exactly do you mean by \"maps a function over it\"? \u2013 Casebash  Mar 14 '10 at 6:24 ", " Casebash, I'm being deliberately informal in the introduction. See the examples near the end to get a sense of what \"mapping a function\" entails. \u2013 Chris Conway  Mar 14 '10 at 14:54 ", " Monad is not a datatype. It is a rule of composing functions: stackoverflow.com/a/37345315/1614973 \u2013 Dmitri Zaitsev  May 20 '16 at 12:16 "], "answer_body": " A monad is a datatype that has two operations: >>= (aka bind ) and return (aka unit ). return takes an arbitrary value and creates an instance of the monad with it. >>= takes an instance of the monad and maps a function over it. (You can see already that a monad is a strange kind of datatype, since in most programming languages you couldn't write a function that takes an arbitrary value and creates a type from it. Monads use a kind of parametric polymorphism .)  In Haskell notation, the monad interface is written  class Monad m where\n  return :: a -> m a\n  (>>=) :: forall a b . m a -> (a -> m b) -> m b  These operations are supposed to obey certain \"laws\", but that's not terrifically important: the \"laws\" just codify the way sensible implementations of the operations ought to behave (basically, that >>= and return ought to agree about how values get transformed into monad instances and that >>= is associative).  Monads are not just about state and I/O: they abstract a common pattern of computation that includes working with state, I/O, exceptions, and non-determinism. Probably the simplest monads to understand are lists and option types:  instance Monad [ ] where\n    []     >>= k = []\n    (x:xs) >>= k = k x ++ (xs >>= k)\n    return x     = [x]\n\ninstance Monad Maybe where\n    Just x  >>= k = k x\n    Nothing >>= k = Nothing\n    return x      = Just x  where [] and : are the list constructors, ++ is the concatenation operator, and Just and Nothing are the Maybe constructors. Both of these monads encapsulate common and useful patterns of computation on their respective data types (note that neither has anything to do with side effects or I/O).  You really have to play around writing some non-trivial Haskell code to appreciate what monads are about and why they are useful. ", "question_id": 44965}, "0.1878245873376727", 1], [{"answer_votes": "5", "answer_comments": null, "answer_body": " In the context of Scala you will find the following to be the simplest definition. Basically flatMap (or bind) is 'associative' and there exists an identity.  trait M[+A] {\n  def flatMap[B](f: A => M[B]): M[B] // AKA bind\n\n  // Pseudo Meta Code\n  def isValidMonad: Boolean = {\n    // for every parameter the following holds\n    def isAssociativeOn[X, Y, Z](x: M[X], f: X => M[Y], g: Y => M[Z]): Boolean =\n      x.flatMap(f).flatMap(g) == x.flatMap(f(_).flatMap(g))\n\n    // for every parameter X and x, there exists an id\n    // such that the following holds\n    def isAnIdentity[X](x: M[X], id: X => M[X]): Boolean =\n      x.flatMap(id) == x\n  }\n}  E.g.  // These could be any functions\nval f: Int => Option[String] = number => if (number == 7) Some(\"hello\") else None\nval g: String => Option[Double] = string => Some(3.14)\n\n// Observe these are identical. Since Option is a Monad \n// they will always be identical no matter what the functions are\nscala> Some(7).flatMap(f).flatMap(g)\nres211: Option[Double] = Some(3.14)\n\nscala> Some(7).flatMap(f(_).flatMap(g))\nres212: Option[Double] = Some(3.14)\n\n\n// As Option is a Monad, there exists an identity:\nval id: Int => Option[Int] = x => Some(x)\n\n// Observe these are identical\nscala> Some(7).flatMap(id)\nres213: Option[Int] = Some(7)\n\nscala> Some(7)\nres214: Some[Int] = Some(7)  NOTE Strictly speaking the definition of a Monad in functional programming is not the same as the definition of a Monad in Category Theory , which is defined in turns of map and flatten .  Though they are kind of equivalent under certain mappings.  This presentations is very good: http://www.slideshare.net/samthemonad/monad-presentation-scala-as-a-category ", "question_id": 44965}, "0.1878245873376727", 1], [{"answer_votes": "5", "answer_comments": null, "answer_body": " This answer begins with a motivating example, works through the example, derives an example of a monad, and formally defines \"monad\".  Consider these three functions in pseudocode:  f(<x, messages>) := <x, messages \"called f. \">\ng(<x, messages>) := <x, messages \"called g. \">\nwrap(x)          := <x, \"\">  f takes an ordered pair of the form <x, messages> and returns an ordered pair. It leaves the first item untouched and appends \"called f. \" to the second item. Same with g .  You can compose these functions and get your original value, along with a string that shows which order the functions were called in:  f(g(wrap(x)))\n= f(g(<x, \"\">))\n= f(<x, \"called g. \">)\n= <x, \"called g. called f. \">  You dislike the fact that f and g are responsible for appending their own log messages to the previous logging information. (Just imagine for the sake of argument that instead of appending strings, f and g must perform complicated logic on the second item of the pair. It would be a pain to repeat that complicated logic in two -- or more -- different functions.)  You prefer to write simpler functions:  f(x)    := <x, \"called f. \">\ng(x)    := <x, \"called g. \">\nwrap(x) := <x, \"\">  But look at what happens when you compose them:  f(g(wrap(x)))\n= f(g(<x, \"\">))\n= f(<<x, \"\">, \"called g. \">)\n= <<<x, \"\">, \"called g. \">, \"called f. \">  The problem is that passing a pair into a function does not give you what you want. But what if you could feed a pair into a function:  feed(f, feed(g, wrap(x)))\n= feed(f, feed(g, <x, \"\">))\n= feed(f, <x, \"called g. \">)\n= <x, \"called g. called f. \">  Read feed(f, m) as \"feed m into f \". To feed a pair <x, messages> into a function f is to pass  x into f , get <y, message> out of f , and return <y, messages message> .  feed(f, <x, messages>) := let <y, message> = f(x)\n                          in  <y, messages message>  Notice what happens when you do three things with your functions:  First: if you wrap a value and then feed the resulting pair into a function:  feed(f, wrap(x))\n= feed(f, <x, \"\">)\n= let <y, message> = f(x)\n  in  <y, \"\" message>\n= let <y, message> = <x, \"called f. \">\n  in  <y, \"\" message>\n= <x, \"\" \"called f. \">\n= <x, \"called f. \">\n= f(x)  That is the same as passing the value into the function.  Second: if you feed a pair into wrap :  feed(wrap, <x, messages>)\n= let <y, message> = wrap(x)\n  in  <y, messages message>\n= let <y, message> = <x, \"\">\n  in  <y, messages message>\n= <x, messages \"\">\n= <x, messages>  That does not change the pair.  Third: if you define a function that takes x and feeds g(x) into f :  h(x) := feed(f, g(x))  and feed a pair into it:  feed(h, <x, messages>)\n= let <y, message> = h(x)\n  in  <y, messages message>\n= let <y, message> = feed(f, g(x))\n  in  <y, messages message>\n= let <y, message> = feed(f, <x, \"called g. \">)\n  in  <y, messages message>\n= let <y, message> = let <z, msg> = f(x)\n                     in  <z, \"called g. \" msg>\n  in <y, messages message>\n= let <y, message> = let <z, msg> = <x, \"called f. \">\n                     in  <z, \"called g. \" msg>\n  in <y, messages message>\n= let <y, message> = <x, \"called g. \" \"called f. \">\n  in <y, messages message>\n= <x, messages \"called g. \" \"called f. \">\n= feed(f, <x, messages \"called g. \">)\n= feed(f, feed(g, <x, messages>))  That is the same as feeding the pair into g and feeding the resulting pair into f .  You have most of a monad. Now you just need to know about the data types in your program.  What type of value is <x, \"called f. \"> ? Well, that depends on what type of value x is. If x is of type t , then your pair is a value of type \"pair of t and string\". Call that type M t .  M is a type constructor: M alone does not refer to a type, but M _ refers to a type once you fill in the blank with a type. An M int is a pair of an int and a string. An M string is a pair of a string and a string. Etc.  Congratulations, you have created a monad!  Formally, your monad is the tuple <M, feed, wrap> .  A monad is a tuple <M, feed, wrap> where:   M is a type constructor.  feed takes a (function that takes a t and returns an M u ) and an M t and returns an M u .  wrap takes a v and returns an M v .   t , u , and v are any three types that may or may not be the same. A monad satisfies the three properties you proved for your specific monad:   Feeding a wrapped t into a function is the same as passing the unwrapped t into the function.  Formally: feed(f, wrap(x)) = f(x)  Feeding an M t into wrap does nothing to the M t .  Formally: feed(wrap, m) = m  Feeding an M t (call it m ) into a function that   passes the t into g  gets an M u (call it n ) from g  feeds n into f   is the same as   feeding m into g  getting n from g  feeding n into f   Formally: feed(h, m) = feed(f, feed(g, m)) where h(x) := feed(f, g(x))   Typically, feed is called bind (AKA >>= in Haskell) and wrap is called return . ", "question_id": 44965}, "0.1878245873376727", 1], [{"answer_votes": "3", "answer_comments": null, "answer_body": " tl;dr  {-# LANGUAGE InstanceSigs #-}\n\nnewtype Id t = Id t\n\ninstance Monad Id where\n   return :: t -> Id t\n   return = Id\n\n   (=<<) :: (a -> Id b) -> Id a -> Id b\n   f =<< (Id x) = f x  Prologue  The application operator $ of functions  forall a b. a -> b  is canonically defined  ($) :: (a -> b) -> a -> b\nf $ x = f x\n\ninfixr 0 $  in terms of Haskell-primitive function application f x ( infixl 10 ). Composition . is defined in terms of $ as  (.) :: (b -> c) -> (a -> b) -> (a -> c)\nf . g = \\ x -> f $ g x\n\ninfixr 9 .  and satisfies the equivalences forall f g h.  f . id  =  f            :: c -> d   Right identity\n     id . g  =  g            :: b -> c   Left identity\n(f . g) . h  =  f . (g . h)  :: a -> d   Associativity  . is associative, and id is its right and left identity.  The Kleisli triple  In programming, a monad is functor type constructor with an instance of the monad type class. There are several equivalent variants of definition and implementation, each carrying slightly different intuitions about the monad abstraction.  A functor is a type constructor f of kind * -> * with an instance of the functor type class.  {-# LANGUAGE KindSignatures #-}\n\nclass Functor (f :: * -> *) where\n   map :: (a -> b) -> (f a -> f b)  In addition to following statically enforced type protocol, instances of the functor type class must obey the algebraic functor laws  forall f g.  map id  =  id           :: f t -> f t   Identity\nmap f . map g  =  map (f . g)  :: f a -> f c   Composition / short cut fusion  Functor computations have the type  forall f t. Functor f => f t  A computation c r consists in results  r within context  c .  Unary monadic functions or Kleisli arrows have the type  forall m a b. Functor m => a -> m b  Kleisi arrows are functions that take one argument a and return a monadic computation m b .  Monads are canonically defined in terms of the Kleisli triple  forall m. Functor m =>  (m, return, (=<<))  implemented as the type class  class Functor m => Monad m where\n   return :: t -> m t\n   (=<<)  :: (a -> m b) -> m a -> m b\n\ninfixr 1 =<<  The Kleisli identity  return is a Kleisli arrow that promotes a value t into monadic context m . Extension or Kleisli application  =<< applies a Kleisli arrow a -> m b to results of a computation m a .  Kleisli composition  <=< is defined in terms of extension as  (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)\nf <=< g = \\ x -> f =<< g x\n\ninfixr 1 <=<  <=< composes two Kleisli arrows, applying the left arrow to results of the right arrow\u2019s application.  Instances of the monad type class must obey the monad laws , most elegantly stated in terms of Kleisli composition: forall f g h.  return <=< g  =  g                :: b -> m c   Left identity\n   f <=< return  =  f                :: c -> m d   Right identity\n(f <=< g) <=< h  =  f <=< (g <=< h)  :: a -> m d   Associativity  <=< is associative, and return is its right and left identity.  Identity  The identity type  type Id t = t  is the identity function on types  Id :: * -> *  Interpreted as a functor,  return :: t -> Id t\n=      id :: t ->    t\n\n    (=<<) :: (a -> Id b) -> Id a -> Id b\n=     ($) :: (a ->    b) ->    a ->    b\n\n    (<=<) :: (b -> Id c) -> (a -> Id b) -> (a -> Id c)\n=     (.) :: (b ->    c) -> (a ->    b) -> (a ->    c)  In canonical Haskell, the identity monad is defined  newtype Id t = Id t\n\ninstance Functor Id where\n   map :: (a -> b) -> Id a -> Id b\n   map f (Id x) = Id (f x)\n\ninstance Monad Id where\n   return :: t -> Id t\n   return = Id\n\n   (=<<) :: (a -> Id b) -> Id a -> Id b\n   f =<< (Id x) = f x  Option  An option type  data Maybe t = Nothing | Just t  encodes computation Maybe t that may not yield a result t , computation that may \u201cfail\u201d. The option monad is defined  instance Functor Maybe where\n   map :: (a -> b) -> (Maybe a -> Maybe b)\n   map f (Just x) = Just (f x)\n   map _ Nothing  = Nothing\n\ninstance Monad Maybe where\n   return :: t -> Maybe t\n   return = Just\n\n   (=<<) :: (a -> Maybe b) -> Maybe a -> Maybe b\n   f =<< (Just x) = f x\n   _ =<< Nothing  = Nothing  a -> Maybe b is applied only if Maybe a yields a result.  newtype Nat = Nat Int  The natural numbers can be encoded as those integers greater than or equal to zero.  toNat :: Int -> Maybe Nat\ntoNat i | i >= 0    = Just (Nat i)\n        | otherwise = Nothing  The natural numbers are not closed under subtraction.  (-?) :: Nat -> Nat -> Maybe Nat\n(Nat n) -? (Nat m) = toNat (n - m)\n\ninfixl 6 -?  The option monad covers a basic form of exception handling.  (-? 20) <=< toNat :: Int -> Maybe Nat  List  The list monad, over the list type  data [] t = [] | t : [t]\n\ninfixr 5 :  and its additive monoid operation \u201cappend\u201d  (++) :: [t] -> [t] -> [t]\n(x : xs) ++ ys = x : xs ++ ys\n[]       ++ ys = ys\n\ninfixr 5 ++  encodes nonlinear computation [t] yielding a natural amount 0, 1, ... of results t .  instance Functor [] where\n   map :: (a -> b) -> ([a] -> [b])\n   map f (x : xs) = f x : map f xs\n   map _ []       = []\n\ninstance Monad [] where\n   return :: t -> [t]\n   return = (: [])\n\n   (=<<) :: (a -> [b]) -> [a] -> [b]\n   f =<< (x : xs) = f x ++ f =<< xs\n   _ =<< []       = []  Extension concatenates ++ all result lists [b] from applications f x of a Kleisli arrow a -> [b] to elements of [a] into a single result list [b] .  Let the proper divisors of a positive integer n be  divisors :: Integral t => t -> [t]\ndivisors n = filter (`divides` n) [2 .. n - 1]\n\ndivides :: Integral t => t -> t -> Bool\n(`divides` n) = (== 0) . (n `rem`)  then  forall n.  let f = f <=< divisors in f n  =  []  In defining the monad type class, instead of extension =<< , the Haskell standard uses its flip, the bind operator >>= .  class Applicative m => Monad m where\n   (>>=) :: forall a b. m a -> (a -> m b) -> m b\n\n   (>>) :: forall a b. m a -> m b -> m b\n   m >> k = m >>= \\ _ -> k\n   {-# INLINE (>>) #-}\n\n   return :: a -> m a\n   return = pure\n\n   fail :: String -> m a\n   fail s = errorWithoutStackTrace s  For simplicitys sake, this explanation uses the type class hierarchy  class              Functor f\nclass Functor m => Monad m  In Haskell, the current standard hierarchy is  class                  Functor f\nclass Functor p     => Applicative p\nclass Applicative m => Monad m  because not only is every monad a functor, but every applicative is a functor and every monad an applicative, too.  Using the list monad, the imperative pseudocode  for a in (1, ..., 10)\n   for b in (1, ..., 10)\n      p <- a * b\n      if even(p)\n         yield p  roughly translates to the do block  do a <- [1 .. 10]\n   b <- [1 .. 10]\n   let p = a * b\n   guard (even p)\n   return p  the equivalent monad comprehension  [p | a <- [1 .. 10], b <- [1 .. 10], let p = a * b, even p]  and the expression  [1 .. 10] >>= (\\ a ->\n   [1 .. 10] >>= (\\ b ->\n      let p = a * b in\n         guard (even p) >>\n            return p\n   )\n)  Do notation and monad comprehensions are syntactic sugar for nested bind expressions. The bind operator is used for local name binding of monadic results.  let x = v in e  =  (\\ x -> e) $ v    =  v & (\\ x -> e)\n  do r <- m; c  =  (\\ r -> c) =<< m  =  m >>= (\\ r -> c)  where  (&) :: a -> (a -> b) -> b\n(&) = flip ($)\n\ninfixl 0 &  The guard function is defined  guard :: Additive m => Bool -> m ()\nguard True  = return ()\nguard False = fail  where the unit type or \u201cempty tuple\u201d  data () = ()  Additive monads that support choice and failure can be abstracted over using a type class  class Monad m => Additive m where\n   fail  :: m t\n   (<|>) :: m t -> m t -> m t\n\ninfixl 3 <|>\n\ninstance Additive Maybe where\n   fail = Nothing\n\n   Nothing <|> m = m\n   m       <|> _ = m\n\ninstance Additive [] where\n   fail = []\n   (<|>) = (++)  where fail and <|> form a monoid forall k l m.  fail <|> l  =  l\n     k <|> fail  =  k\n(k <|> l) <|> m  =  k <|> (l <|> m)  and fail is the absorbing/annihilating zero element of additive monads  _ =<< fail  =  fail  If in  guard (even p) >> return p  even p is true, then the guard produces [()] , and, by the definition of >> , the local constant function  \\ _ -> return p  is applied to the result () . If false, then the guard produces the list monad\u2019s fail  [] , which yields no result for a Kleisli arrow to be applied >> to.  State  Infamously, monads are used to encode stateful computation.  A state processor is a function  forall st t. st -> (t, st)  that transitions a state st and yields a result t . The state  st can be anything. Nothing, flag, count, array, handle, machine, world.  The type of state processors is usually called  type State st t = st -> (t, st)  The state processor monad is the kinded * -> * functor State st . Kleisli arrows of the state processor monad are functions  forall st a b. a -> (State st) b  In canonical Haskell, the lazy version of the state processor monad is defined  newtype State st t = State { stateProc :: st -> (t, st) }\n\ninstance Functor (State st) where\n   map :: (a -> b) -> ((State st) a -> (State st) b)\n   map f (State p) = State $ \\ s0 -> let (x, s1) = p s0\n                                     in  (f x, s1)\n\ninstance Monad (State st) where\n   return :: t -> (State st) t\n   return x = State $ \\ s -> (x, s)\n\n   (=<<) :: (a -> (State st) b) -> (State st) a -> (State st) b\n   f =<< (State p) = State $ \\ s0 -> let (x, s1) = p s0\n                                     in  stateProc (f x) s1  A state processor is run by supplying an initial state:  run :: State st t -> st -> (t, st)\nrun = stateProc\n\neval :: State st t -> st -> t\neval = fst . run\n\nexec :: State st t -> st -> st\nexec = snd . run  State access is provided by primitives get and put , methods of abstraction over stateful monads:  {-# LANGUAGE MultiParamTypeClasses, FunctionalDependencies #-}\n\nclass Monad m => Stateful m st |\u00a0m -> st where\n   get :: m st\n   put :: st -> m ()  m -> st declares a functional dependency of the state type st on the monad m ; that a State t , for example, will determine the state type to be t uniquely.  instance Stateful (State st) st where\n   get :: State st st\n   get = State $ \\ s -> (s, s)\n\n   put :: st -> State st ()\n   put s = State $ \\ _ -> ((), s)  with the unit type used analogously to void in C.  modify :: Stateful m st => (st -> st) -> m ()\nmodify f = do\n   s <- get\n   put (f s)\n\ngets :: Stateful m st => (st -> t) -> m t\ngets f = do\n   s <- get\n   return (f s)  gets is often used with record field accessors.  The state monad equivalent of the variable threading  let s0 = 34\n    s1 = (+ 1) s0\n    n = (* 12) s1\n    s2 = (+ 7) s1\nin  (show n, s2)  where s0 :: Int , is the equally referentially transparent, but infinitely more elegant and practical  (flip run) 34\n   (do\n      modify (+ 1)\n      n <- gets (* 12)\n      modify (+ 7)\n      return (show n)\n   )  modify (+ 1) is a computation of type State Int () , except for its effect equivalent to return () .  (flip run) 34\n   (modify (+ 1) >>\n      gets (* 12) >>= (\\ n ->\n         modify (+ 7) >>\n            return (show n)\n      )\n   )  The monad law of associativity can be written in terms of >>=  forall m f g.  (m >>= f) >>= g  =  m >>= (\\ x -> f x >>= g)  or  do {                 do {                   do {\n   r1 <- do {           x <- m;                r0 <- m;\n      r0 <- m;   =      do {            =      r1 <- f r0;\n      f r0                 r1 <- f x;          g r1\n   };                      g r1             }\n   g r1                 }\n}                    }  Like in expression-oriented programming (e.g. Rust), the last statement of a block represents its yield. The bind operator is sometimes called a \u201cprogrammable semicolon\u201d.  Iteration control structure primitives from structured imperative programming are emulated monadically  for :: Monad m => (a -> m b) -> [a] -> m ()\nfor f = foldr ((>>) . f) (return ())\n\nwhile :: Monad m => m Bool -> m t -> m ()\nwhile c m = do\n   b <- c\n   if b then m >> while c m\n        else return ()\n\nforever :: Monad m => m t\nforever m = m >> forever m  Input/Output  data World  The I/O world state processor monad is a reconciliation of pure Haskell and the real world, of functional denotative and imperative operational semantics. A close analogue of the actual strict implementation:  type IO t = World -> (t, World)  Interaction is facilitated by impure primitives  getChar         :: IO Char\nputChar         :: Char -> IO ()\nreadFile        :: FilePath -> IO String\nwriteFile       :: FilePath -> String -> IO ()\nhSetBuffering   :: Handle -> BufferMode -> IO ()\nhTell           :: Handle -> IO Integer\n. . .              . . .  The impurity of code that uses IO primitives is permanently protocolized by the type system. Because purity is awesome, what happens in IO , stays in IO .  unsafePerformIO :: IO t -> t  Or, at least, should.  The type signature of a Haskell program  main :: IO ()\nmain = putStrLn \"Hello, World!\"  expands to  World -> ((), World)  A function that transforms a world.  Epilogue  The category whiches objects are Haskell types and whiches morphisms are functions between Haskell types is, \u201cfast and loose\u201d, the category Hask .  A functor T is a mapping from a category C to a category D ; for each object in C an object in D  Tobj :  Obj(C) -> Obj(D)\n   f :: *      -> *  and for each morphism in C a morphism in D  Tmor :  HomC(X, Y) -> HomD(Tobj(X), Tobj(Y))\n map :: (a -> b)   -> (f a -> f b)  where X , Y are objects in C . HomC(X, Y) is the homomorphism class of all morphisms X -> Y in C . The functor must preserve morphism identity and composition, the \u201cstructure\u201d of C , in D .  Tmor    Tobj\n\n      T(id)  =  id        : T(X) -> T(X)   Identity\nT(f) . T(g)  =  T(f . g)  : T(X) -> T(Z)   Composition  The Kleisli category of a category C is given by a Kleisli triple  <T, eta, _*>  of an endofunctor  T : C -> C  ( f ), an identity morphism eta ( return ), and an extension operator * ( =<< ).  Each Kleisli morphism in Hask  f :  X -> T(Y)\n      f :: a -> m b  by the extension operator  (_)* :  Hom(X, T(Y)) -> Hom(T(X), T(Y))\n  (=<<) :: (a -> m b)   -> (m a -> m b)  is given a morphism in Hask \u2019s Kleisli category  f* :  T(X) -> T(Y)\n(f =<<) :: m a  -> m b  Composition in the Kleisli category .T is given in terms of extension  f .T g  =  f* . g       :  X -> T(Z)\nf <=< g  =  (f =<<) . g  :: a -> m c  and satisfies the category axioms  eta .T g  =  g                :  Y -> T(Z)   Left identity\n   return <=< g  =  g                :: b -> m c\n\n       f .T eta  =  f                :  Z -> T(U)   Right identity\n   f <=< return  =  f                :: c -> m d\n\n  (f .T g) .T h  =  f .T (g .T h)    :  X -> T(U)   Associativity\n(f <=< g) <=< h  =  f <=< (g <=< h)  :: a -> m d  which, applying the equivalence transformations  eta .T g  =  g\n     eta* . g  =  g               By definition of .T\n     eta* . g  =  id . g          forall f.  id . f  =  f\n         eta*  =  id              forall f g h.  f . h  =  g . h  ==>  f  =  g\n\n(f .T g) .T h  =  f .T (g .T h)\n(f* . g)* . h  =  f* . (g* . h)   By definition of .T\n(f* . g)* . h  =  f* . g* . h     . is associative\n    (f* . g)*  =  f* . g*         forall f g h.  f . h  =  g . h  ==>  f  =  g  in terms of extension are canonically given  eta*  =  id                 :  T(X) -> T(X)   Left identity\n       (return =<<)  =  id                 :: m t -> m t\n\n           f* . eta  =  f                  :  Z -> T(U)      Right identity\n   (f =<<) . return  =  f                  :: c -> m d\n\n          (f* . g)*  =  f* . g*            :  T(X) -> T(Z)   Associativity\n(((f =<<) . g) =<<)  =  (f =<<) . (g =<<)  :: m a -> m c  Monads can also be defined in terms not of Kleislian extension, but a natural transformation mu , in programming called join . A monad is defined in terms of mu as a triple over a category C , of an endofunctor  T :  C -> C\n     f :: * -> *  and two natural tranformations  eta :  Id -> T\nreturn :: t  -> f t\n\n    mu :  T . T   -> T\n  join :: f (f t) -> f t  satisfying the equivalences  mu . T(mu)  =  mu . mu               :  T . T . T -> T . T   Associativity\n  join . map join  =  join . join           :: f (f (f t)) -> f t\n\n      mu . T(eta)  =  mu . eta       =  id  :  T -> T               Identity\njoin . map return  =  join . return  =  id  :: f t -> f t  The monad type class is then defined  class Functor m => Monad m where\n   return :: t -> m t\n   join   :: m (m t) -> m t  The canonical mu implementation of the option monad:  instance Monad Maybe where\n   return = Just\n\n   join (Just m) = m\n   join Nothing  = Nothing  The concat function  concat :: [[a]] -> [a]\nconcat (x : xs) = x ++ concat xs\nconcat []       = []  is the join of the list monad.  instance Monad [] where\n   return :: t -> [t]\n   return = (: [])\n\n   (=<<) :: (a -> [b]) -> ([a] -> [b])\n   (f =<<) = concat . map f  Implementations of join can be translated from extension form using the equivalence  mu  =  id*           :  T . T -> T\n   join  =  (id =<<)      :: m (m t) -> m t  The reverse translation from mu to extension form is given by  f*  =  mu . T(f)     :  T(X) -> T(Y)\n(f =<<)  =  join . map f  :: m a -> m b    Philip Wadler: Monads for functional programming  Simon L Peyton Jones, Philip Wadler: Imperative functional programming  Jonathan M. D. Hill, Keith Clarke: An introduction to category theory, category theory monads, and their relationship to functional programming \u00b4  Kleisli category  Eugenio Moggi: Notions of computation and monads  What a monad is not    But why should a theory so abstract be of any use for programming?  The answer is simple: as computer scientists, we value abstraction ! When we design the interface to a software component, we want it to reveal as little as possible about the implementation. We want to be able to replace the implementation with many alternatives, many other \u2018instances\u2019 of the same \u2018concept\u2019. When we design a generic interface to many program libraries, it is even more important that the interface we choose have a variety of implementations. It is the generality of the monad concept which we value so highly, it is because category theory is so abstract that its concepts are so useful for programming.  It is hardly suprising, then, that the generalisation of monads that we present below also has a close connection to category theory. But we stress that our purpose is very practical: it is not to \u2018implement category theory\u2019, it is to find a more general way to structure combinator libraries. It is simply our good fortune that mathematicians have already done much of the work for us!   from Generalising Monads to Arrows by John Hughes ", "question_id": 44965}, "0.1878245873376727", 1], [{"answer_votes": "2", "answer_comments": null, "answer_body": " Another attempt at explaining monads, using just Python lists and the map function. I fully accept this isn't a full explanation, but I hope it gets at the core concepts.  I got the basis of this from the funfunfunction video on Monads and the Learn You A Haskell chapter 'For a Few Monads More' . I highly recommend watching the funfunfunction video.  At it's very simplest, Monads are objects that have a map and flatMap functions ( bind in Haskell). There are some extra required properties , but these are the core ones.  flatMap 'flattens' the output of map, for lists this just concatenates the values of the list e.g.  concat([[1], [4], [9]]) = [1, 4, 9]  So in Python we can very basically implement a Monad with just these two functions:  def flatMap(func, lst):\n    return concat(map(func, lst))\n\ndef concat(lst):\n    return sum(lst, [])  func is any function that takes a value and returns a list e.g.  lambda x: [x*x]  Explanation  For clarity I created the concat function in Python via a simple function , which sums the lists i.e. [] + [1] + [4] + [9] = [1, 4, 9] (Haskell has a native concat method).  I'm assuming you know what the map function is e.g.:  >>> list(map(lambda x: [x*x], [1,2,3]))\n[[1], [4], [9]]  Flattening is the key concept of Monads and for each object which is a Monad this flattening allows you to get at the value that is wrapped in the Monad.  Now we can call:  >>> flatMap(lambda x: [x*x], [1,2,3])\n[1, 4, 9]  This lambda is taking a value x and putting it into a list. A monad works with any function that goes from a value to a type of the monad, so a list in this case.  That's your monad defined .  I think the question of why they're useful has been answered in other questions.  More explanation  Other examples that aren't lists are JavaScript Promises, which have the then method and JavaScript Streams which have a flatMap method.  So Promises and Streams use a slightly different function which flattens out a Stream or a Promise and returns the value from within.  The Haskell list monad has the following definition:  instance Monad [] where  \n    return x = [x]  \n    xs >>= f = concat (map f xs)  \n    fail _ = []  i.e. there are three functions return (not to be confused with return in most other languages), >>= (the flatMap ) and fail .  Hopefully you can see the similarity between:  xs >>= f = concat (map f xs)  and:  def flatMap(f, xs):\n    return concat(map(f, xs)) ", "question_id": 44965}, "0.1878245873376727", 1], [{"answer_votes": "2", "answer_comments": [" here is an implementation: github.com/brianspinos777/Programming_cheat_sheets/blob/master/\u2026 \u2013 Brian Joseph Spinos  Dec 21 '17 at 21:23 ", " IOW, Monad is generalized function call protocol. \u2013 Will Ness  Jan 28 at 16:09 ", " You answer is the most helpful in my opinion. Although I have to say that I think the emphasis needs to be on the fact that the functions you're refering to don't just involve values in contexts, they actively put values in contexts.  So for example, a function, f :: m a -> m b would very easily compose with another function, g :: m b -> m c.  But monads (bind specifically) allows us to perpetually compose functions which put their input in the same context, without us needing to take the value out of that context first (which would effectively remove information from the value) \u2013 James  Mar 23 at 18:41  ", " @James I think that should be the emphasis for functors? \u2013 Jonas  Mar 24 at 5:03 ", " @Jonas I guess I didn't explain propperly.   When I say that the functions put values in contexts, I mean that they have type (a -> m b). These are very useful since putting a value into a context adds new information to it but it would usually be difficult to chain a (a -> m b) and a (b -> m c) together since we can't just take the value out of the context. So we would have to use some convoluted process to chain these functions together in a sensible way depending on the specific context and monads just allow us to do this in a consistent way, regardless of the context. \u2013 James  Mar 24 at 16:23 "], "answer_body": " I will try to explain Monad in the context of Haskell.  In functional programming, function composition is important. It allows our program to consist of small, easy-to-read functions.  Let's say we have two functions: g :: Int -> String and f :: String -> Bool .  We can do (f . g) x , which is just the same as f (g x) , where x is an Int value.  When doing composition/applying the result of one function to another, having the types match up is important. In the above case, the type of the result returned by g must be the same as the type accepted by f .  But sometimes values are in contexts, and this makes it a bit less easy to line up types. (Having values in contexts is very useful. For example, the Maybe Int type represents an Int value that may not be there, the IO String type represents a String value that is there as a result of performing some side effects.)  Let's say we now have g1 :: Int -> Maybe String and f1 :: String -> Maybe Bool . g1 and f1 are very similar to g and f respectively.  We can't do (f1 . g1) x or f1 (g1 x) , where x is an Int value. The type of the result returned by g1 is not what f1 expects.  We could compose f and g with the . operator, but now we can't compose f1 and g1 with . . The problem is that we can't straightforwardly pass a value in a context to a function that expects a value that is not in a context.  Wouldn't it be nice if we introduce an operator to compose g1 and f1 , such that we can write (f1 OPERATOR g1) x ? g1 returns a value in a context. The value will be taken out of context and applied to f1 . And yes, we have such an operator. It's <=< .  We also have the >>= operator that does for us the exact same thing, though in a slightly different syntax.  We write: g1 x >>= f1 . g1 x is a Maybe Int value. The >>= operator helps take that Int value out of the \"perhaps-not-there\" context, and apply it to f1 . The result of f1 , which is a Maybe Bool , will be the result of the entire >>= operation.  And finally, why is Monad useful? Because Monad is the type class that defines the >>= operator, very much the same as the Eq type class that defines the == and /= operators.  To conclude, the Monad type class defines the >>= operator that allows us to pass values in a context (we call these monadic values) to functions that don't expect values in a context. The context will be taken care of.  If there is one thing to remember here, it is that Monad s allow function composition that involves values in contexts . ", "question_id": 44965}, "0.1878245873376727", 1], [{"answer_votes": "1", "answer_comments": null, "answer_body": " http://mikehadlow.blogspot.com/2011/02/monads-in-c-8-video-of-my-ddd9-monad.html  This is the video you are looking for.  Demonstrating in C# what the problem is with composition and aligning the types, and then implementing them properly in C#. \nTowards the end he displays how the same C# code looks in F# and finally in Haskell. ", "question_id": 44965}, "0.1878245873376727", 1], [{"answer_votes": "0", "answer_comments": null, "answer_body": " Let the below \" {| a |m} \" represent some piece of monadic data. A data type which advertises an a :  (I got an a!)\n          /        \n    {| a |m}  Function, f , knows how to create a monad, if only it had an a :  (Hi f! What should I be?)\n                      /\n(You?. Oh, you'll be /\n that data there.)  /\n /                 /  (I got a b.)\n|    --------------      |\n|  /                     |\nf a                      |\n  |--later->       {| b |m}  Here we see function, f , tries to evaluate a monad but gets rebuked.  (Hmm, how do I get that a?)\n o       (Get lost buddy.\no         Wrong type.)\no       /\nf {| a |m}  Funtion, f , finds a way to extract the a by using >>= .  (Muaahaha. How you \n         like me now!?)       \n    (Better.)      \\\n        |     (Give me that a.)\n(Fine, well ok.)    |\n         \\          |\n   {| a |m}   >>=   f  Little does f know, the monad and >>= are in collusion.  (Yah got an a for me?)       \n(Yeah, but hey    | \n listen. I got    |\n something to     |\n tell you first   |\n ...)   \\        /\n         |      /\n   {| a |m}   >>=   f  But what do they actually talk about? Well, that depends on the monad. Talking solely in the abstract has limited use; you have to have some experience with particular monads to flesh out the understanding.  For instance, the data type Maybe  data Maybe a = Nothing | Just a  has a monad instance which will acts like the following...  Wherein, if the case is Just a  (Yah what is it?)       \n(... hm? Oh,      |\nforget about it.  |\nHey a, yr up.)    | \n            \\     |\n(Evaluation  \\    |\ntime already? \\   |\nHows my hair?) |  |\n      |       /   |\n      |  (It's    |\n      |  fine.)  /\n      |   /     /    \n   {| a |m}   >>=   f  But for the case of Nothing  (Yah what is it?)       \n(... There      |\nis no a. )      |\n  |        (No a?)\n(No a.)         |\n  |        (Ok, I'll deal\n  |         with this.)\n   \\            |\n    \\      (Hey f, get lost.) \n     \\          |   ( Where's my a? \n      \\         |     I evaluate a)\n       \\    (Not any more  |\n        \\    you don't.    |\n         |   We're returning\n         |   Nothing.)   /\n         |      |       /\n         |      |      /\n         |      |     /\n   {| a |m}   >>=   f      (I got a b.)\n                    |  (This is   \\\n                    |   such a     \\\n                    |   sham.) o o  \\\n                    |               o|\n                    |--later-> {| b |m}  So the Maybe monad lets a computation continue if it actually contains the a it advertises, but aborts the computation if it doesn't. The result, however is still a piece of monadic data, though not the output of f . For this reason, the Maybe monad is used to represent the context of failure.  Different monads behave differently. Lists are other types of data with monadic instances. They behave like the following:  (Ok, here's your a. Well, its\n a bunch of them, actually.)\n  |\n  |    (Thanks, no problem. Ok\n  |     f, here you go, an a.)\n  |       |\n  |       |        (Thank's. See\n  |       |         you later.)\n  |  (Whoa. Hold up f,      |\n  |   I got another         |\n  |   a for you.)           |\n  |       |      (What? No, sorry.\n  |       |       Can't do it. I \n  |       |       have my hands full\n  |       |       with all these \"b\" \n  |       |       I just made.) \n  |  (I'll hold those,      |\n  |   you take this, and   /\n  |   come back for more  /\n  |   when you're done   / \n  |   and we'll do it   / \n  |   again.)          /\n   \\      |  ( Uhhh. All right.)\n    \\     |       /    \n     \\    \\      /\n{| a |m}   >>=  f  In this case, the function knew how to make a list from it's input, but didn't know what to do with extra input and extra lists. The bind >>= , helped f out by combining the multiple outputs. I include this example to show that while >>= is responsible for extracting a , it also has access to the eventual bound output of f . Indeed, it will never extract any a unless it knows the eventual output has the same type of context.  There are other monads which are used to represent different contexts. Here's some characterizations of a few more. The IO monad doesn't actually have an a , but it knows a guy and will get that a for you. The State st monad has a secret stash of st that it will pass to f under the table, even though f just came asking for an a . The Reader r monad is similar to State st , although it only lets f look at r .  The point in all this is that any type of data which is declared itself to be a Monad is declaring some sort of context around extracting a value from the monad. The big gain from all this? Well, its easy enough to couch a calculation with some sort of context. It can get messy, however, when stringing together multiple context laden calculations. The monad operations take care of resolving the interactions of context so that the programmer doesn't have to.  Note, that use of the >>= eases a mess by by taking some of the autonomy away from f . That is, in the above case of Nothing for instance, f no longer gets to decide what to do in the case of Nothing ; it's encoded in >>= . This is the trade off. If it was necessary for f to decide what to do in the case of Nothing , then f should have been a function from Maybe a to Maybe b . In this case, Maybe being a monad is irrelevant.  Note, however, that sometimes a data type does not export it's constructors (looking at you IO), and if we want to work with the advertised value we have little choice but to work with it's monadic interface. ", "question_id": 44965}, "0.1878245873376727", 1], [{"answer_votes": "0", "answer_comments": null, "answer_body": " If you are asking for a succinct, practical explanation for something so abstract, then you can only hope for an abstract answer:  a -> b  is one way of representing a computation from a s to b s. You can chain computations, aka compose them together:  (b -> c) -> (a -> b) -> (a -> c)  More complex computations demand more complex types, e.g.:  a -> f b  is the type of computations from a s to b s that are into f s. You can also compose them:  (b -> f c) -> (a -> f b) -> (a -> f c)  It turns out this pattern appears literally everywhere and has the same properties as the first composition above (associativity, right- and left-identity).  One had to give this pattern a name, but then would it help to know that the first composition is formally characterised as a Semigroupoid ?  \"Monads are just as interesting and important as parentheses\" (Oleg Kiselyov) ", "question_id": 44965}, "0.1878245873376727", 1], [{"answer_votes": "951", "answer_comments": [" As someone who has had a great deal of problems understanding monads, I can say that this answer helped.. a little. However, there's still some things that I don't understand. In what way is the list comprehension a monad? Is there an expanded form of that example? Another thing that really bothers me about most monad explanations, including this one- Is that they keep mixing up \"what is a monad?\" with \"what is a monad good for?\" and \"How is a monad implemented?\".  you jumped that shark when you wrote \"A monad is basically just a type that supports the >>= operator.\" Which just had me... \u2013 Breton  Aug 10 '09 at 2:00 ", " Also I disagree with your conclusion about why monads are hard. If monads themselves aren't complex, then you should be able to explain what they are without a bunch of baggage. I don't want to know about the implementation when I ask the question \"What is a monad\", I want to know what itch it's meant to be scratching. So far it seems like the answer is \"Because the authors of haskell are sadomasochists and decided that you should do something stupidly complex to accomplish simple things, so you HAVE to learn monads to use haskell, not because they're in any way useful in themselves\"... \u2013 Breton  Aug 10 '09 at 2:08 ", " But.. that can't be right, can it? I think monads are hard because nobody can seem to figure out how to explain them without getting caught up in confusing implementation details. I mean.. what is a school bus? It's a metal platform with a device in the front which consumes a refined petroleum product to drive in a cycle some metallic pistons, which in turn rotate a crank shaft attached to some gears which drive some wheels. The wheels have inflated rubber bags around them which interface with an ashphalt surface to cause a collection of seats to move forward. The seats move forward because... \u2013 Breton  Aug 10 '09 at 2:12 ", " I read all of this and still don't know what a monad is, aside from the fact that it's something Haskell programmers don't understand well enough to explain. The examples don't help much, given that these are all things one can do without monads, and this answer doesn't make it clear how monads make them any easier, only more confusing. The one part of this answer that came close to being useful was where the syntactic sugar of example #2 was removed. I say came close because, aside from the first line, the expansion doesn't bear any real resemblance to the original. \u2013 Laurence Gonsalves  Dec 19 '11 at 4:44 ", " Another problem that seems to be endemic to explanations of monads is that it's written in Haskell. I'm not saying Haskell is a bad language -- I'm saying it's a bad language for explaining monads. If I knew Haskell I'd already understand monads, so if you want to explain monads, start by using a language that people who don't know monads are more likely to understand. If you must use Haskell, don't use the syntactic sugar at all -- use the smallest, simplest subset of the language you can, and don't assume an understanding of Haskell IO. \u2013 Laurence Gonsalves  Dec 19 '11 at 4:50 "], "answer_body": " First: The term monad is a bit vacuous if you are not a mathematician. An alternative term is computation builder which is a bit more descriptive of what they are actually useful for.  You ask for practical examples:  Example 1: List comprehension :  [x*2 | x<-[1..10], odd x]  This expression returns the doubles of all odd numbers in the range from 1 to 10. Very useful!  It turns out this is really just syntactic sugar for some operations within the List monad. The same list comprehension can be written as:  do\n   x <- [1..10]\n   if odd x \n       then [x * 2] \n       else []  Or even:  [1..10] >>= (\\x -> if odd x then [x*2] else [])  Example 2: Input/Output :  do\n   putStrLn \"What is your name?\"\n   name <- getLine\n   putStrLn (\"Welcome, \" ++ name ++ \"!\")  Both examples use monads, AKA computation builders. The common theme is that the monad chains operations in some specific, useful way. In the list comprehension, the operations are chained such that if an operation returns a list, then the following operations are performed on every item in the list. The IO monad on the other hand performs the operations sequentially, but passes a \"hidden variable\" along, which represents \"the state of the world\", which allows us to write I/O code in a pure functional manner.  It turns out the pattern of chaining operations is quite useful and is used for lots of different things in Haskell.  Another example is exceptions: Using the Error monad, operations are chained such that they are performed sequentially, except if an error is thrown, in which case the rest of the chain is abandoned.  Both the list-comprehension syntax and the do-notation are syntactic sugar for chaining operations using the >>= operator. A monad is basically just a type that supports the >>= operator.  Example 3: A parser  This is a very simple parser which parses either a quoted string or a number:  parseExpr = parseString <|> parseNumber\n\nparseString = do\n        char '\"'\n        x <- many (noneOf \"\\\"\")\n        char '\"'\n        return (StringValue x)\n\nparseNumber = do\n    num <- many1 digit\n    return (NumberValue (read num))  The operations char , digit , etc. are pretty simple. They either match or don't match. The magic is the monad which manages the control flow: The operations are performed sequentially until a match fails, in which case the monad backtracks to the latest <|> and tries the next option. Again, a way of chaining operations with some additional, useful semantics.  Example 4: Asynchronous programming  The above examples are in Haskell, but it turns out F# also supports monads. This example is stolen from Don Syme :  let AsyncHttp(url:string) =\n    async {  let req = WebRequest.Create(url)\n             let! rsp = req.GetResponseAsync()\n             use stream = rsp.GetResponseStream()\n             use reader = new System.IO.StreamReader(stream)\n             return reader.ReadToEnd() }  This method fetches a web page. The punch line is the use of GetResponseAsync - it actually waits for the response on a separate thread, while the main thread returns from the function. The last three lines are executed on the spawned thread when the response have been received.  In most other languages you would have to explicitly create a separate function for the lines that handle the response. The async monad is able to \"split\" the block on its own and postpone the execution of the latter half. (The async {} syntax indicates that the control flow in the block is defined by the async monad.)  How they work  So how can a monad do all these fancy control-flow thing? What actually happens in a do-block (or a computation expression as they are called in F#), is that every operation (basically every line) is wrapped in a separate anonymous function. These functions are then combined using the bind operator (spelled >>= in Haskell). Since the bind operation combines functions, it can execute them as it sees fit: sequentially, multiple times, in reverse, discard some, execute some on a separate thread when it feels like it and so on.  As an example, this is the expanded version of the IO-code from example 2:  putStrLn \"What is your name?\"\n>>= (\\_ -> getLine)\n>>= (\\name -> putStrLn (\"Welcome, \" ++ name ++ \"!\"))  This is uglier, but it's also more obvious what is actually going on. The >>= operator is the magic ingredient: It takes a value (on the left side) and combines it with a function (on the right side), to produce a new value. This new value is then taken by the next >>= operator and again combined with a function to produce a new value. >>= can be viewed as a mini-evaluator.  Note that >>= is overloaded for different types, so every monad has its own implementation of >>= . (All the operations in the chain have to be of the type of the same monad though, otherwise the >>= operator won't work.)  The simplest possible implementation of >>= just takes the value on the left and applies it to the function on the right and returns the result, but as said before, what makes the whole pattern useful is when there is something extra going on in the monad's implementation of >>= .  There is some additional cleverness in how the values are passed from one operation to the next, but this requires a deeper explanation of the Haskell type system.  Summing up  In Haskell-terms a monad is a parameterized type which is an instance of the Monad type class, which defines >>= along with a few other operators. In layman's terms, a monad is just a type for which the >>= operation is defined.  In itself >>= is just a cumbersome way of chaining functions, but with the presence of the do-notation which hides the \"plumbing\", the monadic operations turns out to be a very nice and useful abstraction, useful many places in the language, and useful for creating your own mini-languages in the language.  Why are monads hard?  For many Haskell-learners, monads are an obstacle they hit like a brick wall. It's not that monads themselves are complex, but that the implementation relies on many other advanced Haskell features like parameterized types, type classes, and so on. The problem is that Haskell I/O is based on monads, and I/O is probably one of the first things you want to understand when learning a new language - after all, it's not much fun to create programs which don't produce any output. I have no immediate solution for this chicken-and-egg problem, except treating I/O like \"magic happens here\" until you have enough experience with other parts of language. Sorry.  Excellent blog on monads: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html ", "question_id": 44965}, "0.12691422528587282", 3], [{"answer_votes": "30", "answer_comments": [" Monads weren't 'designed', they were applied from one domain (category theory) to another (I/O in purely functional programming languages). Did Newton 'design' the calculus? \u2013 Jared Updike  Jul 31 '09 at 22:40 ", " Point 1 and 2 above are correct and useful. Points 4 and 5 are sort of ad hominem, even if more or less true. They don't really help explain monads. \u2013 Jared Updike  Jul 31 '09 at 22:42 ", " Re: 4, 5: The \"Secret handshake\" thing is a red herring. Programming is full of jargon. Haskell just happens to call stuff what it is without pretending to rediscover something. If it exists in mathematics already, why make up a new name for it? The name is really not the reason people don't get monads; they are a subtle concept. The average person probably understands addition and multiplication, why don't they get the concept of an Abelian Group? Because it is more abstract and general and that person hasn't done the work to wrap their head around the concept. A name change wouldn't help. \u2013 Jared Updike  Jul 31 '09 at 22:53 ", " Sigh... I'm not making an attack on Haskell ... I was making a joke.  So, I don't really get the bit about being \"ad hominem\".  Yes, the calculus was \"designed\". That's why, for example, calculus students are taught the Leibniz notation, rather than the icky stuff Netwton used. Better design.  Good names help understanding a lot. If I called Abelian Groups \"distended wrinkle pods\", you may have trouble understanding me.  You might be saying \"but that name is nonsense\", no one would ever call them that.  To people who have never heard of category theory \"monad\" sounds like nonsense. \u2013 Scott Wisniewski  Aug 1 '09 at 1:21 ", " @Scott: sorry if my extensive comments made it seem I was getting defensive about Haskell. I enjoy your humor about the secret handshake and you will note I said it is more or less true. :-) If you called Abelian Groups \"distended wrinkle pods\" you would be making the same mistake of trying to give monads a \"better name\" (cf. F# \"computation expressions\"): the term exists and people who care know what monads are, but not what \"warm fuzzy things\" are (or \"computation expressions\"). If I understand your use of the term \"type operator\" correctly there are lots of other type operators than monads. \u2013 Jared Updike  Aug 3 '09 at 23:27 "], "answer_body": " A monad is, effectively, a form of \"type operator\". It will do three things. First it will \"wrap\" (or otherwise convert) a value of one type into another type (typically called a \"monadic type\"). Secondly it will make all the operations (or functions) available on the underlying type available on the monadic type. Finally it will provide support for combining its self with another monad to produce a composite monad.  The \"maybe monad\" is essentially the equivalent of \"nullable types\" in Visual Basic / C#. It takes a non nullable type \"T\" and converts it into a \"Nullable<T>\", and then defines what all the binary operators mean on a Nullable<T>.  Side effects are represented simillarly. A structure is created that holds descriptions of side effects alongside a function's return value. The \"lifted\" operations then copy around side effects as values are passed between functions.  They are called \"monads\" rather than the easier-to-grasp name of \"type operators\" for several reasons:   Monads have restrictions on what they can do (see the definiton for details).  Those restrictions, along with the fact that there are three operations involved, conform to the structure of something called a monad in Category Theory, which is an obscure branch of mathematics.  They were designed by proponents of \"pure\" functional languages  Proponents of pure functional languages like obscure branches of mathematics  Because the math is obscure, and monads are associated with particular styles of programming, people tend to use the word monad as a sort of secret handshake. Because of this no one has bothered to invest in a better name.  ", "question_id": 44965}, "0.12691422528587282", 3], [{"answer_votes": "8", "answer_comments": null, "answer_body": " Monads Are Not Metaphors , but a practically useful abstraction emerging from a common pattern, as Daniel Spiewak explains. ", "question_id": 44965}, "0.12691422528587282", 3], [{"answer_votes": "5", "answer_comments": null, "answer_body": " In practice, monad is a custom implementation of function composition operator that takes care of side effects and incompatible input and return values (for chaining). ", "question_id": 44965}, "0.12691422528587282", 3], [{"answer_votes": "2", "answer_comments": null, "answer_body": " A very simple answer is:  Monads are an abstraction that provide an interface for encapsulating values, for computing new encapsulated values, and for unwrapping the encapsulated value.  What's convenient about them in practice is that they provide a uniform interface for creating data types that model state while not being stateful .  It's important to understand that a Monad is an abstraction , that is, an abstract interface for dealing with a certain kind of data structure. That interface is then used to build data types that have monadic behavior.  You can find a very good and practical introduction in Monads in Ruby, Part 1: Introduction . ", "question_id": 44965}, "0.12691422528587282", 3]], [[{"answer_votes": "625", "answer_comments": [" I appreciate your answer\u2014especially the final concession that all of this is of course possible too without monads. One point to be made is that it's mostly easier with monads, but it's often not as efficient as doing it without them. Once you need to involve transformers, the extra layering of function calls (and function objects created) has a cost that's hard to see and control, rendered invisible by clever syntax. \u2013 seh  Apr 20 '12 at 16:35 ", " In Haskell at least, most of the overhead of monads gets stripped away by the optimiser. So the only real \"cost\" is in brain power required. (This is not insignificant if \"maintainability\" is something you care about.) But usually, monads make things easier , not harder. (Otherwise, why would you bother?) \u2013 MathematicalOrchid  Apr 21 '12 at 18:40 ", " I'm not sure whether or not Haskell supports this but mathematically you can define a monad either in terms of >>= and return or join and ap. >>= and return are what make monads practically useful but join and ap give a more intuitive understanding of what a monad is. \u2013 Jeremy List  Apr 2 '14 at 10:57 ", " Coming from a non-math, non-functional programming background, this answer made the most sense to me. \u2013 jrahhali  Aug 2 '17 at 23:55 ", " This is the first answer that actually gave me some idea of what the hell a monad is. Thank you for finding a way to explain it! \u2013 robotmay  Aug 14 '17 at 23:48 "], "answer_body": " Explaining \"what is a monad\" is a bit like saying \"what is a number?\" We use numbers all the time. But imagine you met someone who didn't know anything about numbers. How the heck would you explain what numbers are? And how would you even begin to describe why that might be useful?  What is a monad? The short answer: It's a specific way of chaining operations together.  In essence, you're writing execution steps and linking them together with the \"bind function\". (In Haskell, it's named >>= .) You can write the calls to the bind operator yourself, or you can use syntax sugar which makes the compiler insert those function calls for you. But either way, each step is separated by a call to this bind function.  So the bind function is like a semicolon; it separates the steps in a process. The bind function's job is to take the output from the previous step, and feed it into the next step.  That doesn't sound too hard, right? But there is more than one kind of monad. Why? How?  Well, the bind function can just take the result from one step, and feed it to the next step. But if that's \"all\" the monad does... that actually isn't very useful. And that's important to understand: Every useful monad does something else in addition to just being a monad. Every useful monad has a \"special power\", which makes it unique.  (A monad that does nothing special is called the \"identity monad\". Rather like the identity function, this sounds like an utterly pointless thing, yet turns out not to be... But that's another story\u2122.)  Basically, each monad has its own implementation of the bind function. And you can write a bind function such that it does hoopy things between execution steps. For example:   If each step returns a success/failure indicator, you can have bind execute the next step only if the previous one succeeded. In this way, a failing step aborts the whole sequence \"automatically\", without any conditional testing from you. (The Failure Monad .)  Extending this idea, you can implement \"exceptions\". (The Error Monad or Exception Monad .) Because you're defining them yourself rather than it being a language feature, you can define how they work. (E.g., maybe you want to ignore the first two exceptions and only abort when a third exception is thrown.)  You can make each step return multiple results , and have the bind function loop over them, feeding each one into the next step for you. In this way, you don't have to keep writing loops all over the place when dealing with multiple results. The bind function \"automatically\" does all that for you. (The List Monad .)  As well as passing a \"result\" from one step to another, you can have the bind function pass extra data around as well. This data now doesn't show up in your source code, but you can still access it from anywhere, without having to manually pass it to every function. (The Reader Monad .)  You can make it so that the \"extra data\" can be replaced. This allows you to simulate destructive updates , without actually doing destructive updates. (The State Monad and its cousin the Writer Monad .)  Because you're only simulating destructive updates, you can trivially do things that would be impossible with real destructive updates. For example, you can undo the last update , or revert to an older version .  You can make a monad where calculations can be paused , so you can pause your program, go in and tinker with internal state data, and then resume it.  You can implement \"continuations\" as a monad. This allows you to break people's minds!   All of this and more is possible with monads. Of course, all of this is also perfectly possible without monads too. It's just drastically easier using monads. ", "question_id": 44965}, "0.2801442376730847", 4], [{"answer_votes": "34", "answer_comments": [" The only problem with Wadler's paper is the notation is different but I agree that the paper is pretty compelling and a clear concise motivation for applying monads. \u2013 Jared Updike  Jul 31 '09 at 22:34 ", " +1 for the \"monad tutorial fallacy\". Tutorials on monads are akin to having several tutorials trying to explain the concept of integer numbers. One tutorial would say, \"1 is similar to an apple\"; another tutorial says, \"2 is like a pear\"; a third one says, \"3 is basically an orange\". But you never get the whole picture from any single tutorial. What I've taken from that is that monads are an abstract concept which can be used for many quite different purposes. \u2013 stakx  Jan 14 '11 at 7:30  ", " @stakx: Yes, true. But I didn't mean that monads are an abstraction that you cannot learn or shouldn't learn; only that it's best to learn it after you've seen enough concrete examples to perceive a single underlying abstraction. See my other answer here . \u2013 ShreevatsaR  Jan 14 '11 at 12:22 ", " Sometimes I feel that there are so many tutorials that try to convince the reader that monads are useful by using code that do complicated or useful stuff. That hindered my understanding for months. I don't learn that way. I prefer to see extremely simple code, doing something stupid that I can mentally go through and I couldn't find this kind of example. I can't learn if the first example is a monad to parse a complicate grammar. I can learn if it's a monad to sum integers. \u2013 Rafael S. Calsaverini  Jan 23 '11 at 23:11  ", " Mentioning only type constructor is incomplete: stackoverflow.com/a/37345315/1614973 \u2013 Dmitri Zaitsev  May 20 '16 at 12:18 "], "answer_body": " (See also the answers at What is a monad? )  A good motivation to Monads is sigfpe (Dan Piponi)'s You Could Have Invented Monads! (And Maybe You Already Have) . There are a LOT of other monad tutorials , many of which misguidedly try to explain monads in \"simple terms\" using various analogies: this is the monad tutorial fallacy ; avoid them.  As DR MacIver says in Tell us why your language sucks :   So, things I hate about Haskell:   Let\u2019s start with the obvious. Monad tutorials. No, not monads. Specifically the tutorials. They\u2019re endless, overblown and dear god are they tedious. Further, I\u2019ve never seen any convincing evidence that they actually help. Read the class definition, write some code, get over the scary name.  You say you understand the Maybe monad? Good, you're on your way. Just start using other monads and sooner or later you'll understand what monads are in general.  [If you are mathematically oriented, you might want to ignore the dozens of tutorials and learn the definition, or follow lectures in category theory :)\nThe main part of the definition is that a Monad M involves a \"type constructor\" that defines for each existing type \"T\" a new type \"M T\", and some ways for going back and forth between \"regular\" types and \"M\" types.]  Also, surprisingly enough, one of the best introductions to monads is actually one of the early academic papers introducing monads, Philip Wadler's Monads for functional programming . It actually has practical, non-trivial motivating examples, unlike many of the artificial tutorials out there. ", "question_id": 44965}, "0.2782666329294443", 2], [{"answer_votes": "43", "answer_comments": [" Sometimes an explanation from a \"learner\" (like you) is more relevant to another learner than an explanation coming from an expert. Learners think alike :) \u2013 Adrian  Dec 7 '10 at 18:48 ", " What makes something a monad is the existence of a function with type M (M a) -> M a . The fact that you can turn that into one of type M a -> (a -> M b) -> M b is what makes them useful. \u2013 Jeremy List  Aug 19 '14 at 5:58 ", " \"monad\" roughly means \"pattern\" ... no. \u2013 user633183  May 19 '16 at 5:55 "], "answer_body": " [Disclaimer: I am still trying to fully grok monads. The following is just what I have understood so far. If it\u2019s wrong, hopefully someone knowledgeable will call me on the carpet.]  Arnar wrote:   Monads are simply a way to wrapping things and provide methods to do operations on the wrapped stuff without unwrapping it.   That\u2019s precisely it. The idea goes like this:   You take some kind of value and wrap it with some additional information. Just like the value is of a certain kind (eg. an integer or a string), so the additional information is of a certain kind.  E.g., that extra information might be a Maybe or an IO .  Then you have some operators that allow you to operate on the wrapped data while carrying along that additional information. These operators use the additional information to decide how to change the behaviour of the operation on the wrapped value.  E.g., a Maybe Int can be a Just Int or Nothing . Now, if you add a Maybe Int to a Maybe Int , the operator will check to see if they are both Just Int s inside, and if so, will unwrap the Int s, pass them the addition operator, re-wrap the resulting Int into a new Just Int (which is a valid Maybe Int ), and thus return a Maybe Int . But if one of them was a Nothing inside, this operator will just immediately return Nothing , which again is a valid Maybe Int . That way, you can pretend that your Maybe Int s are just normal numbers and perform regular math on them. If you were to get a Nothing , your equations will still produce the right result \u2013 without you having to litter checks for Nothing everywhere .   But the example is just what happens for Maybe . If the extra information was an IO , then that special operator defined for IO s would be called instead, and it could do something totally different before performing the addition. (OK, adding two IO Int s together is probably nonsensical \u2013 I\u2019m not sure yet.) (Also, if you paid attention to the Maybe example, you have noticed that \u201cwrapping a value with extra stuff\u201d is not always correct. But it\u2019s hard to be exact, correct and precise without being inscrutable.)  Basically, \u201cmonad\u201d roughly means \u201cpattern\u201d . But instead of a book full of informally explained and specifically named Patterns, you now have a language construct \u2013 syntax and all \u2013 that allows you to declare new patterns as things in your program . (The imprecision here is all the patterns have to follow a particular form, so a monad is not quite as generic as a pattern. But I think that\u2019s the closest term that most people know and understand.)  And that is why people find monads so confusing: because they are such a generic concept. To ask what makes something a monad is similarly vague as to ask what makes something a pattern.  But think of the implications of having syntactic support in the language for the idea of a pattern: instead of having to read the Gang of Four book and memorise the construction of a particular pattern, you just write code that implements this pattern in an agnostic, generic way once and then you are done! You can then reuse this pattern, like Visitor or Strategy or Fa\u00e7ade or whatever, just by decorating the operations in your code with it, without having to re-implement it over and over!  So that is why people who understand monads find them so useful : it\u2019s not some ivory tower concept that intellectual snobs pride themselves on understanding (OK, that too of course, teehee), but actually makes code simpler. ", "question_id": 44965}, "0.25753384456038475", 0], [{"answer_votes": "162", "answer_comments": [" -> is right-associative, mirroring function application, which is left-associative, so leaving the parentheses out doesn't make a difference here. \u2013 Matthias Benkard  Oct 11 '08 at 16:06 ", " Your explanation did the trick for me. I would have added though a limited summing of some standard monads (reader, state, maybe, ...) to illustrate some practical uses and wrappings \u2013 Rabarberski  Apr 27 '09 at 8:36 ", " I don't think this is a very good explanation at all. Monads are simply A way? okay, which way? Why wouldn't I encapsulate using a class instead of a monad? \u2013 Breton  Nov 6 '10 at 22:14 ", " A longer explanation of this idea: blog.sigfpe.com/2007/04/trivial-monad.html \u2013 sdcvvc  Jan 25 '12 at 16:26  ", " @mb21: In case you're just pointing out that there are too many brackets, note that a->b->c is actually only short for a->(b->c). Writing this particular example as (a -> b) -> (Ta -> Tb) is strictly speaking just adding unncessary characters, but it's morally \"the right thing to do\" as it emphasises that fmap maps a function of type a -> b to a function of type Ta -> Tb. And originally, that's what functors do in category theory and that's where monads come from. \u2013 Nikolaj-K  Jul 21 '14 at 14:36  "], "answer_body": " Actually, contrary to common understanding of Monads, they have nothing to do with state. Monads are simply a way to wrapping things and provide methods to do operations on the wrapped stuff without unwrapping it.  For example, you can create a type to wrap another one, in Haskell:  data Wrapped a = Wrap a  To wrap stuff we define  return :: a -> Wrapped a\nreturn x = Wrap x  To perform operations without unwrapping, say you have a function f :: a -> b , then you can do this to lift that function to act on wrapped values:  fmap :: (a -> b) -> (Wrapped a -> Wrapped b)\nfmap f (Wrap x) = Wrap (f x)  That's about all there is to understand. However, it turns out that there is a more general function to do this lifting , which is bind :  bind :: (a -> Wrapped b) -> (Wrapped a -> Wrapped b)\nbind f (Wrap x) = f x  bind can do a bit more than fmap , but not vice versa. Actually, fmap can be defined only in terms of bind and return . So, when defining a monad.. you give its type (here it was Wrapped a ) and then say how its return and bind operations work.  The cool thing is that this turns out to be such a general pattern that it pops up all over the place, encapsulating state in a pure way is only one of them.  For a good article on how monads can be used to introduce functional dependencies and thus control order of evaluation, like it is used in Haskell's IO monad, check out IO Inside .  As for understanding monads, don't worry too much about it. Read about them what you find interesting and don't worry if you don't understand right away. Then just diving in a language like Haskell is the way to go. Monads are one of these things where understanding trickles into your brain by practice, one day you just suddenly realize you understand them. ", "question_id": 44965}, "0.1878245873376727", 1], [{"answer_votes": "951", "answer_comments": [" As someone who has had a great deal of problems understanding monads, I can say that this answer helped.. a little. However, there's still some things that I don't understand. In what way is the list comprehension a monad? Is there an expanded form of that example? Another thing that really bothers me about most monad explanations, including this one- Is that they keep mixing up \"what is a monad?\" with \"what is a monad good for?\" and \"How is a monad implemented?\".  you jumped that shark when you wrote \"A monad is basically just a type that supports the >>= operator.\" Which just had me... \u2013 Breton  Aug 10 '09 at 2:00 ", " Also I disagree with your conclusion about why monads are hard. If monads themselves aren't complex, then you should be able to explain what they are without a bunch of baggage. I don't want to know about the implementation when I ask the question \"What is a monad\", I want to know what itch it's meant to be scratching. So far it seems like the answer is \"Because the authors of haskell are sadomasochists and decided that you should do something stupidly complex to accomplish simple things, so you HAVE to learn monads to use haskell, not because they're in any way useful in themselves\"... \u2013 Breton  Aug 10 '09 at 2:08 ", " But.. that can't be right, can it? I think monads are hard because nobody can seem to figure out how to explain them without getting caught up in confusing implementation details. I mean.. what is a school bus? It's a metal platform with a device in the front which consumes a refined petroleum product to drive in a cycle some metallic pistons, which in turn rotate a crank shaft attached to some gears which drive some wheels. The wheels have inflated rubber bags around them which interface with an ashphalt surface to cause a collection of seats to move forward. The seats move forward because... \u2013 Breton  Aug 10 '09 at 2:12 ", " I read all of this and still don't know what a monad is, aside from the fact that it's something Haskell programmers don't understand well enough to explain. The examples don't help much, given that these are all things one can do without monads, and this answer doesn't make it clear how monads make them any easier, only more confusing. The one part of this answer that came close to being useful was where the syntactic sugar of example #2 was removed. I say came close because, aside from the first line, the expansion doesn't bear any real resemblance to the original. \u2013 Laurence Gonsalves  Dec 19 '11 at 4:44 ", " Another problem that seems to be endemic to explanations of monads is that it's written in Haskell. I'm not saying Haskell is a bad language -- I'm saying it's a bad language for explaining monads. If I knew Haskell I'd already understand monads, so if you want to explain monads, start by using a language that people who don't know monads are more likely to understand. If you must use Haskell, don't use the syntactic sugar at all -- use the smallest, simplest subset of the language you can, and don't assume an understanding of Haskell IO. \u2013 Laurence Gonsalves  Dec 19 '11 at 4:50 "], "answer_body": " First: The term monad is a bit vacuous if you are not a mathematician. An alternative term is computation builder which is a bit more descriptive of what they are actually useful for.  You ask for practical examples:  Example 1: List comprehension :  [x*2 | x<-[1..10], odd x]  This expression returns the doubles of all odd numbers in the range from 1 to 10. Very useful!  It turns out this is really just syntactic sugar for some operations within the List monad. The same list comprehension can be written as:  do\n   x <- [1..10]\n   if odd x \n       then [x * 2] \n       else []  Or even:  [1..10] >>= (\\x -> if odd x then [x*2] else [])  Example 2: Input/Output :  do\n   putStrLn \"What is your name?\"\n   name <- getLine\n   putStrLn (\"Welcome, \" ++ name ++ \"!\")  Both examples use monads, AKA computation builders. The common theme is that the monad chains operations in some specific, useful way. In the list comprehension, the operations are chained such that if an operation returns a list, then the following operations are performed on every item in the list. The IO monad on the other hand performs the operations sequentially, but passes a \"hidden variable\" along, which represents \"the state of the world\", which allows us to write I/O code in a pure functional manner.  It turns out the pattern of chaining operations is quite useful and is used for lots of different things in Haskell.  Another example is exceptions: Using the Error monad, operations are chained such that they are performed sequentially, except if an error is thrown, in which case the rest of the chain is abandoned.  Both the list-comprehension syntax and the do-notation are syntactic sugar for chaining operations using the >>= operator. A monad is basically just a type that supports the >>= operator.  Example 3: A parser  This is a very simple parser which parses either a quoted string or a number:  parseExpr = parseString <|> parseNumber\n\nparseString = do\n        char '\"'\n        x <- many (noneOf \"\\\"\")\n        char '\"'\n        return (StringValue x)\n\nparseNumber = do\n    num <- many1 digit\n    return (NumberValue (read num))  The operations char , digit , etc. are pretty simple. They either match or don't match. The magic is the monad which manages the control flow: The operations are performed sequentially until a match fails, in which case the monad backtracks to the latest <|> and tries the next option. Again, a way of chaining operations with some additional, useful semantics.  Example 4: Asynchronous programming  The above examples are in Haskell, but it turns out F# also supports monads. This example is stolen from Don Syme :  let AsyncHttp(url:string) =\n    async {  let req = WebRequest.Create(url)\n             let! rsp = req.GetResponseAsync()\n             use stream = rsp.GetResponseStream()\n             use reader = new System.IO.StreamReader(stream)\n             return reader.ReadToEnd() }  This method fetches a web page. The punch line is the use of GetResponseAsync - it actually waits for the response on a separate thread, while the main thread returns from the function. The last three lines are executed on the spawned thread when the response have been received.  In most other languages you would have to explicitly create a separate function for the lines that handle the response. The async monad is able to \"split\" the block on its own and postpone the execution of the latter half. (The async {} syntax indicates that the control flow in the block is defined by the async monad.)  How they work  So how can a monad do all these fancy control-flow thing? What actually happens in a do-block (or a computation expression as they are called in F#), is that every operation (basically every line) is wrapped in a separate anonymous function. These functions are then combined using the bind operator (spelled >>= in Haskell). Since the bind operation combines functions, it can execute them as it sees fit: sequentially, multiple times, in reverse, discard some, execute some on a separate thread when it feels like it and so on.  As an example, this is the expanded version of the IO-code from example 2:  putStrLn \"What is your name?\"\n>>= (\\_ -> getLine)\n>>= (\\name -> putStrLn (\"Welcome, \" ++ name ++ \"!\"))  This is uglier, but it's also more obvious what is actually going on. The >>= operator is the magic ingredient: It takes a value (on the left side) and combines it with a function (on the right side), to produce a new value. This new value is then taken by the next >>= operator and again combined with a function to produce a new value. >>= can be viewed as a mini-evaluator.  Note that >>= is overloaded for different types, so every monad has its own implementation of >>= . (All the operations in the chain have to be of the type of the same monad though, otherwise the >>= operator won't work.)  The simplest possible implementation of >>= just takes the value on the left and applies it to the function on the right and returns the result, but as said before, what makes the whole pattern useful is when there is something extra going on in the monad's implementation of >>= .  There is some additional cleverness in how the values are passed from one operation to the next, but this requires a deeper explanation of the Haskell type system.  Summing up  In Haskell-terms a monad is a parameterized type which is an instance of the Monad type class, which defines >>= along with a few other operators. In layman's terms, a monad is just a type for which the >>= operation is defined.  In itself >>= is just a cumbersome way of chaining functions, but with the presence of the do-notation which hides the \"plumbing\", the monadic operations turns out to be a very nice and useful abstraction, useful many places in the language, and useful for creating your own mini-languages in the language.  Why are monads hard?  For many Haskell-learners, monads are an obstacle they hit like a brick wall. It's not that monads themselves are complex, but that the implementation relies on many other advanced Haskell features like parameterized types, type classes, and so on. The problem is that Haskell I/O is based on monads, and I/O is probably one of the first things you want to understand when learning a new language - after all, it's not much fun to create programs which don't produce any output. I have no immediate solution for this chicken-and-egg problem, except treating I/O like \"magic happens here\" until you have enough experience with other parts of language. Sorry.  Excellent blog on monads: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html ", "question_id": 44965}, "0.12691422528587282", 3]]], "gensim_similarity_tf_idf_code_result": null, "gensim_similarity_tf_idf_body_result": [[{"answer_votes": "2", "answer_comments": [" You seem to be the only one who finally addressed my main problem with understanding Monads. Nobody ever talks about HOW can the value be extracted. Is it implementation dependant? \u2013 Vinicius Seufitele  Aug 22 '12 at 16:39 ", " @ViniciusSeufitele, thanks for your comment. I'm afraid that my understanding hasn't advanced a great deal since I wrote this answer, so I can't really add much. The value extraction logically has to exist, so maybe that's why nobody bothers to mention it. \u2013 Benjol  Aug 23 '12 at 5:45 ", " I have a discussion that treats the monad as a type expansion where the original type, b, is converted to an expanded type M<b> and the associated operators are wrapped to now service M<b>. These wrappers are what will handle the peculiarities of the monad. In particular, extracting the original type from the expanded type and passing it to it's wrapped operator and subsequently promoting the result. The benefit of the monad is that you retain simple declarative expressions. In my treatment I discussed expanding the numeric types system to include a DivByZero value to obviate the need to check \u2013 George  Oct 13 '14 at 16:45 ", " @ViniciusSeufitele , yes it is implementation dependent. The person writing the function >>= has access to the internals of the monad. For example see Maybe Monad and look for instance Monad Maybe . You'll see that when the left hand side is Just x then we return k x . The pattern matching does the unwrap for you. Something analogous happens in every monad implementation. \u2013 Michael Welch  Feb 3 '15 at 16:59  "], "answer_body": " Princess 's explanation of F# Computation Expressions helped me, though I still can't say I've really understood.  EDIT : this series - explaining monads with javascript - is the one that 'tipped the balance' for me.   http://blog.jcoglan.com/2011/03/05/translation-from-haskell-to-javascript-of-selected-portions-of-the-best-introduction-to-monads-ive-ever-read/  http://blog.jcoglan.com/2011/03/06/monad-syntax-for-javascript/  http://blog.jcoglan.com/2011/03/11/promises-are-the-monad-of-asynchronous-programming/   I think that understanding monads is something that creeps up on you. In that sense, reading as many 'tutorials' as you can is a good idea, but often strange stuff (unfamiliar language or syntax) prevents your brain from concentrating on the essential.  Some things that I had difficulty understanding:   Rules-based explanations never worked for me, because most practical examples actually require more than just return/bind.  Also, calling them rules didn't help. It is more a case of \"there are these things that have something in common, let's call the things 'monads', and the bits in common 'rules'\".  Return ( a -> M<a> ) and Bind ( M<a> -> (a -> M<b>) -> M<b> ) are great, but what I could never understand is HOW Bind could extract the a from M<a> in order to pass it into a -> M<b> . I don't think I've ever read anywhere (maybe it's obvious to everyone else), that the reverse of Return ( M<a> -> a ) has to exist inside the monad, it just doesn't need to be exposed.  ", "question_id": 44965}, "0.09119644"], [{"answer_votes": "9", "answer_comments": [" The python examples made it easy to comprehend! Thanks for sharing. \u2013 Ryan Efendy  Mar 2 at 17:50 "], "answer_body": " I am still new to monads, but I thought I would share a link I found that felt really good to read (WITH PICTURES!!): http://www.matusiak.eu/numerodix/blog/2012/3/11/monads-for-the-layman/ (no affiliation)  Basically, the warm and fuzzy concept that I got from the article was the concept that monads are basically adapters that allow disparate functions to work in a composable fashion, i.e. be able to string up multiple functions and mix and match them without worrying about inconsistent return types and such. So the BIND function is in charge of keeping apples with apples and oranges with oranges when we're trying to make these adapters. And the LIFT function is in charge of taking \"lower level\" functions and \"upgrading\" them to work with BIND functions and be composable as well.  I hope I got it right, and more importantly, hope that the article has a valid view on monads. If nothing else, this article helped whet my appetite for learning more about monads. ", "question_id": 44965}, "0.07606585"], [{"answer_votes": "2", "answer_comments": [" Lenses, not Monads, are a way for functional programmers to use imperative code without actually admitting it. \u2013 OleTraveler  Oct 18 '12 at 19:31 "], "answer_body": " Explaining monads seems to be like explaining control-flow statements. Imagine that a non-programmer asks you to explain them?  You can give them an explanation involving the theory - Boolean Logic, register values, pointers, stacks, and frames. But that would be crazy.  You could explain them in terms of the syntax. Basically all control-flow statements in C have curly brackets, and you can distinguish the condition and the conditional code by where they are relative to the brackets. That may be even crazier.  Or you could also explain loops, if statements, routines, subroutines, and possibly co-routines.  Monads can replace a fairly large number of programming techniques. There's a specific syntax in languages that support them, and some theories about them.  They are also a way for functional programmers to use imperative code without actually admitting it, but that's not their only use. ", "question_id": 44965}, "0.07351889"], [{"answer_votes": "36", "answer_comments": [" Sequencing isn't the only reason to define a monad.  A monad is just any functor which has bind and return.  Bind and return give you sequencing.  But they give other things as well.  Also, note that your favorite imperative language is effectively a fancy IO monad with OO classes.  Making it easy to define monads means it's easy to use the interpreter pattern -- define a dsl as a monad and interpret it! \u2013 nomen  May 17 '14 at 16:40  ", " Here is an implementation: github.com/brianspinos777/Programming_cheat_sheets/blob/master/\u2026 \u2013 Brian Joseph Spinos  Dec 21 '17 at 21:20  "], "answer_body": " After much striving, I think I finally understand the monad. After rereading my own lengthy critique of the overwhelmingly top voted answer, I will offer this explanation.  There are three questions that need to be answered to understand monads:   Why do you need a monad?  What is a monad?  How is a monad implemented?   As I noted in my original comments, too many monad explanations get caught up in question number 3, without, and before really adequately covering question 2, or question 1.  Why do you need a monad?  Pure functional languages like Haskell are different from imperative languages like C, or Java in that, a pure functional program is not necessarily executed in a specific order, one step at a time. A Haskell program is more akin to a mathematical function, in which you may solve the \"equation\" in any number of potential orders. This confers a number of benefits, among which is that it eliminates the possibility of certain kinds of bugs, particularly those relating to things like \"state\".  However, there are certain problems that are not so straightforward to solve with this style of programming. Some things, like console programming, and file i/o, need things to happen in a particular order, or need to maintain state. One way to deal with this problem is to create a kind of object that represents the state of a computation, and a series of functions that take a state object as input, and return a new modified state object.  So let's create a hypothetical \"state\" value, that represents the state of a console screen. exactly how this value is constructed is not important, but let's say it's an array of byte length ascii characters that represents what is currently visible on the screen, and an array that represents the last line of input entered by the user, in pseudocode. We've defined some functions that take console state, modify it, and return a new console state.  consolestate MyConsole = new consolestate;  So to do console programming, but in a pure functional manner, you would need to nest a lot of function calls inside eachother.  consolestate FinalConsole = print(input(print(myconsole, \"Hello, what's your name?\")),\"hello, %inputbuffer%!\");  Programming in this way keeps the \"pure\" functional style, while forcing changes to the console to happen in a particular order. But, we'll probably want to do more than just a few operations at a time like in the above example. Nesting functions in that way will start to become ungainly. What we want, is code that does essentially the same thing as above, but is written a bit more like this:  consolestate FinalConsole = myconsole:\n                            print(\"Hello, what's your name?\"):\n                            input():\n                            print(\"hello, %inputbuffer%!\");  This would indeed be a more convenient way to write it. How do we do that though?  What is a monad?  Once you have a type (such as consolestate ) that you define along with a bunch of functions designed specifically to operate on that type, you can turn the whole package of these things into a \"monad\" by defining an operator like : (bind) that automatically feeds return values on its left, into function parameters on its right, and a lift operator that turns normal functions, into functions that work with that specific kind of bind operator.  How is a monad implemented?  See other answers, that seem quite free to jump into the details of that. ", "question_id": 44965}, "0.07027501"], [{"answer_votes": "0", "answer_comments": null, "answer_body": " If you are asking for a succinct, practical explanation for something so abstract, then you can only hope for an abstract answer:  a -> b  is one way of representing a computation from a s to b s. You can chain computations, aka compose them together:  (b -> c) -> (a -> b) -> (a -> c)  More complex computations demand more complex types, e.g.:  a -> f b  is the type of computations from a s to b s that are into f s. You can also compose them:  (b -> f c) -> (a -> f b) -> (a -> f c)  It turns out this pattern appears literally everywhere and has the same properties as the first composition above (associativity, right- and left-identity).  One had to give this pattern a name, but then would it help to know that the first composition is formally characterised as a Semigroupoid ?  \"Monads are just as interesting and important as parentheses\" (Oleg Kiselyov) ", "question_id": 44965}, "0.06916447"], [{"answer_votes": "4", "answer_comments": null, "answer_body": " If I've understood correctly, IEnumerable is derived from monads. I wonder if that might be an interesting angle of approach for those of us from the C# world?  For what it's worth, here are some links to tutorials that helped me (and no, I still haven't understood what monads are).   http://osteele.com/archives/2007/12/overloading-semicolon  http://spbhug.folding-maps.org/wiki/MonadsEn  http://www.loria.fr/~kow/monads/  ", "question_id": 44965}, "0.06521157"], [{"answer_votes": "9", "answer_comments": null, "answer_body": " I've been thinking of Monads in a different way, lately. I've been thinking of them as abstracting out execution order in a mathematical way, which makes new kinds of polymorphism possible.  If you're using an imperative language, and you write some expressions in order, the code ALWAYS runs exactly in that order.  And in the simple case, when you use a monad, it feels the same -- you define a list of expressions that happen in order. Except that, depending on which monad you use, your code might run in order (like in IO monad), in parallel over several items at once (like in the List monad), it might halt partway through (like in the Maybe monad), it might pause partway through to be resumed later (like in a Resumption monad), it might rewind and start from the beginning (like in a Transaction monad), or it might rewind partway to try other options (like in a Logic monad).  And because monads are polymorphic, it's possible to run the same code in different monads, depending on your needs.  Plus, in some cases, it's possible to combine monads together (with monad transformers) to get multiple features at the same time. ", "question_id": 44965}, "0.04956359"], [{"answer_votes": "162", "answer_comments": [" \u2026best way not only on the internet, but anywhere. (Wadler's original paper Monads for functional programming that I mentioned in my answer below is also good.) None of the zillions of tutorials-by-analogy come close. \u2013 ShreevatsaR  Apr 30 '11 at 15:14 ", " This JavaScript translation of Sigfpe's post is the new best way to learn monads, for people who don't already grok advanced Haskell! \u2013 Sam Watkins  Jan 6 '14 at 2:55  ", " This is how I learned what a monad is. Walking the reader through the process of inventing a concept is often the best way to teach the concept. \u2013 Jordan  Mar 8 '15 at 5:58 ", " However, a function accepting the screen object as argument and returning its copy with text modified would be pure. \u2013 Dmitri Zaitsev  May 20 '16 at 12:09 "], "answer_body": " But, You could have invented Monads!   sigfpe says:   But all of these introduce monads as something esoteric in need of explanation. But what I want to argue is that they aren't esoteric at all. In fact, faced with various problems in functional programming you would have been led, inexorably, to certain solutions, all of which are examples of monads. In fact, I hope to get you to invent them now if you haven't already. It's then a small step to notice that all of these solutions are in fact the same solution in disguise. And after reading this, you might be in a better position to understand other documents on monads because you'll recognise everything you see as something you've already invented.  Many of the problems that monads try to solve are related to the issue of side effects. So we'll start with them. (Note that monads let you do more than handle side-effects, in particular many types of container object can be viewed as monads. Some of the introductions to monads find it hard to reconcile these two different uses of monads and concentrate on just one or the other.)  In an imperative programming language such as C++, functions behave nothing like the functions of mathematics. For example, suppose we have a C++ function that takes a single floating point argument and returns a floating point result. Superficially it might seem a little like a mathematical function mapping reals to reals, but a C++ function can do more than just return a number that depends on its arguments. It can read and write the values of global variables as well as writing output to the screen and receiving input from the user. In a pure functional language, however, a function can only read what is supplied to it in its arguments and the only way it can have an effect on the world is through the values it returns.   ", "question_id": 44965}, "0.045820273"], [{"answer_votes": "2", "answer_comments": [" As I understand, monads are more than that. Encapsulating mutable state in a \"pure\" functional languages is only one application of monads. \u2013 thSoft  Dec 30 '10 at 2:17 "], "answer_body": " A monad is a thing used to encapsulate objects that have changing state. It is most often encountered in languages that otherwise do not allow you to have modifiable state (e.g., Haskell).  An example would be for file I/O.  You would be able to use a monad for file I/O to isolate the changing state nature to just the code that used the Monad. The code inside the Monad can effectively ignore the changing state of the world outside the Monad - this makes it a lot easier to reason about the overall effect of your program. ", "question_id": 44965}, "0.03467849"], [{"answer_votes": "5", "answer_comments": null, "answer_body": " Monoid appears to be something that ensures that all operations defined on a Monoid and a supported type will always return a supported type inside the Monoid. Eg, Any number + Any number = A number, no errors.  Whereas division accepts two fractionals, and returns a fractional, which defined division by zero as Infinity in haskell somewhy(which happens to be a fractional somewhy)...  In any case, it appears Monads are just a way to ensure that your chain of operations behaves in a predictable way, and a function that claims to be Num -> Num, composed with another function of Num->Num called with x does not say, fire the missiles.  On the other hand, if we have a function which does fire the missiles, we can compose it with other functions which also fire the missiles, because our intent is clear -- we want to fire the missiles -- but it won't try printing \"Hello World\" for some odd reason.  In Haskell, main is of type IO (), or IO [()], the distiction is strange and I will not discuss it but here's what I think happens:  If I have main, I want it to do a chain of actions, the reason I run the program is to produce an effect -- usually though IO. Thus I can chain IO operations together in main in order to -- do IO, nothing else.  If I try to do something which does not \"return IO\", the program will complain that the chain does not flow, or basically \"How does this relate to what we are trying to do -- an IO action\", it appears to force the programmer to keep their train of thought, without straying off and thinking about firing the missiles, while creating algorithms for sorting -- which does not flow.  Basically, Monads appear to be a tip to the compiler that \"hey, you know this function that returns a number here, it doesn't actually always work, it can sometimes produce a Number, and sometimes Nothing at all, just keep this in mind\". Knowing this, if you try to assert a monadic action, the monadic action may act as a compile time exception saying \"hey, this isn't actually a number, this CAN be a number, but you can't assume this, do something to ensure that the flow is acceptable.\" which prevents unpredictable program behavior -- to a fair extent.  It appears monads are not about purity, nor control, but about maintaining an identity of a category on which all behavior is predictable and defined, or does not compile. You cannot do nothing when you are expected to do something, and you cannot do something if you are expected to do nothing (visible).  The biggest reason I could think of for Monads is -- go look at Procedural/OOP code, and you will notice that you do not know where the program starts, nor ends, all you see is a lot of jumping and a lot of math,magic,and missiles. You will not be able to maintain it, and if you can, you will spend quite a lot of time wrapping your mind around the whole program before you can understand any part of it, because modularity in this context is based on interdependant \"sections\" of code, where code is optimized to be as related as possible for promise of efficiency/inter-relation. Monads are very concrete, and well defined by definition, and ensure that the flow of program is possible to analyze, and isolate parts which are hard to analyze -- as they themselves are monads. A monad appears to be a \"comprehensible unit which is predictable upon its full understanding\" -- If you understand \"Maybe\" monad, there's no possible way it will do anything except be \"Maybe\", which appears trivial, but in most non monadic code, a simple function \"helloworld\" can fire the missiles, do nothing, or destroy the universe or even distort time -- we have no idea nor have any guarantees that IT IS WHAT IT IS. A monad GUARANTEES that IT IS WHAT IT IS. which is very powerful.  All things in \"real world\" appear to be monads, in the sense that it is bound by definite observable laws preventing confusion. This does not mean we have to mimic all the operations of this object to create classes, instead we can simply say \"a square is a square\", nothing but a square, not even a rectangle nor a circle, and \"a square has area of the length of one of it's existing dimensions multiplied by itself. No matter what square you have, if it's a square in 2D space, it's area absolutely cannot be anything but its length squared, it's almost trivial to prove. This is very powerful because we do not need to make assertions to make sure that our world is the way it is, we just use implications of reality to prevent our programs from falling off track.  Im pretty much guaranteed to be wrong but I think this could help somebody out there, so hopefully it helps somebody. ", "question_id": 44965}, "0.031449236"], [{"answer_votes": "34", "answer_comments": [" The only problem with Wadler's paper is the notation is different but I agree that the paper is pretty compelling and a clear concise motivation for applying monads. \u2013 Jared Updike  Jul 31 '09 at 22:34 ", " +1 for the \"monad tutorial fallacy\". Tutorials on monads are akin to having several tutorials trying to explain the concept of integer numbers. One tutorial would say, \"1 is similar to an apple\"; another tutorial says, \"2 is like a pear\"; a third one says, \"3 is basically an orange\". But you never get the whole picture from any single tutorial. What I've taken from that is that monads are an abstract concept which can be used for many quite different purposes. \u2013 stakx  Jan 14 '11 at 7:30  ", " @stakx: Yes, true. But I didn't mean that monads are an abstraction that you cannot learn or shouldn't learn; only that it's best to learn it after you've seen enough concrete examples to perceive a single underlying abstraction. See my other answer here . \u2013 ShreevatsaR  Jan 14 '11 at 12:22 ", " Sometimes I feel that there are so many tutorials that try to convince the reader that monads are useful by using code that do complicated or useful stuff. That hindered my understanding for months. I don't learn that way. I prefer to see extremely simple code, doing something stupid that I can mentally go through and I couldn't find this kind of example. I can't learn if the first example is a monad to parse a complicate grammar. I can learn if it's a monad to sum integers. \u2013 Rafael S. Calsaverini  Jan 23 '11 at 23:11  ", " Mentioning only type constructor is incomplete: stackoverflow.com/a/37345315/1614973 \u2013 Dmitri Zaitsev  May 20 '16 at 12:18 "], "answer_body": " (See also the answers at What is a monad? )  A good motivation to Monads is sigfpe (Dan Piponi)'s You Could Have Invented Monads! (And Maybe You Already Have) . There are a LOT of other monad tutorials , many of which misguidedly try to explain monads in \"simple terms\" using various analogies: this is the monad tutorial fallacy ; avoid them.  As DR MacIver says in Tell us why your language sucks :   So, things I hate about Haskell:   Let\u2019s start with the obvious. Monad tutorials. No, not monads. Specifically the tutorials. They\u2019re endless, overblown and dear god are they tedious. Further, I\u2019ve never seen any convincing evidence that they actually help. Read the class definition, write some code, get over the scary name.  You say you understand the Maybe monad? Good, you're on your way. Just start using other monads and sooner or later you'll understand what monads are in general.  [If you are mathematically oriented, you might want to ignore the dozens of tutorials and learn the definition, or follow lectures in category theory :)\nThe main part of the definition is that a Monad M involves a \"type constructor\" that defines for each existing type \"T\" a new type \"M T\", and some ways for going back and forth between \"regular\" types and \"M\" types.]  Also, surprisingly enough, one of the best introductions to monads is actually one of the early academic papers introducing monads, Philip Wadler's Monads for functional programming . It actually has practical, non-trivial motivating examples, unlike many of the artificial tutorials out there. ", "question_id": 44965}, "0.03044972"], [{"answer_votes": "951", "answer_comments": [" As someone who has had a great deal of problems understanding monads, I can say that this answer helped.. a little. However, there's still some things that I don't understand. In what way is the list comprehension a monad? Is there an expanded form of that example? Another thing that really bothers me about most monad explanations, including this one- Is that they keep mixing up \"what is a monad?\" with \"what is a monad good for?\" and \"How is a monad implemented?\".  you jumped that shark when you wrote \"A monad is basically just a type that supports the >>= operator.\" Which just had me... \u2013 Breton  Aug 10 '09 at 2:00 ", " Also I disagree with your conclusion about why monads are hard. If monads themselves aren't complex, then you should be able to explain what they are without a bunch of baggage. I don't want to know about the implementation when I ask the question \"What is a monad\", I want to know what itch it's meant to be scratching. So far it seems like the answer is \"Because the authors of haskell are sadomasochists and decided that you should do something stupidly complex to accomplish simple things, so you HAVE to learn monads to use haskell, not because they're in any way useful in themselves\"... \u2013 Breton  Aug 10 '09 at 2:08 ", " But.. that can't be right, can it? I think monads are hard because nobody can seem to figure out how to explain them without getting caught up in confusing implementation details. I mean.. what is a school bus? It's a metal platform with a device in the front which consumes a refined petroleum product to drive in a cycle some metallic pistons, which in turn rotate a crank shaft attached to some gears which drive some wheels. The wheels have inflated rubber bags around them which interface with an ashphalt surface to cause a collection of seats to move forward. The seats move forward because... \u2013 Breton  Aug 10 '09 at 2:12 ", " I read all of this and still don't know what a monad is, aside from the fact that it's something Haskell programmers don't understand well enough to explain. The examples don't help much, given that these are all things one can do without monads, and this answer doesn't make it clear how monads make them any easier, only more confusing. The one part of this answer that came close to being useful was where the syntactic sugar of example #2 was removed. I say came close because, aside from the first line, the expansion doesn't bear any real resemblance to the original. \u2013 Laurence Gonsalves  Dec 19 '11 at 4:44 ", " Another problem that seems to be endemic to explanations of monads is that it's written in Haskell. I'm not saying Haskell is a bad language -- I'm saying it's a bad language for explaining monads. If I knew Haskell I'd already understand monads, so if you want to explain monads, start by using a language that people who don't know monads are more likely to understand. If you must use Haskell, don't use the syntactic sugar at all -- use the smallest, simplest subset of the language you can, and don't assume an understanding of Haskell IO. \u2013 Laurence Gonsalves  Dec 19 '11 at 4:50 "], "answer_body": " First: The term monad is a bit vacuous if you are not a mathematician. An alternative term is computation builder which is a bit more descriptive of what they are actually useful for.  You ask for practical examples:  Example 1: List comprehension :  [x*2 | x<-[1..10], odd x]  This expression returns the doubles of all odd numbers in the range from 1 to 10. Very useful!  It turns out this is really just syntactic sugar for some operations within the List monad. The same list comprehension can be written as:  do\n   x <- [1..10]\n   if odd x \n       then [x * 2] \n       else []  Or even:  [1..10] >>= (\\x -> if odd x then [x*2] else [])  Example 2: Input/Output :  do\n   putStrLn \"What is your name?\"\n   name <- getLine\n   putStrLn (\"Welcome, \" ++ name ++ \"!\")  Both examples use monads, AKA computation builders. The common theme is that the monad chains operations in some specific, useful way. In the list comprehension, the operations are chained such that if an operation returns a list, then the following operations are performed on every item in the list. The IO monad on the other hand performs the operations sequentially, but passes a \"hidden variable\" along, which represents \"the state of the world\", which allows us to write I/O code in a pure functional manner.  It turns out the pattern of chaining operations is quite useful and is used for lots of different things in Haskell.  Another example is exceptions: Using the Error monad, operations are chained such that they are performed sequentially, except if an error is thrown, in which case the rest of the chain is abandoned.  Both the list-comprehension syntax and the do-notation are syntactic sugar for chaining operations using the >>= operator. A monad is basically just a type that supports the >>= operator.  Example 3: A parser  This is a very simple parser which parses either a quoted string or a number:  parseExpr = parseString <|> parseNumber\n\nparseString = do\n        char '\"'\n        x <- many (noneOf \"\\\"\")\n        char '\"'\n        return (StringValue x)\n\nparseNumber = do\n    num <- many1 digit\n    return (NumberValue (read num))  The operations char , digit , etc. are pretty simple. They either match or don't match. The magic is the monad which manages the control flow: The operations are performed sequentially until a match fails, in which case the monad backtracks to the latest <|> and tries the next option. Again, a way of chaining operations with some additional, useful semantics.  Example 4: Asynchronous programming  The above examples are in Haskell, but it turns out F# also supports monads. This example is stolen from Don Syme :  let AsyncHttp(url:string) =\n    async {  let req = WebRequest.Create(url)\n             let! rsp = req.GetResponseAsync()\n             use stream = rsp.GetResponseStream()\n             use reader = new System.IO.StreamReader(stream)\n             return reader.ReadToEnd() }  This method fetches a web page. The punch line is the use of GetResponseAsync - it actually waits for the response on a separate thread, while the main thread returns from the function. The last three lines are executed on the spawned thread when the response have been received.  In most other languages you would have to explicitly create a separate function for the lines that handle the response. The async monad is able to \"split\" the block on its own and postpone the execution of the latter half. (The async {} syntax indicates that the control flow in the block is defined by the async monad.)  How they work  So how can a monad do all these fancy control-flow thing? What actually happens in a do-block (or a computation expression as they are called in F#), is that every operation (basically every line) is wrapped in a separate anonymous function. These functions are then combined using the bind operator (spelled >>= in Haskell). Since the bind operation combines functions, it can execute them as it sees fit: sequentially, multiple times, in reverse, discard some, execute some on a separate thread when it feels like it and so on.  As an example, this is the expanded version of the IO-code from example 2:  putStrLn \"What is your name?\"\n>>= (\\_ -> getLine)\n>>= (\\name -> putStrLn (\"Welcome, \" ++ name ++ \"!\"))  This is uglier, but it's also more obvious what is actually going on. The >>= operator is the magic ingredient: It takes a value (on the left side) and combines it with a function (on the right side), to produce a new value. This new value is then taken by the next >>= operator and again combined with a function to produce a new value. >>= can be viewed as a mini-evaluator.  Note that >>= is overloaded for different types, so every monad has its own implementation of >>= . (All the operations in the chain have to be of the type of the same monad though, otherwise the >>= operator won't work.)  The simplest possible implementation of >>= just takes the value on the left and applies it to the function on the right and returns the result, but as said before, what makes the whole pattern useful is when there is something extra going on in the monad's implementation of >>= .  There is some additional cleverness in how the values are passed from one operation to the next, but this requires a deeper explanation of the Haskell type system.  Summing up  In Haskell-terms a monad is a parameterized type which is an instance of the Monad type class, which defines >>= along with a few other operators. In layman's terms, a monad is just a type for which the >>= operation is defined.  In itself >>= is just a cumbersome way of chaining functions, but with the presence of the do-notation which hides the \"plumbing\", the monadic operations turns out to be a very nice and useful abstraction, useful many places in the language, and useful for creating your own mini-languages in the language.  Why are monads hard?  For many Haskell-learners, monads are an obstacle they hit like a brick wall. It's not that monads themselves are complex, but that the implementation relies on many other advanced Haskell features like parameterized types, type classes, and so on. The problem is that Haskell I/O is based on monads, and I/O is probably one of the first things you want to understand when learning a new language - after all, it's not much fun to create programs which don't produce any output. I have no immediate solution for this chicken-and-egg problem, except treating I/O like \"magic happens here\" until you have enough experience with other parts of language. Sorry.  Excellent blog on monads: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html ", "question_id": 44965}, "0.03044089"], [{"answer_votes": "625", "answer_comments": [" I appreciate your answer\u2014especially the final concession that all of this is of course possible too without monads. One point to be made is that it's mostly easier with monads, but it's often not as efficient as doing it without them. Once you need to involve transformers, the extra layering of function calls (and function objects created) has a cost that's hard to see and control, rendered invisible by clever syntax. \u2013 seh  Apr 20 '12 at 16:35 ", " In Haskell at least, most of the overhead of monads gets stripped away by the optimiser. So the only real \"cost\" is in brain power required. (This is not insignificant if \"maintainability\" is something you care about.) But usually, monads make things easier , not harder. (Otherwise, why would you bother?) \u2013 MathematicalOrchid  Apr 21 '12 at 18:40 ", " I'm not sure whether or not Haskell supports this but mathematically you can define a monad either in terms of >>= and return or join and ap. >>= and return are what make monads practically useful but join and ap give a more intuitive understanding of what a monad is. \u2013 Jeremy List  Apr 2 '14 at 10:57 ", " Coming from a non-math, non-functional programming background, this answer made the most sense to me. \u2013 jrahhali  Aug 2 '17 at 23:55 ", " This is the first answer that actually gave me some idea of what the hell a monad is. Thank you for finding a way to explain it! \u2013 robotmay  Aug 14 '17 at 23:48 "], "answer_body": " Explaining \"what is a monad\" is a bit like saying \"what is a number?\" We use numbers all the time. But imagine you met someone who didn't know anything about numbers. How the heck would you explain what numbers are? And how would you even begin to describe why that might be useful?  What is a monad? The short answer: It's a specific way of chaining operations together.  In essence, you're writing execution steps and linking them together with the \"bind function\". (In Haskell, it's named >>= .) You can write the calls to the bind operator yourself, or you can use syntax sugar which makes the compiler insert those function calls for you. But either way, each step is separated by a call to this bind function.  So the bind function is like a semicolon; it separates the steps in a process. The bind function's job is to take the output from the previous step, and feed it into the next step.  That doesn't sound too hard, right? But there is more than one kind of monad. Why? How?  Well, the bind function can just take the result from one step, and feed it to the next step. But if that's \"all\" the monad does... that actually isn't very useful. And that's important to understand: Every useful monad does something else in addition to just being a monad. Every useful monad has a \"special power\", which makes it unique.  (A monad that does nothing special is called the \"identity monad\". Rather like the identity function, this sounds like an utterly pointless thing, yet turns out not to be... But that's another story\u2122.)  Basically, each monad has its own implementation of the bind function. And you can write a bind function such that it does hoopy things between execution steps. For example:   If each step returns a success/failure indicator, you can have bind execute the next step only if the previous one succeeded. In this way, a failing step aborts the whole sequence \"automatically\", without any conditional testing from you. (The Failure Monad .)  Extending this idea, you can implement \"exceptions\". (The Error Monad or Exception Monad .) Because you're defining them yourself rather than it being a language feature, you can define how they work. (E.g., maybe you want to ignore the first two exceptions and only abort when a third exception is thrown.)  You can make each step return multiple results , and have the bind function loop over them, feeding each one into the next step for you. In this way, you don't have to keep writing loops all over the place when dealing with multiple results. The bind function \"automatically\" does all that for you. (The List Monad .)  As well as passing a \"result\" from one step to another, you can have the bind function pass extra data around as well. This data now doesn't show up in your source code, but you can still access it from anywhere, without having to manually pass it to every function. (The Reader Monad .)  You can make it so that the \"extra data\" can be replaced. This allows you to simulate destructive updates , without actually doing destructive updates. (The State Monad and its cousin the Writer Monad .)  Because you're only simulating destructive updates, you can trivially do things that would be impossible with real destructive updates. For example, you can undo the last update , or revert to an older version .  You can make a monad where calculations can be paused , so you can pause your program, go in and tinker with internal state data, and then resume it.  You can implement \"continuations\" as a monad. This allows you to break people's minds!   All of this and more is possible with monads. Of course, all of this is also perfectly possible without monads too. It's just drastically easier using monads. ", "question_id": 44965}, "0.029975828"], [{"answer_votes": "2", "answer_comments": null, "answer_body": " Another attempt at explaining monads, using just Python lists and the map function. I fully accept this isn't a full explanation, but I hope it gets at the core concepts.  I got the basis of this from the funfunfunction video on Monads and the Learn You A Haskell chapter 'For a Few Monads More' . I highly recommend watching the funfunfunction video.  At it's very simplest, Monads are objects that have a map and flatMap functions ( bind in Haskell). There are some extra required properties , but these are the core ones.  flatMap 'flattens' the output of map, for lists this just concatenates the values of the list e.g.  concat([[1], [4], [9]]) = [1, 4, 9]  So in Python we can very basically implement a Monad with just these two functions:  def flatMap(func, lst):\n    return concat(map(func, lst))\n\ndef concat(lst):\n    return sum(lst, [])  func is any function that takes a value and returns a list e.g.  lambda x: [x*x]  Explanation  For clarity I created the concat function in Python via a simple function , which sums the lists i.e. [] + [1] + [4] + [9] = [1, 4, 9] (Haskell has a native concat method).  I'm assuming you know what the map function is e.g.:  >>> list(map(lambda x: [x*x], [1,2,3]))\n[[1], [4], [9]]  Flattening is the key concept of Monads and for each object which is a Monad this flattening allows you to get at the value that is wrapped in the Monad.  Now we can call:  >>> flatMap(lambda x: [x*x], [1,2,3])\n[1, 4, 9]  This lambda is taking a value x and putting it into a list. A monad works with any function that goes from a value to a type of the monad, so a list in this case.  That's your monad defined .  I think the question of why they're useful has been answered in other questions.  More explanation  Other examples that aren't lists are JavaScript Promises, which have the then method and JavaScript Streams which have a flatMap method.  So Promises and Streams use a slightly different function which flattens out a Stream or a Promise and returns the value from within.  The Haskell list monad has the following definition:  instance Monad [] where  \n    return x = [x]  \n    xs >>= f = concat (map f xs)  \n    fail _ = []  i.e. there are three functions return (not to be confused with return in most other languages), >>= (the flatMap ) and fail .  Hopefully you can see the similarity between:  xs >>= f = concat (map f xs)  and:  def flatMap(f, xs):\n    return concat(map(f, xs)) ", "question_id": 44965}, "0.02847273"], [{"answer_votes": "2", "answer_comments": [" here is an implementation: github.com/brianspinos777/Programming_cheat_sheets/blob/master/\u2026 \u2013 Brian Joseph Spinos  Dec 21 '17 at 21:23 ", " IOW, Monad is generalized function call protocol. \u2013 Will Ness  Jan 28 at 16:09 ", " You answer is the most helpful in my opinion. Although I have to say that I think the emphasis needs to be on the fact that the functions you're refering to don't just involve values in contexts, they actively put values in contexts.  So for example, a function, f :: m a -> m b would very easily compose with another function, g :: m b -> m c.  But monads (bind specifically) allows us to perpetually compose functions which put their input in the same context, without us needing to take the value out of that context first (which would effectively remove information from the value) \u2013 James  Mar 23 at 18:41  ", " @James I think that should be the emphasis for functors? \u2013 Jonas  Mar 24 at 5:03 ", " @Jonas I guess I didn't explain propperly.   When I say that the functions put values in contexts, I mean that they have type (a -> m b). These are very useful since putting a value into a context adds new information to it but it would usually be difficult to chain a (a -> m b) and a (b -> m c) together since we can't just take the value out of the context. So we would have to use some convoluted process to chain these functions together in a sensible way depending on the specific context and monads just allow us to do this in a consistent way, regardless of the context. \u2013 James  Mar 24 at 16:23 "], "answer_body": " I will try to explain Monad in the context of Haskell.  In functional programming, function composition is important. It allows our program to consist of small, easy-to-read functions.  Let's say we have two functions: g :: Int -> String and f :: String -> Bool .  We can do (f . g) x , which is just the same as f (g x) , where x is an Int value.  When doing composition/applying the result of one function to another, having the types match up is important. In the above case, the type of the result returned by g must be the same as the type accepted by f .  But sometimes values are in contexts, and this makes it a bit less easy to line up types. (Having values in contexts is very useful. For example, the Maybe Int type represents an Int value that may not be there, the IO String type represents a String value that is there as a result of performing some side effects.)  Let's say we now have g1 :: Int -> Maybe String and f1 :: String -> Maybe Bool . g1 and f1 are very similar to g and f respectively.  We can't do (f1 . g1) x or f1 (g1 x) , where x is an Int value. The type of the result returned by g1 is not what f1 expects.  We could compose f and g with the . operator, but now we can't compose f1 and g1 with . . The problem is that we can't straightforwardly pass a value in a context to a function that expects a value that is not in a context.  Wouldn't it be nice if we introduce an operator to compose g1 and f1 , such that we can write (f1 OPERATOR g1) x ? g1 returns a value in a context. The value will be taken out of context and applied to f1 . And yes, we have such an operator. It's <=< .  We also have the >>= operator that does for us the exact same thing, though in a slightly different syntax.  We write: g1 x >>= f1 . g1 x is a Maybe Int value. The >>= operator helps take that Int value out of the \"perhaps-not-there\" context, and apply it to f1 . The result of f1 , which is a Maybe Bool , will be the result of the entire >>= operation.  And finally, why is Monad useful? Because Monad is the type class that defines the >>= operator, very much the same as the Eq type class that defines the == and /= operators.  To conclude, the Monad type class defines the >>= operator that allows us to pass values in a context (we call these monadic values) to functions that don't expect values in a context. The context will be taken care of.  If there is one thing to remember here, it is that Monad s allow function composition that involves values in contexts . ", "question_id": 44965}, "0.028198201"], [{"answer_votes": "2", "answer_comments": null, "answer_body": " A very simple answer is:  Monads are an abstraction that provide an interface for encapsulating values, for computing new encapsulated values, and for unwrapping the encapsulated value.  What's convenient about them in practice is that they provide a uniform interface for creating data types that model state while not being stateful .  It's important to understand that a Monad is an abstraction , that is, an abstract interface for dealing with a certain kind of data structure. That interface is then used to build data types that have monadic behavior.  You can find a very good and practical introduction in Monads in Ruby, Part 1: Introduction . ", "question_id": 44965}, "0.027444389"], [{"answer_votes": "69", "answer_comments": [" slight addition to def of 'higher order function': they can take OR RETURN functions. That's why they are 'higher' 'cos they do things with themselves. \u2013 Kevin Won  Jan 30 '10 at 6:31  ", " By that definition, addition is a higher-order function. It takes a number and returns a function that adds that number to another. So no, higher order functions are strictly functions whose domain consists of functions. \u2013 Apocalisp  Jan 30 '10 at 16:58  ", " The video ' Brian Beckman: Don't fear the Monad ' follows this same line of logic. \u2013 icc97  Oct 10 '16 at 5:29 "], "answer_body": " You should first understand what a functor is. Before that, understand higher-order functions.  A higher-order function is simply a function that takes a function as an argument.  A functor is any type construction T for which there exists a higher-order function, call it map , that transforms a function of type a -> b (given any two types a and b ) into a function T a -> T b . This map function must also obey the laws of identity and composition such that the following expressions return true for all x , p , and q (Haskell notation):  map id = id\nmap (p . q) = map p . map q  For example, a type constructor called List is a functor if it comes equipped with a function of type (a -> b) -> List a -> List b which obeys the laws above. The only practical implementation is obvious. The resulting List a -> List b function iterates over the given list, calling the (a -> b) function for each element, and returns the list of the results.  A monad is essentially just a functor T with two extra methods, join , of type T (T a) -> T a , and unit (sometimes called return , fork , or pure ) of type a -> T a . For lists in Haskell:  join :: [[a]] -> [a]\npure :: a -> [a]  Why is that useful? Because you could, for example, map over a list with a function that returns a list. Join takes the resulting list of lists and concatenates them. List is a monad because this is possible.  You can write a function that does map , then join . This function is called bind , or flatMap , or (>>=) , or (=<<) . This is normally how a monad instance is given in Haskell.  A monad has to satisfy certain laws, namely that join must be associative. This means that if you have a value x of type [[[a]]] then join (join x) should equal join (map join x) . And pure must be an identity for join such that join (pure x) == x . ", "question_id": 44965}, "0.026258394"], [{"answer_votes": "28", "answer_comments": [" \"...but I hope others find it useful\" it was indeed useful for me, despite of all the emphasized sentences :D \u2013 ftor  Oct 19 '16 at 17:50 ", " This is the most concise and clear explanation of monads I've ever read/watched/heard.  Thank you! \u2013 James  Nov 7 '16 at 2:04 ", " There is important difference between Monad and Monoid. Monad is a rule to \"compose\" functions between different types, so they do not form a binary operation as required for Monoids, see here for more details: stackoverflow.com/questions/2704652/\u2026 \u2013 Dmitri Zaitsev  Nov 18 '16 at 16:51 ", " Yes. You are correct. Your article was over my head :). However, I found this treatment very helpful (and added it to mine as a direction to others). Thanks your the heads up: stackoverflow.com/a/7829607/1612190 \u2013 George  Nov 21 '16 at 7:44 ", " You might have confused Algebraic group theory with Category theory where Monad is coming from. The former is the theory of algebraic groups, which is unrelated. \u2013 Dmitri Zaitsev  Mar 1 '17 at 12:19 "], "answer_body": " I wrote this mostly for me but I hope others find it useful :)  In Summary  A monad is merely custom function composition utilizing a wrapping type to hold stateful/meta information that guides the composition. Interestingly, imperative execution is itself function composition wherein the wrapping type holds whether an exception has occurred, the presence of which aborts further composition. The monadic laws serve to ensure a monad only performs the equivalent of function composition over the wrapped value.  A Little Context  Imperative code is a sequence of instructions performed consecutively while functional code is actually an expression whose order of evaluation is ultimately on an as needed basis. Consequently, an imperative program evaluates each statement fully before proceeding to the next one while a functional program catalogs any preceding subexpression then evaluates the last one to generate a result, at which point any necessary preceding subexpressions are evaluated. (Most functional languages do resolve subexpressions into values as they are encountered with a few, notably Haskell, being the exception).  What Does That Have To Do With Monads  It turns out that imperative evaluation and \"expression\" evaluation are equivalent. Namely, the performance of an evaluation of an expression at any specific time can be described as the sequential evaluation of its subexpressions. Similarly, any sequential execution of statements can be considered an instance of such an expression being evaluated especially if you generalize the notion of return value to be any modification to the application state as oppose to merely formal return values. To the point, all imperative code can be considered a specific ordered evaluation of some equivalent expression (over the application state).  Still, What Does All That Have To Do With Monads  An expression is a composition of functions and a monad is a technique for customizing the composition of functions. Per convention, it is a function called, bind , that composes (binds) two functions ( bind f g = (x) => g(f x) ) within some umbrella type that holds a context or state guiding the binding process. This context allows the associated implementation of bind to massage the composition. In the case of, Result 'a , context that hold an error message or a actual value it would permit the bind to log errors of the preceding result and aborts or continue the composition with a default value, depending on design. Selective application of the subsequent function to be composed is the key facility of monads in that the application process is not blind, unlike silly imperative code. :)  In a monad, the functions to be composed are defined to receive a non-monadic or unwrapped value but return a monadic or wrapped value. An example of one such naturally occurring function is the division operator ( / ) which accepts numbers but may return undefined if the divisor is 0 . Since undefined is not a number, \\ , actually returns a type whose value range is large than a number since it includes all numbers plus undefined .  I suspect this asymmetry, where operators require valid values but may return invalid ones, is a key pragmatic aspect of monads that make them useful but difficult to explain and justify; while imperative coders accept constant result checking as a necessary evil, functional coders use bind over a suitable wrapper type to detect and manage exceptions or invalid results  While being a composition function, nonetheless, for pragmatic reasons bind is described as receiving the result of the first function, a wrapped value, that it then selectively applies to the second function whose result it then collects and returns as its result. Consequently, binds can themselves be composed.  For a complex example, a monad can take a sequence of asynchronous results as a preceding value and apply each to the provided composing function in parallel with respect to the available processors, then collect and return their results as they occur, for instance. All this functionality is in that specific implementation of that monad's bind function; however, there are typically ancillary functions that cooperate, in particular lift with wraps a value into a default instance of the monadic type such as, lift 1 = Just 1 in the case of the Maybe monad, for participation in monadic expressions. (In Haskell, a monad is strongly associated with the wrapper type because monads are implemented using its type class mechanisms whereas in F# the implementation uses defined computations expression instances)  Are you saying that...  ...a monad is just custom function composition using a wrapping type to hold stateful information that the bind or composing function or operator uses in determining whether and how to perform the application of the next function. Yep.  What About The Monadic Laws?  The monadic laws only seek to ensure that a monad implementation only performs the equivalent of function composition over the wrapped type. It does that by ensuring certain equivalences hold per the expectation of composing those two functions over the wrapped type.  That's it I think. Hope it helps some.  I believe this is nice a nice treatment in another StackOverflow of response . ", "question_id": 44965}, "0.024784576"], [{"answer_votes": "5", "answer_comments": null, "answer_body": " The two things that helped me best when learning about there were:  Chapter 8, \"Functional Parsers,\" from Graham Hutton's book Programming in Haskell . This doesn't mention monads at all, actually, but if you can work through chapter and really understand everything in it, particularly how a sequence of bind operations is evaluated, you'll understand the internals of monads. Expect this to take several tries.  The tutorial All About Monads . This gives several good examples of their use, and I have to say that the analogy in Appendex I worked for me. ", "question_id": 44965}, "0.024029737"], [{"answer_votes": "43", "answer_comments": [" Sometimes an explanation from a \"learner\" (like you) is more relevant to another learner than an explanation coming from an expert. Learners think alike :) \u2013 Adrian  Dec 7 '10 at 18:48 ", " What makes something a monad is the existence of a function with type M (M a) -> M a . The fact that you can turn that into one of type M a -> (a -> M b) -> M b is what makes them useful. \u2013 Jeremy List  Aug 19 '14 at 5:58 ", " \"monad\" roughly means \"pattern\" ... no. \u2013 user633183  May 19 '16 at 5:55 "], "answer_body": " [Disclaimer: I am still trying to fully grok monads. The following is just what I have understood so far. If it\u2019s wrong, hopefully someone knowledgeable will call me on the carpet.]  Arnar wrote:   Monads are simply a way to wrapping things and provide methods to do operations on the wrapped stuff without unwrapping it.   That\u2019s precisely it. The idea goes like this:   You take some kind of value and wrap it with some additional information. Just like the value is of a certain kind (eg. an integer or a string), so the additional information is of a certain kind.  E.g., that extra information might be a Maybe or an IO .  Then you have some operators that allow you to operate on the wrapped data while carrying along that additional information. These operators use the additional information to decide how to change the behaviour of the operation on the wrapped value.  E.g., a Maybe Int can be a Just Int or Nothing . Now, if you add a Maybe Int to a Maybe Int , the operator will check to see if they are both Just Int s inside, and if so, will unwrap the Int s, pass them the addition operator, re-wrap the resulting Int into a new Just Int (which is a valid Maybe Int ), and thus return a Maybe Int . But if one of them was a Nothing inside, this operator will just immediately return Nothing , which again is a valid Maybe Int . That way, you can pretend that your Maybe Int s are just normal numbers and perform regular math on them. If you were to get a Nothing , your equations will still produce the right result \u2013 without you having to litter checks for Nothing everywhere .   But the example is just what happens for Maybe . If the extra information was an IO , then that special operator defined for IO s would be called instead, and it could do something totally different before performing the addition. (OK, adding two IO Int s together is probably nonsensical \u2013 I\u2019m not sure yet.) (Also, if you paid attention to the Maybe example, you have noticed that \u201cwrapping a value with extra stuff\u201d is not always correct. But it\u2019s hard to be exact, correct and precise without being inscrutable.)  Basically, \u201cmonad\u201d roughly means \u201cpattern\u201d . But instead of a book full of informally explained and specifically named Patterns, you now have a language construct \u2013 syntax and all \u2013 that allows you to declare new patterns as things in your program . (The imprecision here is all the patterns have to follow a particular form, so a monad is not quite as generic as a pattern. But I think that\u2019s the closest term that most people know and understand.)  And that is why people find monads so confusing: because they are such a generic concept. To ask what makes something a monad is similarly vague as to ask what makes something a pattern.  But think of the implications of having syntactic support in the language for the idea of a pattern: instead of having to read the Gang of Four book and memorise the construction of a particular pattern, you just write code that implements this pattern in an agnostic, generic way once and then you are done! You can then reuse this pattern, like Visitor or Strategy or Fa\u00e7ade or whatever, just by decorating the operations in your code with it, without having to re-implement it over and over!  So that is why people who understand monads find them so useful : it\u2019s not some ivory tower concept that intellectual snobs pride themselves on understanding (OK, that too of course, teehee), but actually makes code simpler. ", "question_id": 44965}, "0.023240058"], [{"answer_votes": "24", "answer_comments": null, "answer_body": " Monads are to control flow what abstract data types are to data.  In other words, many developers are comfortable with the idea of Sets, Lists, Dictionaries (or Hashes, or Maps), and Trees. Within those data types there are many special cases (for instance InsertionOrderPreservingIdentityHashMap).  However, when confronted with program \"flow\" many developers haven't been exposed to many more constructs than if, switch/case, do, while, goto (grr), and (maybe) closures.  So, a monad is simply a control flow construct. A better phrase to replace monad would be 'control type'.  As such, a monad has slots for control logic, or statements, or functions - the equivalent in data structures would be to say that some data structures allow you to add data, and remove it.  For example, the \"if\" monad:  if( clause ) then block  at its simplest has two slots - a clause, and a block. The if monad is usually built to evaluate the result of the clause, and if not false, evaluate the block. Many developers are not introduced to monads when they learn 'if', and it just isn't necessary to understand monads to write effective logic.  Monads can become more complicated, in the same way that data structures can become more complicated, but there are many broad categories of monad that may have similar semantics, but differing implementations and syntax.  Of course, in the same way that data structures may be iterated over, or traversed, monads may be evaluated.  Compilers may or may not have support for user-defined monads. Haskell certainly does. Ioke has some similar capabilities, although the term monad is not used in the language. ", "question_id": 44965}, "0.022640564"], [{"answer_votes": "30", "answer_comments": [" Monads weren't 'designed', they were applied from one domain (category theory) to another (I/O in purely functional programming languages). Did Newton 'design' the calculus? \u2013 Jared Updike  Jul 31 '09 at 22:40 ", " Point 1 and 2 above are correct and useful. Points 4 and 5 are sort of ad hominem, even if more or less true. They don't really help explain monads. \u2013 Jared Updike  Jul 31 '09 at 22:42 ", " Re: 4, 5: The \"Secret handshake\" thing is a red herring. Programming is full of jargon. Haskell just happens to call stuff what it is without pretending to rediscover something. If it exists in mathematics already, why make up a new name for it? The name is really not the reason people don't get monads; they are a subtle concept. The average person probably understands addition and multiplication, why don't they get the concept of an Abelian Group? Because it is more abstract and general and that person hasn't done the work to wrap their head around the concept. A name change wouldn't help. \u2013 Jared Updike  Jul 31 '09 at 22:53 ", " Sigh... I'm not making an attack on Haskell ... I was making a joke.  So, I don't really get the bit about being \"ad hominem\".  Yes, the calculus was \"designed\". That's why, for example, calculus students are taught the Leibniz notation, rather than the icky stuff Netwton used. Better design.  Good names help understanding a lot. If I called Abelian Groups \"distended wrinkle pods\", you may have trouble understanding me.  You might be saying \"but that name is nonsense\", no one would ever call them that.  To people who have never heard of category theory \"monad\" sounds like nonsense. \u2013 Scott Wisniewski  Aug 1 '09 at 1:21 ", " @Scott: sorry if my extensive comments made it seem I was getting defensive about Haskell. I enjoy your humor about the secret handshake and you will note I said it is more or less true. :-) If you called Abelian Groups \"distended wrinkle pods\" you would be making the same mistake of trying to give monads a \"better name\" (cf. F# \"computation expressions\"): the term exists and people who care know what monads are, but not what \"warm fuzzy things\" are (or \"computation expressions\"). If I understand your use of the term \"type operator\" correctly there are lots of other type operators than monads. \u2013 Jared Updike  Aug 3 '09 at 23:27 "], "answer_body": " A monad is, effectively, a form of \"type operator\". It will do three things. First it will \"wrap\" (or otherwise convert) a value of one type into another type (typically called a \"monadic type\"). Secondly it will make all the operations (or functions) available on the underlying type available on the monadic type. Finally it will provide support for combining its self with another monad to produce a composite monad.  The \"maybe monad\" is essentially the equivalent of \"nullable types\" in Visual Basic / C#. It takes a non nullable type \"T\" and converts it into a \"Nullable<T>\", and then defines what all the binary operators mean on a Nullable<T>.  Side effects are represented simillarly. A structure is created that holds descriptions of side effects alongside a function's return value. The \"lifted\" operations then copy around side effects as values are passed between functions.  They are called \"monads\" rather than the easier-to-grasp name of \"type operators\" for several reasons:   Monads have restrictions on what they can do (see the definiton for details).  Those restrictions, along with the fact that there are three operations involved, conform to the structure of something called a monad in Category Theory, which is an obscure branch of mathematics.  They were designed by proponents of \"pure\" functional languages  Proponents of pure functional languages like obscure branches of mathematics  Because the math is obscure, and monads are associated with particular styles of programming, people tend to use the word monad as a sort of secret handshake. Because of this no one has bothered to invest in a better name.  ", "question_id": 44965}, "0.02182664"], [{"answer_votes": "0", "answer_comments": null, "answer_body": " Let the below \" {| a |m} \" represent some piece of monadic data. A data type which advertises an a :  (I got an a!)\n          /        \n    {| a |m}  Function, f , knows how to create a monad, if only it had an a :  (Hi f! What should I be?)\n                      /\n(You?. Oh, you'll be /\n that data there.)  /\n /                 /  (I got a b.)\n|    --------------      |\n|  /                     |\nf a                      |\n  |--later->       {| b |m}  Here we see function, f , tries to evaluate a monad but gets rebuked.  (Hmm, how do I get that a?)\n o       (Get lost buddy.\no         Wrong type.)\no       /\nf {| a |m}  Funtion, f , finds a way to extract the a by using >>= .  (Muaahaha. How you \n         like me now!?)       \n    (Better.)      \\\n        |     (Give me that a.)\n(Fine, well ok.)    |\n         \\          |\n   {| a |m}   >>=   f  Little does f know, the monad and >>= are in collusion.  (Yah got an a for me?)       \n(Yeah, but hey    | \n listen. I got    |\n something to     |\n tell you first   |\n ...)   \\        /\n         |      /\n   {| a |m}   >>=   f  But what do they actually talk about? Well, that depends on the monad. Talking solely in the abstract has limited use; you have to have some experience with particular monads to flesh out the understanding.  For instance, the data type Maybe  data Maybe a = Nothing | Just a  has a monad instance which will acts like the following...  Wherein, if the case is Just a  (Yah what is it?)       \n(... hm? Oh,      |\nforget about it.  |\nHey a, yr up.)    | \n            \\     |\n(Evaluation  \\    |\ntime already? \\   |\nHows my hair?) |  |\n      |       /   |\n      |  (It's    |\n      |  fine.)  /\n      |   /     /    \n   {| a |m}   >>=   f  But for the case of Nothing  (Yah what is it?)       \n(... There      |\nis no a. )      |\n  |        (No a?)\n(No a.)         |\n  |        (Ok, I'll deal\n  |         with this.)\n   \\            |\n    \\      (Hey f, get lost.) \n     \\          |   ( Where's my a? \n      \\         |     I evaluate a)\n       \\    (Not any more  |\n        \\    you don't.    |\n         |   We're returning\n         |   Nothing.)   /\n         |      |       /\n         |      |      /\n         |      |     /\n   {| a |m}   >>=   f      (I got a b.)\n                    |  (This is   \\\n                    |   such a     \\\n                    |   sham.) o o  \\\n                    |               o|\n                    |--later-> {| b |m}  So the Maybe monad lets a computation continue if it actually contains the a it advertises, but aborts the computation if it doesn't. The result, however is still a piece of monadic data, though not the output of f . For this reason, the Maybe monad is used to represent the context of failure.  Different monads behave differently. Lists are other types of data with monadic instances. They behave like the following:  (Ok, here's your a. Well, its\n a bunch of them, actually.)\n  |\n  |    (Thanks, no problem. Ok\n  |     f, here you go, an a.)\n  |       |\n  |       |        (Thank's. See\n  |       |         you later.)\n  |  (Whoa. Hold up f,      |\n  |   I got another         |\n  |   a for you.)           |\n  |       |      (What? No, sorry.\n  |       |       Can't do it. I \n  |       |       have my hands full\n  |       |       with all these \"b\" \n  |       |       I just made.) \n  |  (I'll hold those,      |\n  |   you take this, and   /\n  |   come back for more  /\n  |   when you're done   / \n  |   and we'll do it   / \n  |   again.)          /\n   \\      |  ( Uhhh. All right.)\n    \\     |       /    \n     \\    \\      /\n{| a |m}   >>=  f  In this case, the function knew how to make a list from it's input, but didn't know what to do with extra input and extra lists. The bind >>= , helped f out by combining the multiple outputs. I include this example to show that while >>= is responsible for extracting a , it also has access to the eventual bound output of f . Indeed, it will never extract any a unless it knows the eventual output has the same type of context.  There are other monads which are used to represent different contexts. Here's some characterizations of a few more. The IO monad doesn't actually have an a , but it knows a guy and will get that a for you. The State st monad has a secret stash of st that it will pass to f under the table, even though f just came asking for an a . The Reader r monad is similar to State st , although it only lets f look at r .  The point in all this is that any type of data which is declared itself to be a Monad is declaring some sort of context around extracting a value from the monad. The big gain from all this? Well, its easy enough to couch a calculation with some sort of context. It can get messy, however, when stringing together multiple context laden calculations. The monad operations take care of resolving the interactions of context so that the programmer doesn't have to.  Note, that use of the >>= eases a mess by by taking some of the autonomy away from f . That is, in the above case of Nothing for instance, f no longer gets to decide what to do in the case of Nothing ; it's encoded in >>= . This is the trade off. If it was necessary for f to decide what to do in the case of Nothing , then f should have been a function from Maybe a to Maybe b . In this case, Maybe being a monad is irrelevant.  Note, however, that sometimes a data type does not export it's constructors (looking at you IO), and if we want to work with the advertised value we have little choice but to work with it's monadic interface. ", "question_id": 44965}, "0.019917142"], [{"answer_votes": "14", "answer_comments": null, "answer_body": " My favorite Monad tutorial:  http://www.haskell.org/haskellwiki/All_About_Monads  (out of 170,000 hits on a Google search for \"monad tutorial\"!)  @Stu: The point of monads is to allow you to add (usually) sequential semantics to otherwise pure code; you can even compose monads (using Monad Transformers) and get more interesting and complicated combined semantics, like parsing with error handling, shared state, and logging, for example. All of this is possible in pure code, monads just allow you to abstract it away and reuse it in modular libraries (always good in programming), as well as providing convenient syntax to make it look imperative.  Haskell already has operator overloading[1]: it uses type classes much the way one might use interfaces in Java or C# but Haskell just happens to also allow non-alphanumeric tokens like + && and > as infix identifiers. It's only operator overloading in your way of looking at it if you mean \"overloading the semicolon\" [2]. It sounds like black magic and asking for trouble to \"overload the semicolon\" (picture enterprising Perl hackers getting wind of this idea) but the point is that without monads there is no semicolon, since purely functional code does not require or allow explicit sequencing.  This all sounds much more complicated than it needs to. sigfpe's article is pretty cool but uses Haskell to explain it, which sort of fails to break the chicken and egg problem of understanding Haskell to grok Monads and understanding Monads to grok Haskell.  [1] This is a separate issue from monads but monads use Haskell's operator overloading feature.  [2] This is also an oversimplification since the operator for chaining monadic actions is >>= (pronounced \"bind\") but there is syntactic sugar (\"do\") that lets you use braces and semicolons and/or indentation and newlines. ", "question_id": 44965}, "0.016798455"], [{"answer_votes": "2", "answer_comments": null, "answer_body": " I'm trying to understand monads as well. It's my version:  Monads are about making abstractions about repetitive things. \nFirstly, monad itself is a typed interface (like an abstract generic class), that has two functions: bind and return that have defined signatures. And then, we can create concrete monads based on that abstract monad, of course with specific implementations of bind and return. Additionally, bind and return must fulfill a few invariants in order to make it possible to compose/chain concrete monads.  Why create the monad concept while we have interfaces, types, classes and other tools to create abstractions? Because monads give more: they enforce rethinking problems in a way that enables to compose data without any boilerplate. ", "question_id": 44965}, "0.016534582"], [{"answer_votes": "-1", "answer_comments": null, "answer_body": " Explanation  It's quite simple, when explained in C#/Java terms:   A monad is a function that takes arguments and returns a special type.  The special type that this monad returns is also called monad. (A monad is a combination of #1 and #2)  There's some syntactic sugar to make calling this function and conversion of types easier.   Example  A monad is useful to make the life of the functional programmer easier. The typical example: The Maybe monad takes two parameters, a value and a function. It returns null if the passed value is null . Otherwise it evaluates the function. If we needed a special return type, we would call this return type Maybe as well. A very crude implementation would look like this:  object Maybe(object value, Func<object,object> function)\n{\n    if(value==null)\n        return null;\n\n    return function(value);\n}  This is spectacularly useless in C# because this language lacks the required syntactic sugar to make monads useful. But monads allow you to write more concise code in functional programming languages.  Oftentimes programmers call monads in chains, like so:  var x = Maybe(x, x2 => Maybe(y, y2 => Add(x2, y2)));  In this example the Add method would only be called if x and y are both non- null , otherwise null will be returned.  Answer  To answer the original question: A monad is a function AND a type. Like an implementation of a special interface . ", "question_id": 44965}, "0.016413925"], [{"answer_votes": "6", "answer_comments": [" That is more like Applicative than Monad.  With Monads, you have to get data from the pipes before you can choose the next pipe to connect. \u2013 Peaker  Jul 22 '10 at 23:33 "], "answer_body": " A monad is a way of combining computations together that share a common context.  It is like building a network of pipes.  When constructing the network, there is no data flowing through it.  But when I have finished piecing all the bits together with 'bind' and 'return' then I invoke something like runMyMonad monad data and the data flows through the pipes. ", "question_id": 44965}, "0.014917325"], [{"answer_votes": "3", "answer_comments": [" Do you mean \"what the world doesn't need ...\"? Nice analogy though! \u2013 groverboy  Jan 6 '15 at 1:36 ", " @groverboy I think there was a hint of sarcasm \u2013 icc97  Mar 7 '17 at 8:35 ", " @icc97 you're right - the meaning is clear enough. Sarcasm unintended, apologies to the author. \u2013 groverboy  Mar 14 '17 at 2:29 ", " What the world needs is another comment thread confirming a sarcasm, but if read carefully I've written but so that should make it clear. \u2013 Eugene Yokota  Mar 21 '17 at 3:26 "], "answer_body": " What the world needs is another monad blog post, but I think this is useful in identifying existing monads in the wild.   monads are fractals     The above is a fractal called Sierpinski triangle, the only fractal I can remember to draw. Fractals are self-similar structure like the above triangle, in which the parts are similar to the whole (in this case exactly half the scale as parent triangle).  Monads are fractals. Given a monadic data structure, its values can be composed to form another value of the data structure. This is why it's useful to programming, and this is why it occurrs in many situations.  ", "question_id": 44965}, "0.0147839105"], [{"answer_votes": "2", "answer_comments": null, "answer_body": " Essentially , and Practically , monads allow callback nesting (with a mutually-recursively-threaded state (pardon the hyphens)) (in a composable (or decomposable) fashion) (with type safety (sometimes (depending on the language))) )))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))  E.G. this is NOT a monad:  //JavaScript is 'Practical'\nvar getAllThree = \n         bind(getFirst, function(first){  \n  return bind(getSecond,function(second){  \n  return bind(getThird, function(third){  \n    var fancyResult = // And now make do fancy \n                      // with first, second,\n                      // and third \n    return RETURN(fancyResult);\n  });});});  But monads enable such code. The monad is actually the set of types for:  {bind,RETURN,maybe others I don't know...} . Which is essentially inessential, and practically impractical.  So now I can use it:  var fancyResultReferenceOutsideOfMonad =  \n  getAllThree(someKindOfInputAcceptableToOurGetFunctionsButProbablyAString);  \n\n//Ignore this please, throwing away types, yay JavaScript:\n//  RETURN = K\n//  bind = \\getterFn,cb -> \n//    \\in -> let(result,newState) = getterFn(in) in cb(result)(newState)  Or Break it up:  var getFirstTwo = \n           bind(getFirst, function(first){  \n    return bind(getSecond,function(second){  \n      var fancyResult2 = // And now make do fancy \n                         // with first and second\n      return RETURN(fancyResult2);\n    });})\n  , getAllThree = \n           bind(getFirstTwo, function(fancyResult2){  \n    return bind(getThird,    function(third){  \n      var fancyResult3 = // And now make do fancy \n                         // with fancyResult2,\n                         // and third \n      return RETURN(fancyResult3);\n    });});  Or ignore certain results:  var getFirstTwo = \n           bind(getFirst, function(first){  \n    return bind(getSecond,function(second){  \n      var fancyResult2 = // And now make do fancy \n                         // with first and second\n      return RETURN(fancyResult2);\n    });})\n  , getAllThree = \n           bind(getFirstTwo, function(____dontCare____NotGonnaUse____){  \n    return bind(getThird,    function(three){  \n      var fancyResult3 = // And now make do fancy \n                         // with `three` only!\n      return RETURN(fancyResult3);\n    });});  Or simplify a trivial case from:  var getFirstTwo = \n           bind(getFirst, function(first){  \n    return bind(getSecond,function(second){  \n      var fancyResult2 = // And now make do fancy \n                         // with first and second\n      return RETURN(fancyResult2);\n    });})\n  , getAllThree = \n           bind(getFirstTwo, function(_){  \n    return bind(getThird,    function(three){  \n      return RETURN(three);\n    });});  To (using \"Right Identity\" ):  var getFirstTwo = \n           bind(getFirst, function(first){  \n    return bind(getSecond,function(second){  \n      var fancyResult2 = // And now make do fancy \n                         // with first and second\n      return RETURN(fancyResult2);\n    });})\n  , getAllThree = \n           bind(getFirstTwo, function(_){  \n    return getThird;\n    });  Or jam them back together:  var getAllThree = \n           bind(getFirst, function(first_dontCareNow){  \n    return bind(getSecond,function(second_dontCareNow){  \n    return getThird;\n    });});  The practicality of these abilities doesn't really emerge, or become clear until you try to solve really messy problems like parsing, or module/ajax/resource loading.  Can you imagine thousands of lines of indexOf/subString logic? What if frequent parsing steps were contained in little functions? Functions like chars , spaces , upperChars , or digits ? And what if those functions gave you the result in a callback, without having to mess with Regex groups, and arguments.slice? And what if their composition/decomposition was well understood? Such that you could build big parsers from the bottom up?  So the ability to manage nested callback scopes is incredibly practical , especially when working with monadic parser combinator libraries. (that is to say, in my experience)  DON'T GET HUNG UP ON: - CATEGORY-THEORY - MAYBE-MONADS - MONAD LAWS - HASKELL - !!!! ", "question_id": 44965}, "0.014096591"], [{"answer_votes": "77", "answer_comments": [" What exactly do you mean by \"maps a function over it\"? \u2013 Casebash  Mar 14 '10 at 6:24 ", " Casebash, I'm being deliberately informal in the introduction. See the examples near the end to get a sense of what \"mapping a function\" entails. \u2013 Chris Conway  Mar 14 '10 at 14:54 ", " Monad is not a datatype. It is a rule of composing functions: stackoverflow.com/a/37345315/1614973 \u2013 Dmitri Zaitsev  May 20 '16 at 12:16 "], "answer_body": " A monad is a datatype that has two operations: >>= (aka bind ) and return (aka unit ). return takes an arbitrary value and creates an instance of the monad with it. >>= takes an instance of the monad and maps a function over it. (You can see already that a monad is a strange kind of datatype, since in most programming languages you couldn't write a function that takes an arbitrary value and creates a type from it. Monads use a kind of parametric polymorphism .)  In Haskell notation, the monad interface is written  class Monad m where\n  return :: a -> m a\n  (>>=) :: forall a b . m a -> (a -> m b) -> m b  These operations are supposed to obey certain \"laws\", but that's not terrifically important: the \"laws\" just codify the way sensible implementations of the operations ought to behave (basically, that >>= and return ought to agree about how values get transformed into monad instances and that >>= is associative).  Monads are not just about state and I/O: they abstract a common pattern of computation that includes working with state, I/O, exceptions, and non-determinism. Probably the simplest monads to understand are lists and option types:  instance Monad [ ] where\n    []     >>= k = []\n    (x:xs) >>= k = k x ++ (xs >>= k)\n    return x     = [x]\n\ninstance Monad Maybe where\n    Just x  >>= k = k x\n    Nothing >>= k = Nothing\n    return x      = Just x  where [] and : are the list constructors, ++ is the concatenation operator, and Just and Nothing are the Maybe constructors. Both of these monads encapsulate common and useful patterns of computation on their respective data types (note that neither has anything to do with side effects or I/O).  You really have to play around writing some non-trivial Haskell code to appreciate what monads are about and why they are useful. ", "question_id": 44965}, "0.011955493"], [{"answer_votes": "162", "answer_comments": [" -> is right-associative, mirroring function application, which is left-associative, so leaving the parentheses out doesn't make a difference here. \u2013 Matthias Benkard  Oct 11 '08 at 16:06 ", " Your explanation did the trick for me. I would have added though a limited summing of some standard monads (reader, state, maybe, ...) to illustrate some practical uses and wrappings \u2013 Rabarberski  Apr 27 '09 at 8:36 ", " I don't think this is a very good explanation at all. Monads are simply A way? okay, which way? Why wouldn't I encapsulate using a class instead of a monad? \u2013 Breton  Nov 6 '10 at 22:14 ", " A longer explanation of this idea: blog.sigfpe.com/2007/04/trivial-monad.html \u2013 sdcvvc  Jan 25 '12 at 16:26  ", " @mb21: In case you're just pointing out that there are too many brackets, note that a->b->c is actually only short for a->(b->c). Writing this particular example as (a -> b) -> (Ta -> Tb) is strictly speaking just adding unncessary characters, but it's morally \"the right thing to do\" as it emphasises that fmap maps a function of type a -> b to a function of type Ta -> Tb. And originally, that's what functors do in category theory and that's where monads come from. \u2013 Nikolaj-K  Jul 21 '14 at 14:36  "], "answer_body": " Actually, contrary to common understanding of Monads, they have nothing to do with state. Monads are simply a way to wrapping things and provide methods to do operations on the wrapped stuff without unwrapping it.  For example, you can create a type to wrap another one, in Haskell:  data Wrapped a = Wrap a  To wrap stuff we define  return :: a -> Wrapped a\nreturn x = Wrap x  To perform operations without unwrapping, say you have a function f :: a -> b , then you can do this to lift that function to act on wrapped values:  fmap :: (a -> b) -> (Wrapped a -> Wrapped b)\nfmap f (Wrap x) = Wrap (f x)  That's about all there is to understand. However, it turns out that there is a more general function to do this lifting , which is bind :  bind :: (a -> Wrapped b) -> (Wrapped a -> Wrapped b)\nbind f (Wrap x) = f x  bind can do a bit more than fmap , but not vice versa. Actually, fmap can be defined only in terms of bind and return . So, when defining a monad.. you give its type (here it was Wrapped a ) and then say how its return and bind operations work.  The cool thing is that this turns out to be such a general pattern that it pops up all over the place, encapsulating state in a pure way is only one of them.  For a good article on how monads can be used to introduce functional dependencies and thus control order of evaluation, like it is used in Haskell's IO monad, check out IO Inside .  As for understanding monads, don't worry too much about it. Read about them what you find interesting and don't worry if you don't understand right away. Then just diving in a language like Haskell is the way to go. Monads are one of these things where understanding trickles into your brain by practice, one day you just suddenly realize you understand them. ", "question_id": 44965}, "0.011281614"], [{"answer_votes": "1", "answer_comments": null, "answer_body": " http://mikehadlow.blogspot.com/2011/02/monads-in-c-8-video-of-my-ddd9-monad.html  This is the video you are looking for.  Demonstrating in C# what the problem is with composition and aligning the types, and then implementing them properly in C#. \nTowards the end he displays how the same C# code looks in F# and finally in Haskell. ", "question_id": 44965}, "0.010033693"], [{"answer_votes": "5", "answer_comments": null, "answer_body": " This answer begins with a motivating example, works through the example, derives an example of a monad, and formally defines \"monad\".  Consider these three functions in pseudocode:  f(<x, messages>) := <x, messages \"called f. \">\ng(<x, messages>) := <x, messages \"called g. \">\nwrap(x)          := <x, \"\">  f takes an ordered pair of the form <x, messages> and returns an ordered pair. It leaves the first item untouched and appends \"called f. \" to the second item. Same with g .  You can compose these functions and get your original value, along with a string that shows which order the functions were called in:  f(g(wrap(x)))\n= f(g(<x, \"\">))\n= f(<x, \"called g. \">)\n= <x, \"called g. called f. \">  You dislike the fact that f and g are responsible for appending their own log messages to the previous logging information. (Just imagine for the sake of argument that instead of appending strings, f and g must perform complicated logic on the second item of the pair. It would be a pain to repeat that complicated logic in two -- or more -- different functions.)  You prefer to write simpler functions:  f(x)    := <x, \"called f. \">\ng(x)    := <x, \"called g. \">\nwrap(x) := <x, \"\">  But look at what happens when you compose them:  f(g(wrap(x)))\n= f(g(<x, \"\">))\n= f(<<x, \"\">, \"called g. \">)\n= <<<x, \"\">, \"called g. \">, \"called f. \">  The problem is that passing a pair into a function does not give you what you want. But what if you could feed a pair into a function:  feed(f, feed(g, wrap(x)))\n= feed(f, feed(g, <x, \"\">))\n= feed(f, <x, \"called g. \">)\n= <x, \"called g. called f. \">  Read feed(f, m) as \"feed m into f \". To feed a pair <x, messages> into a function f is to pass  x into f , get <y, message> out of f , and return <y, messages message> .  feed(f, <x, messages>) := let <y, message> = f(x)\n                          in  <y, messages message>  Notice what happens when you do three things with your functions:  First: if you wrap a value and then feed the resulting pair into a function:  feed(f, wrap(x))\n= feed(f, <x, \"\">)\n= let <y, message> = f(x)\n  in  <y, \"\" message>\n= let <y, message> = <x, \"called f. \">\n  in  <y, \"\" message>\n= <x, \"\" \"called f. \">\n= <x, \"called f. \">\n= f(x)  That is the same as passing the value into the function.  Second: if you feed a pair into wrap :  feed(wrap, <x, messages>)\n= let <y, message> = wrap(x)\n  in  <y, messages message>\n= let <y, message> = <x, \"\">\n  in  <y, messages message>\n= <x, messages \"\">\n= <x, messages>  That does not change the pair.  Third: if you define a function that takes x and feeds g(x) into f :  h(x) := feed(f, g(x))  and feed a pair into it:  feed(h, <x, messages>)\n= let <y, message> = h(x)\n  in  <y, messages message>\n= let <y, message> = feed(f, g(x))\n  in  <y, messages message>\n= let <y, message> = feed(f, <x, \"called g. \">)\n  in  <y, messages message>\n= let <y, message> = let <z, msg> = f(x)\n                     in  <z, \"called g. \" msg>\n  in <y, messages message>\n= let <y, message> = let <z, msg> = <x, \"called f. \">\n                     in  <z, \"called g. \" msg>\n  in <y, messages message>\n= let <y, message> = <x, \"called g. \" \"called f. \">\n  in <y, messages message>\n= <x, messages \"called g. \" \"called f. \">\n= feed(f, <x, messages \"called g. \">)\n= feed(f, feed(g, <x, messages>))  That is the same as feeding the pair into g and feeding the resulting pair into f .  You have most of a monad. Now you just need to know about the data types in your program.  What type of value is <x, \"called f. \"> ? Well, that depends on what type of value x is. If x is of type t , then your pair is a value of type \"pair of t and string\". Call that type M t .  M is a type constructor: M alone does not refer to a type, but M _ refers to a type once you fill in the blank with a type. An M int is a pair of an int and a string. An M string is a pair of a string and a string. Etc.  Congratulations, you have created a monad!  Formally, your monad is the tuple <M, feed, wrap> .  A monad is a tuple <M, feed, wrap> where:   M is a type constructor.  feed takes a (function that takes a t and returns an M u ) and an M t and returns an M u .  wrap takes a v and returns an M v .   t , u , and v are any three types that may or may not be the same. A monad satisfies the three properties you proved for your specific monad:   Feeding a wrapped t into a function is the same as passing the unwrapped t into the function.  Formally: feed(f, wrap(x)) = f(x)  Feeding an M t into wrap does nothing to the M t .  Formally: feed(wrap, m) = m  Feeding an M t (call it m ) into a function that   passes the t into g  gets an M u (call it n ) from g  feeds n into f   is the same as   feeding m into g  getting n from g  feeding n into f   Formally: feed(h, m) = feed(f, feed(g, m)) where h(x) := feed(f, g(x))   Typically, feed is called bind (AKA >>= in Haskell) and wrap is called return . ", "question_id": 44965}, "0.0062043807"], [{"answer_votes": "3", "answer_comments": null, "answer_body": " tl;dr  {-# LANGUAGE InstanceSigs #-}\n\nnewtype Id t = Id t\n\ninstance Monad Id where\n   return :: t -> Id t\n   return = Id\n\n   (=<<) :: (a -> Id b) -> Id a -> Id b\n   f =<< (Id x) = f x  Prologue  The application operator $ of functions  forall a b. a -> b  is canonically defined  ($) :: (a -> b) -> a -> b\nf $ x = f x\n\ninfixr 0 $  in terms of Haskell-primitive function application f x ( infixl 10 ). Composition . is defined in terms of $ as  (.) :: (b -> c) -> (a -> b) -> (a -> c)\nf . g = \\ x -> f $ g x\n\ninfixr 9 .  and satisfies the equivalences forall f g h.  f . id  =  f            :: c -> d   Right identity\n     id . g  =  g            :: b -> c   Left identity\n(f . g) . h  =  f . (g . h)  :: a -> d   Associativity  . is associative, and id is its right and left identity.  The Kleisli triple  In programming, a monad is functor type constructor with an instance of the monad type class. There are several equivalent variants of definition and implementation, each carrying slightly different intuitions about the monad abstraction.  A functor is a type constructor f of kind * -> * with an instance of the functor type class.  {-# LANGUAGE KindSignatures #-}\n\nclass Functor (f :: * -> *) where\n   map :: (a -> b) -> (f a -> f b)  In addition to following statically enforced type protocol, instances of the functor type class must obey the algebraic functor laws  forall f g.  map id  =  id           :: f t -> f t   Identity\nmap f . map g  =  map (f . g)  :: f a -> f c   Composition / short cut fusion  Functor computations have the type  forall f t. Functor f => f t  A computation c r consists in results  r within context  c .  Unary monadic functions or Kleisli arrows have the type  forall m a b. Functor m => a -> m b  Kleisi arrows are functions that take one argument a and return a monadic computation m b .  Monads are canonically defined in terms of the Kleisli triple  forall m. Functor m =>  (m, return, (=<<))  implemented as the type class  class Functor m => Monad m where\n   return :: t -> m t\n   (=<<)  :: (a -> m b) -> m a -> m b\n\ninfixr 1 =<<  The Kleisli identity  return is a Kleisli arrow that promotes a value t into monadic context m . Extension or Kleisli application  =<< applies a Kleisli arrow a -> m b to results of a computation m a .  Kleisli composition  <=< is defined in terms of extension as  (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)\nf <=< g = \\ x -> f =<< g x\n\ninfixr 1 <=<  <=< composes two Kleisli arrows, applying the left arrow to results of the right arrow\u2019s application.  Instances of the monad type class must obey the monad laws , most elegantly stated in terms of Kleisli composition: forall f g h.  return <=< g  =  g                :: b -> m c   Left identity\n   f <=< return  =  f                :: c -> m d   Right identity\n(f <=< g) <=< h  =  f <=< (g <=< h)  :: a -> m d   Associativity  <=< is associative, and return is its right and left identity.  Identity  The identity type  type Id t = t  is the identity function on types  Id :: * -> *  Interpreted as a functor,  return :: t -> Id t\n=      id :: t ->    t\n\n    (=<<) :: (a -> Id b) -> Id a -> Id b\n=     ($) :: (a ->    b) ->    a ->    b\n\n    (<=<) :: (b -> Id c) -> (a -> Id b) -> (a -> Id c)\n=     (.) :: (b ->    c) -> (a ->    b) -> (a ->    c)  In canonical Haskell, the identity monad is defined  newtype Id t = Id t\n\ninstance Functor Id where\n   map :: (a -> b) -> Id a -> Id b\n   map f (Id x) = Id (f x)\n\ninstance Monad Id where\n   return :: t -> Id t\n   return = Id\n\n   (=<<) :: (a -> Id b) -> Id a -> Id b\n   f =<< (Id x) = f x  Option  An option type  data Maybe t = Nothing | Just t  encodes computation Maybe t that may not yield a result t , computation that may \u201cfail\u201d. The option monad is defined  instance Functor Maybe where\n   map :: (a -> b) -> (Maybe a -> Maybe b)\n   map f (Just x) = Just (f x)\n   map _ Nothing  = Nothing\n\ninstance Monad Maybe where\n   return :: t -> Maybe t\n   return = Just\n\n   (=<<) :: (a -> Maybe b) -> Maybe a -> Maybe b\n   f =<< (Just x) = f x\n   _ =<< Nothing  = Nothing  a -> Maybe b is applied only if Maybe a yields a result.  newtype Nat = Nat Int  The natural numbers can be encoded as those integers greater than or equal to zero.  toNat :: Int -> Maybe Nat\ntoNat i | i >= 0    = Just (Nat i)\n        | otherwise = Nothing  The natural numbers are not closed under subtraction.  (-?) :: Nat -> Nat -> Maybe Nat\n(Nat n) -? (Nat m) = toNat (n - m)\n\ninfixl 6 -?  The option monad covers a basic form of exception handling.  (-? 20) <=< toNat :: Int -> Maybe Nat  List  The list monad, over the list type  data [] t = [] | t : [t]\n\ninfixr 5 :  and its additive monoid operation \u201cappend\u201d  (++) :: [t] -> [t] -> [t]\n(x : xs) ++ ys = x : xs ++ ys\n[]       ++ ys = ys\n\ninfixr 5 ++  encodes nonlinear computation [t] yielding a natural amount 0, 1, ... of results t .  instance Functor [] where\n   map :: (a -> b) -> ([a] -> [b])\n   map f (x : xs) = f x : map f xs\n   map _ []       = []\n\ninstance Monad [] where\n   return :: t -> [t]\n   return = (: [])\n\n   (=<<) :: (a -> [b]) -> [a] -> [b]\n   f =<< (x : xs) = f x ++ f =<< xs\n   _ =<< []       = []  Extension concatenates ++ all result lists [b] from applications f x of a Kleisli arrow a -> [b] to elements of [a] into a single result list [b] .  Let the proper divisors of a positive integer n be  divisors :: Integral t => t -> [t]\ndivisors n = filter (`divides` n) [2 .. n - 1]\n\ndivides :: Integral t => t -> t -> Bool\n(`divides` n) = (== 0) . (n `rem`)  then  forall n.  let f = f <=< divisors in f n  =  []  In defining the monad type class, instead of extension =<< , the Haskell standard uses its flip, the bind operator >>= .  class Applicative m => Monad m where\n   (>>=) :: forall a b. m a -> (a -> m b) -> m b\n\n   (>>) :: forall a b. m a -> m b -> m b\n   m >> k = m >>= \\ _ -> k\n   {-# INLINE (>>) #-}\n\n   return :: a -> m a\n   return = pure\n\n   fail :: String -> m a\n   fail s = errorWithoutStackTrace s  For simplicitys sake, this explanation uses the type class hierarchy  class              Functor f\nclass Functor m => Monad m  In Haskell, the current standard hierarchy is  class                  Functor f\nclass Functor p     => Applicative p\nclass Applicative m => Monad m  because not only is every monad a functor, but every applicative is a functor and every monad an applicative, too.  Using the list monad, the imperative pseudocode  for a in (1, ..., 10)\n   for b in (1, ..., 10)\n      p <- a * b\n      if even(p)\n         yield p  roughly translates to the do block  do a <- [1 .. 10]\n   b <- [1 .. 10]\n   let p = a * b\n   guard (even p)\n   return p  the equivalent monad comprehension  [p | a <- [1 .. 10], b <- [1 .. 10], let p = a * b, even p]  and the expression  [1 .. 10] >>= (\\ a ->\n   [1 .. 10] >>= (\\ b ->\n      let p = a * b in\n         guard (even p) >>\n            return p\n   )\n)  Do notation and monad comprehensions are syntactic sugar for nested bind expressions. The bind operator is used for local name binding of monadic results.  let x = v in e  =  (\\ x -> e) $ v    =  v & (\\ x -> e)\n  do r <- m; c  =  (\\ r -> c) =<< m  =  m >>= (\\ r -> c)  where  (&) :: a -> (a -> b) -> b\n(&) = flip ($)\n\ninfixl 0 &  The guard function is defined  guard :: Additive m => Bool -> m ()\nguard True  = return ()\nguard False = fail  where the unit type or \u201cempty tuple\u201d  data () = ()  Additive monads that support choice and failure can be abstracted over using a type class  class Monad m => Additive m where\n   fail  :: m t\n   (<|>) :: m t -> m t -> m t\n\ninfixl 3 <|>\n\ninstance Additive Maybe where\n   fail = Nothing\n\n   Nothing <|> m = m\n   m       <|> _ = m\n\ninstance Additive [] where\n   fail = []\n   (<|>) = (++)  where fail and <|> form a monoid forall k l m.  fail <|> l  =  l\n     k <|> fail  =  k\n(k <|> l) <|> m  =  k <|> (l <|> m)  and fail is the absorbing/annihilating zero element of additive monads  _ =<< fail  =  fail  If in  guard (even p) >> return p  even p is true, then the guard produces [()] , and, by the definition of >> , the local constant function  \\ _ -> return p  is applied to the result () . If false, then the guard produces the list monad\u2019s fail  [] , which yields no result for a Kleisli arrow to be applied >> to.  State  Infamously, monads are used to encode stateful computation.  A state processor is a function  forall st t. st -> (t, st)  that transitions a state st and yields a result t . The state  st can be anything. Nothing, flag, count, array, handle, machine, world.  The type of state processors is usually called  type State st t = st -> (t, st)  The state processor monad is the kinded * -> * functor State st . Kleisli arrows of the state processor monad are functions  forall st a b. a -> (State st) b  In canonical Haskell, the lazy version of the state processor monad is defined  newtype State st t = State { stateProc :: st -> (t, st) }\n\ninstance Functor (State st) where\n   map :: (a -> b) -> ((State st) a -> (State st) b)\n   map f (State p) = State $ \\ s0 -> let (x, s1) = p s0\n                                     in  (f x, s1)\n\ninstance Monad (State st) where\n   return :: t -> (State st) t\n   return x = State $ \\ s -> (x, s)\n\n   (=<<) :: (a -> (State st) b) -> (State st) a -> (State st) b\n   f =<< (State p) = State $ \\ s0 -> let (x, s1) = p s0\n                                     in  stateProc (f x) s1  A state processor is run by supplying an initial state:  run :: State st t -> st -> (t, st)\nrun = stateProc\n\neval :: State st t -> st -> t\neval = fst . run\n\nexec :: State st t -> st -> st\nexec = snd . run  State access is provided by primitives get and put , methods of abstraction over stateful monads:  {-# LANGUAGE MultiParamTypeClasses, FunctionalDependencies #-}\n\nclass Monad m => Stateful m st |\u00a0m -> st where\n   get :: m st\n   put :: st -> m ()  m -> st declares a functional dependency of the state type st on the monad m ; that a State t , for example, will determine the state type to be t uniquely.  instance Stateful (State st) st where\n   get :: State st st\n   get = State $ \\ s -> (s, s)\n\n   put :: st -> State st ()\n   put s = State $ \\ _ -> ((), s)  with the unit type used analogously to void in C.  modify :: Stateful m st => (st -> st) -> m ()\nmodify f = do\n   s <- get\n   put (f s)\n\ngets :: Stateful m st => (st -> t) -> m t\ngets f = do\n   s <- get\n   return (f s)  gets is often used with record field accessors.  The state monad equivalent of the variable threading  let s0 = 34\n    s1 = (+ 1) s0\n    n = (* 12) s1\n    s2 = (+ 7) s1\nin  (show n, s2)  where s0 :: Int , is the equally referentially transparent, but infinitely more elegant and practical  (flip run) 34\n   (do\n      modify (+ 1)\n      n <- gets (* 12)\n      modify (+ 7)\n      return (show n)\n   )  modify (+ 1) is a computation of type State Int () , except for its effect equivalent to return () .  (flip run) 34\n   (modify (+ 1) >>\n      gets (* 12) >>= (\\ n ->\n         modify (+ 7) >>\n            return (show n)\n      )\n   )  The monad law of associativity can be written in terms of >>=  forall m f g.  (m >>= f) >>= g  =  m >>= (\\ x -> f x >>= g)  or  do {                 do {                   do {\n   r1 <- do {           x <- m;                r0 <- m;\n      r0 <- m;   =      do {            =      r1 <- f r0;\n      f r0                 r1 <- f x;          g r1\n   };                      g r1             }\n   g r1                 }\n}                    }  Like in expression-oriented programming (e.g. Rust), the last statement of a block represents its yield. The bind operator is sometimes called a \u201cprogrammable semicolon\u201d.  Iteration control structure primitives from structured imperative programming are emulated monadically  for :: Monad m => (a -> m b) -> [a] -> m ()\nfor f = foldr ((>>) . f) (return ())\n\nwhile :: Monad m => m Bool -> m t -> m ()\nwhile c m = do\n   b <- c\n   if b then m >> while c m\n        else return ()\n\nforever :: Monad m => m t\nforever m = m >> forever m  Input/Output  data World  The I/O world state processor monad is a reconciliation of pure Haskell and the real world, of functional denotative and imperative operational semantics. A close analogue of the actual strict implementation:  type IO t = World -> (t, World)  Interaction is facilitated by impure primitives  getChar         :: IO Char\nputChar         :: Char -> IO ()\nreadFile        :: FilePath -> IO String\nwriteFile       :: FilePath -> String -> IO ()\nhSetBuffering   :: Handle -> BufferMode -> IO ()\nhTell           :: Handle -> IO Integer\n. . .              . . .  The impurity of code that uses IO primitives is permanently protocolized by the type system. Because purity is awesome, what happens in IO , stays in IO .  unsafePerformIO :: IO t -> t  Or, at least, should.  The type signature of a Haskell program  main :: IO ()\nmain = putStrLn \"Hello, World!\"  expands to  World -> ((), World)  A function that transforms a world.  Epilogue  The category whiches objects are Haskell types and whiches morphisms are functions between Haskell types is, \u201cfast and loose\u201d, the category Hask .  A functor T is a mapping from a category C to a category D ; for each object in C an object in D  Tobj :  Obj(C) -> Obj(D)\n   f :: *      -> *  and for each morphism in C a morphism in D  Tmor :  HomC(X, Y) -> HomD(Tobj(X), Tobj(Y))\n map :: (a -> b)   -> (f a -> f b)  where X , Y are objects in C . HomC(X, Y) is the homomorphism class of all morphisms X -> Y in C . The functor must preserve morphism identity and composition, the \u201cstructure\u201d of C , in D .  Tmor    Tobj\n\n      T(id)  =  id        : T(X) -> T(X)   Identity\nT(f) . T(g)  =  T(f . g)  : T(X) -> T(Z)   Composition  The Kleisli category of a category C is given by a Kleisli triple  <T, eta, _*>  of an endofunctor  T : C -> C  ( f ), an identity morphism eta ( return ), and an extension operator * ( =<< ).  Each Kleisli morphism in Hask  f :  X -> T(Y)\n      f :: a -> m b  by the extension operator  (_)* :  Hom(X, T(Y)) -> Hom(T(X), T(Y))\n  (=<<) :: (a -> m b)   -> (m a -> m b)  is given a morphism in Hask \u2019s Kleisli category  f* :  T(X) -> T(Y)\n(f =<<) :: m a  -> m b  Composition in the Kleisli category .T is given in terms of extension  f .T g  =  f* . g       :  X -> T(Z)\nf <=< g  =  (f =<<) . g  :: a -> m c  and satisfies the category axioms  eta .T g  =  g                :  Y -> T(Z)   Left identity\n   return <=< g  =  g                :: b -> m c\n\n       f .T eta  =  f                :  Z -> T(U)   Right identity\n   f <=< return  =  f                :: c -> m d\n\n  (f .T g) .T h  =  f .T (g .T h)    :  X -> T(U)   Associativity\n(f <=< g) <=< h  =  f <=< (g <=< h)  :: a -> m d  which, applying the equivalence transformations  eta .T g  =  g\n     eta* . g  =  g               By definition of .T\n     eta* . g  =  id . g          forall f.  id . f  =  f\n         eta*  =  id              forall f g h.  f . h  =  g . h  ==>  f  =  g\n\n(f .T g) .T h  =  f .T (g .T h)\n(f* . g)* . h  =  f* . (g* . h)   By definition of .T\n(f* . g)* . h  =  f* . g* . h     . is associative\n    (f* . g)*  =  f* . g*         forall f g h.  f . h  =  g . h  ==>  f  =  g  in terms of extension are canonically given  eta*  =  id                 :  T(X) -> T(X)   Left identity\n       (return =<<)  =  id                 :: m t -> m t\n\n           f* . eta  =  f                  :  Z -> T(U)      Right identity\n   (f =<<) . return  =  f                  :: c -> m d\n\n          (f* . g)*  =  f* . g*            :  T(X) -> T(Z)   Associativity\n(((f =<<) . g) =<<)  =  (f =<<) . (g =<<)  :: m a -> m c  Monads can also be defined in terms not of Kleislian extension, but a natural transformation mu , in programming called join . A monad is defined in terms of mu as a triple over a category C , of an endofunctor  T :  C -> C\n     f :: * -> *  and two natural tranformations  eta :  Id -> T\nreturn :: t  -> f t\n\n    mu :  T . T   -> T\n  join :: f (f t) -> f t  satisfying the equivalences  mu . T(mu)  =  mu . mu               :  T . T . T -> T . T   Associativity\n  join . map join  =  join . join           :: f (f (f t)) -> f t\n\n      mu . T(eta)  =  mu . eta       =  id  :  T -> T               Identity\njoin . map return  =  join . return  =  id  :: f t -> f t  The monad type class is then defined  class Functor m => Monad m where\n   return :: t -> m t\n   join   :: m (m t) -> m t  The canonical mu implementation of the option monad:  instance Monad Maybe where\n   return = Just\n\n   join (Just m) = m\n   join Nothing  = Nothing  The concat function  concat :: [[a]] -> [a]\nconcat (x : xs) = x ++ concat xs\nconcat []       = []  is the join of the list monad.  instance Monad [] where\n   return :: t -> [t]\n   return = (: [])\n\n   (=<<) :: (a -> [b]) -> ([a] -> [b])\n   (f =<<) = concat . map f  Implementations of join can be translated from extension form using the equivalence  mu  =  id*           :  T . T -> T\n   join  =  (id =<<)      :: m (m t) -> m t  The reverse translation from mu to extension form is given by  f*  =  mu . T(f)     :  T(X) -> T(Y)\n(f =<<)  =  join . map f  :: m a -> m b    Philip Wadler: Monads for functional programming  Simon L Peyton Jones, Philip Wadler: Imperative functional programming  Jonathan M. D. Hill, Keith Clarke: An introduction to category theory, category theory monads, and their relationship to functional programming \u00b4  Kleisli category  Eugenio Moggi: Notions of computation and monads  What a monad is not    But why should a theory so abstract be of any use for programming?  The answer is simple: as computer scientists, we value abstraction ! When we design the interface to a software component, we want it to reveal as little as possible about the implementation. We want to be able to replace the implementation with many alternatives, many other \u2018instances\u2019 of the same \u2018concept\u2019. When we design a generic interface to many program libraries, it is even more important that the interface we choose have a variety of implementations. It is the generality of the monad concept which we value so highly, it is because category theory is so abstract that its concepts are so useful for programming.  It is hardly suprising, then, that the generalisation of monads that we present below also has a close connection to category theory. But we stress that our purpose is very practical: it is not to \u2018implement category theory\u2019, it is to find a more general way to structure combinator libraries. It is simply our good fortune that mathematicians have already done much of the work for us!   from Generalising Monads to Arrows by John Hughes ", "question_id": 44965}, "0.005816585"], [{"answer_votes": "-1", "answer_comments": [" Big Mistake : monad computation can be triggerred wo. main. \u2013 Titou  Jul 13 '15 at 13:28 "], "answer_body": " Mathematial thinking  For short: An Algebraic Structure for Combining Computations.  return data : create a computation who just simply generate a data in monad world.  (return data) >>= (return func) : The second parameter accept first parameter as a data generator and create a new computations which concatenate them.  You can think that (>>=) and return won't do any computation itself. They just simply combine and create computations.  Any monad computation will be compute if and only if main trigs it. ", "question_id": 44965}, "0.0055527124"], [{"answer_votes": "8", "answer_comments": [" If you use jQuery, this explanation can be very helpful, especially if your Haskell isn't strong \u2013 byteclub  Dec 15 '10 at 16:16 ", " JQuery is emphatically not a monad. The linked article is wrong. \u2013 Tony Morris  Jun 19 '12 at 8:13 ", " Being \"emphatic\" isn't very convincing.  For some useful discussion on the topic, see Is jQuery a monad - Stack Overflow \u2013 nealmcb  Mar 25 '13 at 4:23 ", " See also Douglas Crackford's Google Talk Monads and Gonads and his Javascript code for doing modads, expanding on the similar behavior of AJAX libraries and Promises: douglascrockford/monad \u00b7 GitHub \u2013 nealmcb  Mar 25 '13 at 5:10 "], "answer_body": " In addition to the excellent answers above, let me offer you a link to the following article (by Patrick Thomson) which explains monads by relating the concept to the JavaScript library jQuery (and its way of using \"method chaining\" to manipulate the DOM): jQuery is a Monad  The jQuery documentation itself doesn't refer to the term \"monad\" but talks about the \"builder pattern\" which is probably more familiar.  This doesn't change the fact that you have a proper monad there maybe without even realizing it. ", "question_id": 44965}, "0.003910676"], [{"answer_votes": "8", "answer_comments": null, "answer_body": " Monads Are Not Metaphors , but a practically useful abstraction emerging from a common pattern, as Daniel Spiewak explains. ", "question_id": 44965}, "0.0031225444"], [{"answer_votes": "5", "answer_comments": null, "answer_body": " In the context of Scala you will find the following to be the simplest definition. Basically flatMap (or bind) is 'associative' and there exists an identity.  trait M[+A] {\n  def flatMap[B](f: A => M[B]): M[B] // AKA bind\n\n  // Pseudo Meta Code\n  def isValidMonad: Boolean = {\n    // for every parameter the following holds\n    def isAssociativeOn[X, Y, Z](x: M[X], f: X => M[Y], g: Y => M[Z]): Boolean =\n      x.flatMap(f).flatMap(g) == x.flatMap(f(_).flatMap(g))\n\n    // for every parameter X and x, there exists an id\n    // such that the following holds\n    def isAnIdentity[X](x: M[X], id: X => M[X]): Boolean =\n      x.flatMap(id) == x\n  }\n}  E.g.  // These could be any functions\nval f: Int => Option[String] = number => if (number == 7) Some(\"hello\") else None\nval g: String => Option[Double] = string => Some(3.14)\n\n// Observe these are identical. Since Option is a Monad \n// they will always be identical no matter what the functions are\nscala> Some(7).flatMap(f).flatMap(g)\nres211: Option[Double] = Some(3.14)\n\nscala> Some(7).flatMap(f(_).flatMap(g))\nres212: Option[Double] = Some(3.14)\n\n\n// As Option is a Monad, there exists an identity:\nval id: Int => Option[Int] = x => Some(x)\n\n// Observe these are identical\nscala> Some(7).flatMap(id)\nres213: Option[Int] = Some(7)\n\nscala> Some(7)\nres214: Some[Int] = Some(7)  NOTE Strictly speaking the definition of a Monad in functional programming is not the same as the definition of a Monad in Category Theory , which is defined in turns of map and flatten .  Though they are kind of equivalent under certain mappings.  This presentations is very good: http://www.slideshare.net/samthemonad/monad-presentation-scala-as-a-category ", "question_id": 44965}, "0.0029653593"], [{"answer_votes": "5", "answer_comments": null, "answer_body": " In practice, monad is a custom implementation of function composition operator that takes care of side effects and incompatible input and return values (for chaining). ", "question_id": 44965}, "0.0024044595"], [{"answer_votes": "3", "answer_comments": [" The course doesn't exist on Coursera any more \u2013 icc97  Dec 15 '16 at 13:26 ", " That's a surprising - and v poor - reflection on Coursera. \u2013 javadba  Dec 5 '17 at 1:30 "], "answer_body": " In the Coursera \"Principles of Reactive Programming\" training - Erik Meier describes them as:  \"Monads are return types that guide you through the happy path.\" -Erik Meijer ", "question_id": 44965}, "0.0019837746"], [{"answer_votes": "3", "answer_comments": [" See if this helps projects.tmorris.net/public/what-does-monad-mean/artifacts/1.1/\u2026 \u2013 Tony Morris  Sep 9 '10 at 22:17  ", " Google Code is going to be closed down on 2016-01-15. Most projects are now read-only, as of 2015-08-24. \u2013 Peter Mortensen  Aug 28 '15 at 17:37 "], "answer_body": " http://code.google.com/p/monad-tutorial/ is a work in progress to address exactly this question. ", "question_id": 44965}, "0.0014079873"]], "nltk_title_analyze_code_result": null, "merge_gensim_nltk_title": [[{"answer_votes": "2", "answer_comments": [" You seem to be the only one who finally addressed my main problem with understanding Monads. Nobody ever talks about HOW can the value be extracted. Is it implementation dependant? \u2013 Vinicius Seufitele  Aug 22 '12 at 16:39 ", " @ViniciusSeufitele, thanks for your comment. I'm afraid that my understanding hasn't advanced a great deal since I wrote this answer, so I can't really add much. The value extraction logically has to exist, so maybe that's why nobody bothers to mention it. \u2013 Benjol  Aug 23 '12 at 5:45 ", " I have a discussion that treats the monad as a type expansion where the original type, b, is converted to an expanded type M<b> and the associated operators are wrapped to now service M<b>. These wrappers are what will handle the peculiarities of the monad. In particular, extracting the original type from the expanded type and passing it to it's wrapped operator and subsequently promoting the result. The benefit of the monad is that you retain simple declarative expressions. In my treatment I discussed expanding the numeric types system to include a DivByZero value to obviate the need to check \u2013 George  Oct 13 '14 at 16:45 ", " @ViniciusSeufitele , yes it is implementation dependent. The person writing the function >>= has access to the internals of the monad. For example see Maybe Monad and look for instance Monad Maybe . You'll see that when the left hand side is Just x then we return k x . The pattern matching does the unwrap for you. Something analogous happens in every monad implementation. \u2013 Michael Welch  Feb 3 '15 at 16:59  "], "answer_body": " Princess 's explanation of F# Computation Expressions helped me, though I still can't say I've really understood.  EDIT : this series - explaining monads with javascript - is the one that 'tipped the balance' for me.   http://blog.jcoglan.com/2011/03/05/translation-from-haskell-to-javascript-of-selected-portions-of-the-best-introduction-to-monads-ive-ever-read/  http://blog.jcoglan.com/2011/03/06/monad-syntax-for-javascript/  http://blog.jcoglan.com/2011/03/11/promises-are-the-monad-of-asynchronous-programming/   I think that understanding monads is something that creeps up on you. In that sense, reading as many 'tutorials' as you can is a good idea, but often strange stuff (unfamiliar language or syntax) prevents your brain from concentrating on the essential.  Some things that I had difficulty understanding:   Rules-based explanations never worked for me, because most practical examples actually require more than just return/bind.  Also, calling them rules didn't help. It is more a case of \"there are these things that have something in common, let's call the things 'monads', and the bits in common 'rules'\".  Return ( a -> M<a> ) and Bind ( M<a> -> (a -> M<b>) -> M<b> ) are great, but what I could never understand is HOW Bind could extract the a from M<a> in order to pass it into a -> M<b> . I don't think I've ever read anywhere (maybe it's obvious to everyone else), that the reverse of Return ( M<a> -> a ) has to exist inside the monad, it just doesn't need to be exposed.  ", "question_id": 44965}, "0.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.091196440.09119644"], [{"answer_votes": "9", "answer_comments": [" The python examples made it easy to comprehend! Thanks for sharing. \u2013 Ryan Efendy  Mar 2 at 17:50 "], "answer_body": " I am still new to monads, but I thought I would share a link I found that felt really good to read (WITH PICTURES!!): http://www.matusiak.eu/numerodix/blog/2012/3/11/monads-for-the-layman/ (no affiliation)  Basically, the warm and fuzzy concept that I got from the article was the concept that monads are basically adapters that allow disparate functions to work in a composable fashion, i.e. be able to string up multiple functions and mix and match them without worrying about inconsistent return types and such. So the BIND function is in charge of keeping apples with apples and oranges with oranges when we're trying to make these adapters. And the LIFT function is in charge of taking \"lower level\" functions and \"upgrading\" them to work with BIND functions and be composable as well.  I hope I got it right, and more importantly, hope that the article has a valid view on monads. If nothing else, this article helped whet my appetite for learning more about monads. ", "question_id": 44965}, "0.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.076065850.07606585"], [{"answer_votes": "2", "answer_comments": [" Lenses, not Monads, are a way for functional programmers to use imperative code without actually admitting it. \u2013 OleTraveler  Oct 18 '12 at 19:31 "], "answer_body": " Explaining monads seems to be like explaining control-flow statements. Imagine that a non-programmer asks you to explain them?  You can give them an explanation involving the theory - Boolean Logic, register values, pointers, stacks, and frames. But that would be crazy.  You could explain them in terms of the syntax. Basically all control-flow statements in C have curly brackets, and you can distinguish the condition and the conditional code by where they are relative to the brackets. That may be even crazier.  Or you could also explain loops, if statements, routines, subroutines, and possibly co-routines.  Monads can replace a fairly large number of programming techniques. There's a specific syntax in languages that support them, and some theories about them.  They are also a way for functional programmers to use imperative code without actually admitting it, but that's not their only use. ", "question_id": 44965}, "0.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.073518890.07351889"], [{"answer_votes": "36", "answer_comments": [" Sequencing isn't the only reason to define a monad.  A monad is just any functor which has bind and return.  Bind and return give you sequencing.  But they give other things as well.  Also, note that your favorite imperative language is effectively a fancy IO monad with OO classes.  Making it easy to define monads means it's easy to use the interpreter pattern -- define a dsl as a monad and interpret it! \u2013 nomen  May 17 '14 at 16:40  ", " Here is an implementation: github.com/brianspinos777/Programming_cheat_sheets/blob/master/\u2026 \u2013 Brian Joseph Spinos  Dec 21 '17 at 21:20  "], "answer_body": " After much striving, I think I finally understand the monad. After rereading my own lengthy critique of the overwhelmingly top voted answer, I will offer this explanation.  There are three questions that need to be answered to understand monads:   Why do you need a monad?  What is a monad?  How is a monad implemented?   As I noted in my original comments, too many monad explanations get caught up in question number 3, without, and before really adequately covering question 2, or question 1.  Why do you need a monad?  Pure functional languages like Haskell are different from imperative languages like C, or Java in that, a pure functional program is not necessarily executed in a specific order, one step at a time. A Haskell program is more akin to a mathematical function, in which you may solve the \"equation\" in any number of potential orders. This confers a number of benefits, among which is that it eliminates the possibility of certain kinds of bugs, particularly those relating to things like \"state\".  However, there are certain problems that are not so straightforward to solve with this style of programming. Some things, like console programming, and file i/o, need things to happen in a particular order, or need to maintain state. One way to deal with this problem is to create a kind of object that represents the state of a computation, and a series of functions that take a state object as input, and return a new modified state object.  So let's create a hypothetical \"state\" value, that represents the state of a console screen. exactly how this value is constructed is not important, but let's say it's an array of byte length ascii characters that represents what is currently visible on the screen, and an array that represents the last line of input entered by the user, in pseudocode. We've defined some functions that take console state, modify it, and return a new console state.  consolestate MyConsole = new consolestate;  So to do console programming, but in a pure functional manner, you would need to nest a lot of function calls inside eachother.  consolestate FinalConsole = print(input(print(myconsole, \"Hello, what's your name?\")),\"hello, %inputbuffer%!\");  Programming in this way keeps the \"pure\" functional style, while forcing changes to the console to happen in a particular order. But, we'll probably want to do more than just a few operations at a time like in the above example. Nesting functions in that way will start to become ungainly. What we want, is code that does essentially the same thing as above, but is written a bit more like this:  consolestate FinalConsole = myconsole:\n                            print(\"Hello, what's your name?\"):\n                            input():\n                            print(\"hello, %inputbuffer%!\");  This would indeed be a more convenient way to write it. How do we do that though?  What is a monad?  Once you have a type (such as consolestate ) that you define along with a bunch of functions designed specifically to operate on that type, you can turn the whole package of these things into a \"monad\" by defining an operator like : (bind) that automatically feeds return values on its left, into function parameters on its right, and a lift operator that turns normal functions, into functions that work with that specific kind of bind operator.  How is a monad implemented?  See other answers, that seem quite free to jump into the details of that. ", "question_id": 44965}, "0.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.070275010.07027501"], [{"answer_votes": "0", "answer_comments": null, "answer_body": " If you are asking for a succinct, practical explanation for something so abstract, then you can only hope for an abstract answer:  a -> b  is one way of representing a computation from a s to b s. You can chain computations, aka compose them together:  (b -> c) -> (a -> b) -> (a -> c)  More complex computations demand more complex types, e.g.:  a -> f b  is the type of computations from a s to b s that are into f s. You can also compose them:  (b -> f c) -> (a -> f b) -> (a -> f c)  It turns out this pattern appears literally everywhere and has the same properties as the first composition above (associativity, right- and left-identity).  One had to give this pattern a name, but then would it help to know that the first composition is formally characterised as a Semigroupoid ?  \"Monads are just as interesting and important as parentheses\" (Oleg Kiselyov) ", "question_id": 44965}, "0.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.069164470.06916447"], [{"answer_votes": "4", "answer_comments": null, "answer_body": " If I've understood correctly, IEnumerable is derived from monads. I wonder if that might be an interesting angle of approach for those of us from the C# world?  For what it's worth, here are some links to tutorials that helped me (and no, I still haven't understood what monads are).   http://osteele.com/archives/2007/12/overloading-semicolon  http://spbhug.folding-maps.org/wiki/MonadsEn  http://www.loria.fr/~kow/monads/  ", "question_id": 44965}, "0.065211570.065211570.065211570.065211570.065211570.065211570.065211570.065211570.065211570.065211570.065211570.065211570.065211570.065211570.065211570.065211570.065211570.065211570.065211570.065211570.065211570.065211570.065211570.065211570.065211570.065211570.065211570.06521157"], [{"answer_votes": "9", "answer_comments": null, "answer_body": " I've been thinking of Monads in a different way, lately. I've been thinking of them as abstracting out execution order in a mathematical way, which makes new kinds of polymorphism possible.  If you're using an imperative language, and you write some expressions in order, the code ALWAYS runs exactly in that order.  And in the simple case, when you use a monad, it feels the same -- you define a list of expressions that happen in order. Except that, depending on which monad you use, your code might run in order (like in IO monad), in parallel over several items at once (like in the List monad), it might halt partway through (like in the Maybe monad), it might pause partway through to be resumed later (like in a Resumption monad), it might rewind and start from the beginning (like in a Transaction monad), or it might rewind partway to try other options (like in a Logic monad).  And because monads are polymorphic, it's possible to run the same code in different monads, depending on your needs.  Plus, in some cases, it's possible to combine monads together (with monad transformers) to get multiple features at the same time. ", "question_id": 44965}, "0.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.049563590.04956359"], [{"answer_votes": "162", "answer_comments": [" \u2026best way not only on the internet, but anywhere. (Wadler's original paper Monads for functional programming that I mentioned in my answer below is also good.) None of the zillions of tutorials-by-analogy come close. \u2013 ShreevatsaR  Apr 30 '11 at 15:14 ", " This JavaScript translation of Sigfpe's post is the new best way to learn monads, for people who don't already grok advanced Haskell! \u2013 Sam Watkins  Jan 6 '14 at 2:55  ", " This is how I learned what a monad is. Walking the reader through the process of inventing a concept is often the best way to teach the concept. \u2013 Jordan  Mar 8 '15 at 5:58 ", " However, a function accepting the screen object as argument and returning its copy with text modified would be pure. \u2013 Dmitri Zaitsev  May 20 '16 at 12:09 "], "answer_body": " But, You could have invented Monads!   sigfpe says:   But all of these introduce monads as something esoteric in need of explanation. But what I want to argue is that they aren't esoteric at all. In fact, faced with various problems in functional programming you would have been led, inexorably, to certain solutions, all of which are examples of monads. In fact, I hope to get you to invent them now if you haven't already. It's then a small step to notice that all of these solutions are in fact the same solution in disguise. And after reading this, you might be in a better position to understand other documents on monads because you'll recognise everything you see as something you've already invented.  Many of the problems that monads try to solve are related to the issue of side effects. So we'll start with them. (Note that monads let you do more than handle side-effects, in particular many types of container object can be viewed as monads. Some of the introductions to monads find it hard to reconcile these two different uses of monads and concentrate on just one or the other.)  In an imperative programming language such as C++, functions behave nothing like the functions of mathematics. For example, suppose we have a C++ function that takes a single floating point argument and returns a floating point result. Superficially it might seem a little like a mathematical function mapping reals to reals, but a C++ function can do more than just return a number that depends on its arguments. It can read and write the values of global variables as well as writing output to the screen and receiving input from the user. In a pure functional language, however, a function can only read what is supplied to it in its arguments and the only way it can have an effect on the world is through the values it returns.   ", "question_id": 44965}, "0.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.0458202730.045820273"], [{"answer_votes": "2", "answer_comments": [" As I understand, monads are more than that. Encapsulating mutable state in a \"pure\" functional languages is only one application of monads. \u2013 thSoft  Dec 30 '10 at 2:17 "], "answer_body": " A monad is a thing used to encapsulate objects that have changing state. It is most often encountered in languages that otherwise do not allow you to have modifiable state (e.g., Haskell).  An example would be for file I/O.  You would be able to use a monad for file I/O to isolate the changing state nature to just the code that used the Monad. The code inside the Monad can effectively ignore the changing state of the world outside the Monad - this makes it a lot easier to reason about the overall effect of your program. ", "question_id": 44965}, "0.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.034678490.03467849"], [{"answer_votes": "5", "answer_comments": null, "answer_body": " Monoid appears to be something that ensures that all operations defined on a Monoid and a supported type will always return a supported type inside the Monoid. Eg, Any number + Any number = A number, no errors.  Whereas division accepts two fractionals, and returns a fractional, which defined division by zero as Infinity in haskell somewhy(which happens to be a fractional somewhy)...  In any case, it appears Monads are just a way to ensure that your chain of operations behaves in a predictable way, and a function that claims to be Num -> Num, composed with another function of Num->Num called with x does not say, fire the missiles.  On the other hand, if we have a function which does fire the missiles, we can compose it with other functions which also fire the missiles, because our intent is clear -- we want to fire the missiles -- but it won't try printing \"Hello World\" for some odd reason.  In Haskell, main is of type IO (), or IO [()], the distiction is strange and I will not discuss it but here's what I think happens:  If I have main, I want it to do a chain of actions, the reason I run the program is to produce an effect -- usually though IO. Thus I can chain IO operations together in main in order to -- do IO, nothing else.  If I try to do something which does not \"return IO\", the program will complain that the chain does not flow, or basically \"How does this relate to what we are trying to do -- an IO action\", it appears to force the programmer to keep their train of thought, without straying off and thinking about firing the missiles, while creating algorithms for sorting -- which does not flow.  Basically, Monads appear to be a tip to the compiler that \"hey, you know this function that returns a number here, it doesn't actually always work, it can sometimes produce a Number, and sometimes Nothing at all, just keep this in mind\". Knowing this, if you try to assert a monadic action, the monadic action may act as a compile time exception saying \"hey, this isn't actually a number, this CAN be a number, but you can't assume this, do something to ensure that the flow is acceptable.\" which prevents unpredictable program behavior -- to a fair extent.  It appears monads are not about purity, nor control, but about maintaining an identity of a category on which all behavior is predictable and defined, or does not compile. You cannot do nothing when you are expected to do something, and you cannot do something if you are expected to do nothing (visible).  The biggest reason I could think of for Monads is -- go look at Procedural/OOP code, and you will notice that you do not know where the program starts, nor ends, all you see is a lot of jumping and a lot of math,magic,and missiles. You will not be able to maintain it, and if you can, you will spend quite a lot of time wrapping your mind around the whole program before you can understand any part of it, because modularity in this context is based on interdependant \"sections\" of code, where code is optimized to be as related as possible for promise of efficiency/inter-relation. Monads are very concrete, and well defined by definition, and ensure that the flow of program is possible to analyze, and isolate parts which are hard to analyze -- as they themselves are monads. A monad appears to be a \"comprehensible unit which is predictable upon its full understanding\" -- If you understand \"Maybe\" monad, there's no possible way it will do anything except be \"Maybe\", which appears trivial, but in most non monadic code, a simple function \"helloworld\" can fire the missiles, do nothing, or destroy the universe or even distort time -- we have no idea nor have any guarantees that IT IS WHAT IT IS. A monad GUARANTEES that IT IS WHAT IT IS. which is very powerful.  All things in \"real world\" appear to be monads, in the sense that it is bound by definite observable laws preventing confusion. This does not mean we have to mimic all the operations of this object to create classes, instead we can simply say \"a square is a square\", nothing but a square, not even a rectangle nor a circle, and \"a square has area of the length of one of it's existing dimensions multiplied by itself. No matter what square you have, if it's a square in 2D space, it's area absolutely cannot be anything but its length squared, it's almost trivial to prove. This is very powerful because we do not need to make assertions to make sure that our world is the way it is, we just use implications of reality to prevent our programs from falling off track.  Im pretty much guaranteed to be wrong but I think this could help somebody out there, so hopefully it helps somebody. ", "question_id": 44965}, "0.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.0314492360.031449236"], [{"answer_votes": "34", "answer_comments": [" The only problem with Wadler's paper is the notation is different but I agree that the paper is pretty compelling and a clear concise motivation for applying monads. \u2013 Jared Updike  Jul 31 '09 at 22:34 ", " +1 for the \"monad tutorial fallacy\". Tutorials on monads are akin to having several tutorials trying to explain the concept of integer numbers. One tutorial would say, \"1 is similar to an apple\"; another tutorial says, \"2 is like a pear\"; a third one says, \"3 is basically an orange\". But you never get the whole picture from any single tutorial. What I've taken from that is that monads are an abstract concept which can be used for many quite different purposes. \u2013 stakx  Jan 14 '11 at 7:30  ", " @stakx: Yes, true. But I didn't mean that monads are an abstraction that you cannot learn or shouldn't learn; only that it's best to learn it after you've seen enough concrete examples to perceive a single underlying abstraction. See my other answer here . \u2013 ShreevatsaR  Jan 14 '11 at 12:22 ", " Sometimes I feel that there are so many tutorials that try to convince the reader that monads are useful by using code that do complicated or useful stuff. That hindered my understanding for months. I don't learn that way. I prefer to see extremely simple code, doing something stupid that I can mentally go through and I couldn't find this kind of example. I can't learn if the first example is a monad to parse a complicate grammar. I can learn if it's a monad to sum integers. \u2013 Rafael S. Calsaverini  Jan 23 '11 at 23:11  ", " Mentioning only type constructor is incomplete: stackoverflow.com/a/37345315/1614973 \u2013 Dmitri Zaitsev  May 20 '16 at 12:18 "], "answer_body": " (See also the answers at What is a monad? )  A good motivation to Monads is sigfpe (Dan Piponi)'s You Could Have Invented Monads! (And Maybe You Already Have) . There are a LOT of other monad tutorials , many of which misguidedly try to explain monads in \"simple terms\" using various analogies: this is the monad tutorial fallacy ; avoid them.  As DR MacIver says in Tell us why your language sucks :   So, things I hate about Haskell:   Let\u2019s start with the obvious. Monad tutorials. No, not monads. Specifically the tutorials. They\u2019re endless, overblown and dear god are they tedious. Further, I\u2019ve never seen any convincing evidence that they actually help. Read the class definition, write some code, get over the scary name.  You say you understand the Maybe monad? Good, you're on your way. Just start using other monads and sooner or later you'll understand what monads are in general.  [If you are mathematically oriented, you might want to ignore the dozens of tutorials and learn the definition, or follow lectures in category theory :)\nThe main part of the definition is that a Monad M involves a \"type constructor\" that defines for each existing type \"T\" a new type \"M T\", and some ways for going back and forth between \"regular\" types and \"M\" types.]  Also, surprisingly enough, one of the best introductions to monads is actually one of the early academic papers introducing monads, Philip Wadler's Monads for functional programming . It actually has practical, non-trivial motivating examples, unlike many of the artificial tutorials out there. ", "question_id": 44965}, "0.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.030449720.03044972"], [{"answer_votes": "951", "answer_comments": [" As someone who has had a great deal of problems understanding monads, I can say that this answer helped.. a little. However, there's still some things that I don't understand. In what way is the list comprehension a monad? Is there an expanded form of that example? Another thing that really bothers me about most monad explanations, including this one- Is that they keep mixing up \"what is a monad?\" with \"what is a monad good for?\" and \"How is a monad implemented?\".  you jumped that shark when you wrote \"A monad is basically just a type that supports the >>= operator.\" Which just had me... \u2013 Breton  Aug 10 '09 at 2:00 ", " Also I disagree with your conclusion about why monads are hard. If monads themselves aren't complex, then you should be able to explain what they are without a bunch of baggage. I don't want to know about the implementation when I ask the question \"What is a monad\", I want to know what itch it's meant to be scratching. So far it seems like the answer is \"Because the authors of haskell are sadomasochists and decided that you should do something stupidly complex to accomplish simple things, so you HAVE to learn monads to use haskell, not because they're in any way useful in themselves\"... \u2013 Breton  Aug 10 '09 at 2:08 ", " But.. that can't be right, can it? I think monads are hard because nobody can seem to figure out how to explain them without getting caught up in confusing implementation details. I mean.. what is a school bus? It's a metal platform with a device in the front which consumes a refined petroleum product to drive in a cycle some metallic pistons, which in turn rotate a crank shaft attached to some gears which drive some wheels. The wheels have inflated rubber bags around them which interface with an ashphalt surface to cause a collection of seats to move forward. The seats move forward because... \u2013 Breton  Aug 10 '09 at 2:12 ", " I read all of this and still don't know what a monad is, aside from the fact that it's something Haskell programmers don't understand well enough to explain. The examples don't help much, given that these are all things one can do without monads, and this answer doesn't make it clear how monads make them any easier, only more confusing. The one part of this answer that came close to being useful was where the syntactic sugar of example #2 was removed. I say came close because, aside from the first line, the expansion doesn't bear any real resemblance to the original. \u2013 Laurence Gonsalves  Dec 19 '11 at 4:44 ", " Another problem that seems to be endemic to explanations of monads is that it's written in Haskell. I'm not saying Haskell is a bad language -- I'm saying it's a bad language for explaining monads. If I knew Haskell I'd already understand monads, so if you want to explain monads, start by using a language that people who don't know monads are more likely to understand. If you must use Haskell, don't use the syntactic sugar at all -- use the smallest, simplest subset of the language you can, and don't assume an understanding of Haskell IO. \u2013 Laurence Gonsalves  Dec 19 '11 at 4:50 "], "answer_body": " First: The term monad is a bit vacuous if you are not a mathematician. An alternative term is computation builder which is a bit more descriptive of what they are actually useful for.  You ask for practical examples:  Example 1: List comprehension :  [x*2 | x<-[1..10], odd x]  This expression returns the doubles of all odd numbers in the range from 1 to 10. Very useful!  It turns out this is really just syntactic sugar for some operations within the List monad. The same list comprehension can be written as:  do\n   x <- [1..10]\n   if odd x \n       then [x * 2] \n       else []  Or even:  [1..10] >>= (\\x -> if odd x then [x*2] else [])  Example 2: Input/Output :  do\n   putStrLn \"What is your name?\"\n   name <- getLine\n   putStrLn (\"Welcome, \" ++ name ++ \"!\")  Both examples use monads, AKA computation builders. The common theme is that the monad chains operations in some specific, useful way. In the list comprehension, the operations are chained such that if an operation returns a list, then the following operations are performed on every item in the list. The IO monad on the other hand performs the operations sequentially, but passes a \"hidden variable\" along, which represents \"the state of the world\", which allows us to write I/O code in a pure functional manner.  It turns out the pattern of chaining operations is quite useful and is used for lots of different things in Haskell.  Another example is exceptions: Using the Error monad, operations are chained such that they are performed sequentially, except if an error is thrown, in which case the rest of the chain is abandoned.  Both the list-comprehension syntax and the do-notation are syntactic sugar for chaining operations using the >>= operator. A monad is basically just a type that supports the >>= operator.  Example 3: A parser  This is a very simple parser which parses either a quoted string or a number:  parseExpr = parseString <|> parseNumber\n\nparseString = do\n        char '\"'\n        x <- many (noneOf \"\\\"\")\n        char '\"'\n        return (StringValue x)\n\nparseNumber = do\n    num <- many1 digit\n    return (NumberValue (read num))  The operations char , digit , etc. are pretty simple. They either match or don't match. The magic is the monad which manages the control flow: The operations are performed sequentially until a match fails, in which case the monad backtracks to the latest <|> and tries the next option. Again, a way of chaining operations with some additional, useful semantics.  Example 4: Asynchronous programming  The above examples are in Haskell, but it turns out F# also supports monads. This example is stolen from Don Syme :  let AsyncHttp(url:string) =\n    async {  let req = WebRequest.Create(url)\n             let! rsp = req.GetResponseAsync()\n             use stream = rsp.GetResponseStream()\n             use reader = new System.IO.StreamReader(stream)\n             return reader.ReadToEnd() }  This method fetches a web page. The punch line is the use of GetResponseAsync - it actually waits for the response on a separate thread, while the main thread returns from the function. The last three lines are executed on the spawned thread when the response have been received.  In most other languages you would have to explicitly create a separate function for the lines that handle the response. The async monad is able to \"split\" the block on its own and postpone the execution of the latter half. (The async {} syntax indicates that the control flow in the block is defined by the async monad.)  How they work  So how can a monad do all these fancy control-flow thing? What actually happens in a do-block (or a computation expression as they are called in F#), is that every operation (basically every line) is wrapped in a separate anonymous function. These functions are then combined using the bind operator (spelled >>= in Haskell). Since the bind operation combines functions, it can execute them as it sees fit: sequentially, multiple times, in reverse, discard some, execute some on a separate thread when it feels like it and so on.  As an example, this is the expanded version of the IO-code from example 2:  putStrLn \"What is your name?\"\n>>= (\\_ -> getLine)\n>>= (\\name -> putStrLn (\"Welcome, \" ++ name ++ \"!\"))  This is uglier, but it's also more obvious what is actually going on. The >>= operator is the magic ingredient: It takes a value (on the left side) and combines it with a function (on the right side), to produce a new value. This new value is then taken by the next >>= operator and again combined with a function to produce a new value. >>= can be viewed as a mini-evaluator.  Note that >>= is overloaded for different types, so every monad has its own implementation of >>= . (All the operations in the chain have to be of the type of the same monad though, otherwise the >>= operator won't work.)  The simplest possible implementation of >>= just takes the value on the left and applies it to the function on the right and returns the result, but as said before, what makes the whole pattern useful is when there is something extra going on in the monad's implementation of >>= .  There is some additional cleverness in how the values are passed from one operation to the next, but this requires a deeper explanation of the Haskell type system.  Summing up  In Haskell-terms a monad is a parameterized type which is an instance of the Monad type class, which defines >>= along with a few other operators. In layman's terms, a monad is just a type for which the >>= operation is defined.  In itself >>= is just a cumbersome way of chaining functions, but with the presence of the do-notation which hides the \"plumbing\", the monadic operations turns out to be a very nice and useful abstraction, useful many places in the language, and useful for creating your own mini-languages in the language.  Why are monads hard?  For many Haskell-learners, monads are an obstacle they hit like a brick wall. It's not that monads themselves are complex, but that the implementation relies on many other advanced Haskell features like parameterized types, type classes, and so on. The problem is that Haskell I/O is based on monads, and I/O is probably one of the first things you want to understand when learning a new language - after all, it's not much fun to create programs which don't produce any output. I have no immediate solution for this chicken-and-egg problem, except treating I/O like \"magic happens here\" until you have enough experience with other parts of language. Sorry.  Excellent blog on monads: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html ", "question_id": 44965}, "0.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.030440890.03044089"], [{"answer_votes": "625", "answer_comments": [" I appreciate your answer\u2014especially the final concession that all of this is of course possible too without monads. One point to be made is that it's mostly easier with monads, but it's often not as efficient as doing it without them. Once you need to involve transformers, the extra layering of function calls (and function objects created) has a cost that's hard to see and control, rendered invisible by clever syntax. \u2013 seh  Apr 20 '12 at 16:35 ", " In Haskell at least, most of the overhead of monads gets stripped away by the optimiser. So the only real \"cost\" is in brain power required. (This is not insignificant if \"maintainability\" is something you care about.) But usually, monads make things easier , not harder. (Otherwise, why would you bother?) \u2013 MathematicalOrchid  Apr 21 '12 at 18:40 ", " I'm not sure whether or not Haskell supports this but mathematically you can define a monad either in terms of >>= and return or join and ap. >>= and return are what make monads practically useful but join and ap give a more intuitive understanding of what a monad is. \u2013 Jeremy List  Apr 2 '14 at 10:57 ", " Coming from a non-math, non-functional programming background, this answer made the most sense to me. \u2013 jrahhali  Aug 2 '17 at 23:55 ", " This is the first answer that actually gave me some idea of what the hell a monad is. Thank you for finding a way to explain it! \u2013 robotmay  Aug 14 '17 at 23:48 "], "answer_body": " Explaining \"what is a monad\" is a bit like saying \"what is a number?\" We use numbers all the time. But imagine you met someone who didn't know anything about numbers. How the heck would you explain what numbers are? And how would you even begin to describe why that might be useful?  What is a monad? The short answer: It's a specific way of chaining operations together.  In essence, you're writing execution steps and linking them together with the \"bind function\". (In Haskell, it's named >>= .) You can write the calls to the bind operator yourself, or you can use syntax sugar which makes the compiler insert those function calls for you. But either way, each step is separated by a call to this bind function.  So the bind function is like a semicolon; it separates the steps in a process. The bind function's job is to take the output from the previous step, and feed it into the next step.  That doesn't sound too hard, right? But there is more than one kind of monad. Why? How?  Well, the bind function can just take the result from one step, and feed it to the next step. But if that's \"all\" the monad does... that actually isn't very useful. And that's important to understand: Every useful monad does something else in addition to just being a monad. Every useful monad has a \"special power\", which makes it unique.  (A monad that does nothing special is called the \"identity monad\". Rather like the identity function, this sounds like an utterly pointless thing, yet turns out not to be... But that's another story\u2122.)  Basically, each monad has its own implementation of the bind function. And you can write a bind function such that it does hoopy things between execution steps. For example:   If each step returns a success/failure indicator, you can have bind execute the next step only if the previous one succeeded. In this way, a failing step aborts the whole sequence \"automatically\", without any conditional testing from you. (The Failure Monad .)  Extending this idea, you can implement \"exceptions\". (The Error Monad or Exception Monad .) Because you're defining them yourself rather than it being a language feature, you can define how they work. (E.g., maybe you want to ignore the first two exceptions and only abort when a third exception is thrown.)  You can make each step return multiple results , and have the bind function loop over them, feeding each one into the next step for you. In this way, you don't have to keep writing loops all over the place when dealing with multiple results. The bind function \"automatically\" does all that for you. (The List Monad .)  As well as passing a \"result\" from one step to another, you can have the bind function pass extra data around as well. This data now doesn't show up in your source code, but you can still access it from anywhere, without having to manually pass it to every function. (The Reader Monad .)  You can make it so that the \"extra data\" can be replaced. This allows you to simulate destructive updates , without actually doing destructive updates. (The State Monad and its cousin the Writer Monad .)  Because you're only simulating destructive updates, you can trivially do things that would be impossible with real destructive updates. For example, you can undo the last update , or revert to an older version .  You can make a monad where calculations can be paused , so you can pause your program, go in and tinker with internal state data, and then resume it.  You can implement \"continuations\" as a monad. This allows you to break people's minds!   All of this and more is possible with monads. Of course, all of this is also perfectly possible without monads too. It's just drastically easier using monads. ", "question_id": 44965}, "0.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.0299758280.029975828"], [{"answer_votes": "2", "answer_comments": null, "answer_body": " Another attempt at explaining monads, using just Python lists and the map function. I fully accept this isn't a full explanation, but I hope it gets at the core concepts.  I got the basis of this from the funfunfunction video on Monads and the Learn You A Haskell chapter 'For a Few Monads More' . I highly recommend watching the funfunfunction video.  At it's very simplest, Monads are objects that have a map and flatMap functions ( bind in Haskell). There are some extra required properties , but these are the core ones.  flatMap 'flattens' the output of map, for lists this just concatenates the values of the list e.g.  concat([[1], [4], [9]]) = [1, 4, 9]  So in Python we can very basically implement a Monad with just these two functions:  def flatMap(func, lst):\n    return concat(map(func, lst))\n\ndef concat(lst):\n    return sum(lst, [])  func is any function that takes a value and returns a list e.g.  lambda x: [x*x]  Explanation  For clarity I created the concat function in Python via a simple function , which sums the lists i.e. [] + [1] + [4] + [9] = [1, 4, 9] (Haskell has a native concat method).  I'm assuming you know what the map function is e.g.:  >>> list(map(lambda x: [x*x], [1,2,3]))\n[[1], [4], [9]]  Flattening is the key concept of Monads and for each object which is a Monad this flattening allows you to get at the value that is wrapped in the Monad.  Now we can call:  >>> flatMap(lambda x: [x*x], [1,2,3])\n[1, 4, 9]  This lambda is taking a value x and putting it into a list. A monad works with any function that goes from a value to a type of the monad, so a list in this case.  That's your monad defined .  I think the question of why they're useful has been answered in other questions.  More explanation  Other examples that aren't lists are JavaScript Promises, which have the then method and JavaScript Streams which have a flatMap method.  So Promises and Streams use a slightly different function which flattens out a Stream or a Promise and returns the value from within.  The Haskell list monad has the following definition:  instance Monad [] where  \n    return x = [x]  \n    xs >>= f = concat (map f xs)  \n    fail _ = []  i.e. there are three functions return (not to be confused with return in most other languages), >>= (the flatMap ) and fail .  Hopefully you can see the similarity between:  xs >>= f = concat (map f xs)  and:  def flatMap(f, xs):\n    return concat(map(f, xs)) ", "question_id": 44965}, "0.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.028472730.02847273"], [{"answer_votes": "2", "answer_comments": [" here is an implementation: github.com/brianspinos777/Programming_cheat_sheets/blob/master/\u2026 \u2013 Brian Joseph Spinos  Dec 21 '17 at 21:23 ", " IOW, Monad is generalized function call protocol. \u2013 Will Ness  Jan 28 at 16:09 ", " You answer is the most helpful in my opinion. Although I have to say that I think the emphasis needs to be on the fact that the functions you're refering to don't just involve values in contexts, they actively put values in contexts.  So for example, a function, f :: m a -> m b would very easily compose with another function, g :: m b -> m c.  But monads (bind specifically) allows us to perpetually compose functions which put their input in the same context, without us needing to take the value out of that context first (which would effectively remove information from the value) \u2013 James  Mar 23 at 18:41  ", " @James I think that should be the emphasis for functors? \u2013 Jonas  Mar 24 at 5:03 ", " @Jonas I guess I didn't explain propperly.   When I say that the functions put values in contexts, I mean that they have type (a -> m b). These are very useful since putting a value into a context adds new information to it but it would usually be difficult to chain a (a -> m b) and a (b -> m c) together since we can't just take the value out of the context. So we would have to use some convoluted process to chain these functions together in a sensible way depending on the specific context and monads just allow us to do this in a consistent way, regardless of the context. \u2013 James  Mar 24 at 16:23 "], "answer_body": " I will try to explain Monad in the context of Haskell.  In functional programming, function composition is important. It allows our program to consist of small, easy-to-read functions.  Let's say we have two functions: g :: Int -> String and f :: String -> Bool .  We can do (f . g) x , which is just the same as f (g x) , where x is an Int value.  When doing composition/applying the result of one function to another, having the types match up is important. In the above case, the type of the result returned by g must be the same as the type accepted by f .  But sometimes values are in contexts, and this makes it a bit less easy to line up types. (Having values in contexts is very useful. For example, the Maybe Int type represents an Int value that may not be there, the IO String type represents a String value that is there as a result of performing some side effects.)  Let's say we now have g1 :: Int -> Maybe String and f1 :: String -> Maybe Bool . g1 and f1 are very similar to g and f respectively.  We can't do (f1 . g1) x or f1 (g1 x) , where x is an Int value. The type of the result returned by g1 is not what f1 expects.  We could compose f and g with the . operator, but now we can't compose f1 and g1 with . . The problem is that we can't straightforwardly pass a value in a context to a function that expects a value that is not in a context.  Wouldn't it be nice if we introduce an operator to compose g1 and f1 , such that we can write (f1 OPERATOR g1) x ? g1 returns a value in a context. The value will be taken out of context and applied to f1 . And yes, we have such an operator. It's <=< .  We also have the >>= operator that does for us the exact same thing, though in a slightly different syntax.  We write: g1 x >>= f1 . g1 x is a Maybe Int value. The >>= operator helps take that Int value out of the \"perhaps-not-there\" context, and apply it to f1 . The result of f1 , which is a Maybe Bool , will be the result of the entire >>= operation.  And finally, why is Monad useful? Because Monad is the type class that defines the >>= operator, very much the same as the Eq type class that defines the == and /= operators.  To conclude, the Monad type class defines the >>= operator that allows us to pass values in a context (we call these monadic values) to functions that don't expect values in a context. The context will be taken care of.  If there is one thing to remember here, it is that Monad s allow function composition that involves values in contexts . ", "question_id": 44965}, "0.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.0281982010.028198201"], [{"answer_votes": "2", "answer_comments": null, "answer_body": " A very simple answer is:  Monads are an abstraction that provide an interface for encapsulating values, for computing new encapsulated values, and for unwrapping the encapsulated value.  What's convenient about them in practice is that they provide a uniform interface for creating data types that model state while not being stateful .  It's important to understand that a Monad is an abstraction , that is, an abstract interface for dealing with a certain kind of data structure. That interface is then used to build data types that have monadic behavior.  You can find a very good and practical introduction in Monads in Ruby, Part 1: Introduction . ", "question_id": 44965}, "0.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.0274443890.027444389"], [{"answer_votes": "69", "answer_comments": [" slight addition to def of 'higher order function': they can take OR RETURN functions. That's why they are 'higher' 'cos they do things with themselves. \u2013 Kevin Won  Jan 30 '10 at 6:31  ", " By that definition, addition is a higher-order function. It takes a number and returns a function that adds that number to another. So no, higher order functions are strictly functions whose domain consists of functions. \u2013 Apocalisp  Jan 30 '10 at 16:58  ", " The video ' Brian Beckman: Don't fear the Monad ' follows this same line of logic. \u2013 icc97  Oct 10 '16 at 5:29 "], "answer_body": " You should first understand what a functor is. Before that, understand higher-order functions.  A higher-order function is simply a function that takes a function as an argument.  A functor is any type construction T for which there exists a higher-order function, call it map , that transforms a function of type a -> b (given any two types a and b ) into a function T a -> T b . This map function must also obey the laws of identity and composition such that the following expressions return true for all x , p , and q (Haskell notation):  map id = id\nmap (p . q) = map p . map q  For example, a type constructor called List is a functor if it comes equipped with a function of type (a -> b) -> List a -> List b which obeys the laws above. The only practical implementation is obvious. The resulting List a -> List b function iterates over the given list, calling the (a -> b) function for each element, and returns the list of the results.  A monad is essentially just a functor T with two extra methods, join , of type T (T a) -> T a , and unit (sometimes called return , fork , or pure ) of type a -> T a . For lists in Haskell:  join :: [[a]] -> [a]\npure :: a -> [a]  Why is that useful? Because you could, for example, map over a list with a function that returns a list. Join takes the resulting list of lists and concatenates them. List is a monad because this is possible.  You can write a function that does map , then join . This function is called bind , or flatMap , or (>>=) , or (=<<) . This is normally how a monad instance is given in Haskell.  A monad has to satisfy certain laws, namely that join must be associative. This means that if you have a value x of type [[[a]]] then join (join x) should equal join (map join x) . And pure must be an identity for join such that join (pure x) == x . ", "question_id": 44965}, "0.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.0262583940.026258394"], [{"answer_votes": "28", "answer_comments": [" \"...but I hope others find it useful\" it was indeed useful for me, despite of all the emphasized sentences :D \u2013 ftor  Oct 19 '16 at 17:50 ", " This is the most concise and clear explanation of monads I've ever read/watched/heard.  Thank you! \u2013 James  Nov 7 '16 at 2:04 ", " There is important difference between Monad and Monoid. Monad is a rule to \"compose\" functions between different types, so they do not form a binary operation as required for Monoids, see here for more details: stackoverflow.com/questions/2704652/\u2026 \u2013 Dmitri Zaitsev  Nov 18 '16 at 16:51 ", " Yes. You are correct. Your article was over my head :). However, I found this treatment very helpful (and added it to mine as a direction to others). Thanks your the heads up: stackoverflow.com/a/7829607/1612190 \u2013 George  Nov 21 '16 at 7:44 ", " You might have confused Algebraic group theory with Category theory where Monad is coming from. The former is the theory of algebraic groups, which is unrelated. \u2013 Dmitri Zaitsev  Mar 1 '17 at 12:19 "], "answer_body": " I wrote this mostly for me but I hope others find it useful :)  In Summary  A monad is merely custom function composition utilizing a wrapping type to hold stateful/meta information that guides the composition. Interestingly, imperative execution is itself function composition wherein the wrapping type holds whether an exception has occurred, the presence of which aborts further composition. The monadic laws serve to ensure a monad only performs the equivalent of function composition over the wrapped value.  A Little Context  Imperative code is a sequence of instructions performed consecutively while functional code is actually an expression whose order of evaluation is ultimately on an as needed basis. Consequently, an imperative program evaluates each statement fully before proceeding to the next one while a functional program catalogs any preceding subexpression then evaluates the last one to generate a result, at which point any necessary preceding subexpressions are evaluated. (Most functional languages do resolve subexpressions into values as they are encountered with a few, notably Haskell, being the exception).  What Does That Have To Do With Monads  It turns out that imperative evaluation and \"expression\" evaluation are equivalent. Namely, the performance of an evaluation of an expression at any specific time can be described as the sequential evaluation of its subexpressions. Similarly, any sequential execution of statements can be considered an instance of such an expression being evaluated especially if you generalize the notion of return value to be any modification to the application state as oppose to merely formal return values. To the point, all imperative code can be considered a specific ordered evaluation of some equivalent expression (over the application state).  Still, What Does All That Have To Do With Monads  An expression is a composition of functions and a monad is a technique for customizing the composition of functions. Per convention, it is a function called, bind , that composes (binds) two functions ( bind f g = (x) => g(f x) ) within some umbrella type that holds a context or state guiding the binding process. This context allows the associated implementation of bind to massage the composition. In the case of, Result 'a , context that hold an error message or a actual value it would permit the bind to log errors of the preceding result and aborts or continue the composition with a default value, depending on design. Selective application of the subsequent function to be composed is the key facility of monads in that the application process is not blind, unlike silly imperative code. :)  In a monad, the functions to be composed are defined to receive a non-monadic or unwrapped value but return a monadic or wrapped value. An example of one such naturally occurring function is the division operator ( / ) which accepts numbers but may return undefined if the divisor is 0 . Since undefined is not a number, \\ , actually returns a type whose value range is large than a number since it includes all numbers plus undefined .  I suspect this asymmetry, where operators require valid values but may return invalid ones, is a key pragmatic aspect of monads that make them useful but difficult to explain and justify; while imperative coders accept constant result checking as a necessary evil, functional coders use bind over a suitable wrapper type to detect and manage exceptions or invalid results  While being a composition function, nonetheless, for pragmatic reasons bind is described as receiving the result of the first function, a wrapped value, that it then selectively applies to the second function whose result it then collects and returns as its result. Consequently, binds can themselves be composed.  For a complex example, a monad can take a sequence of asynchronous results as a preceding value and apply each to the provided composing function in parallel with respect to the available processors, then collect and return their results as they occur, for instance. All this functionality is in that specific implementation of that monad's bind function; however, there are typically ancillary functions that cooperate, in particular lift with wraps a value into a default instance of the monadic type such as, lift 1 = Just 1 in the case of the Maybe monad, for participation in monadic expressions. (In Haskell, a monad is strongly associated with the wrapper type because monads are implemented using its type class mechanisms whereas in F# the implementation uses defined computations expression instances)  Are you saying that...  ...a monad is just custom function composition using a wrapping type to hold stateful information that the bind or composing function or operator uses in determining whether and how to perform the application of the next function. Yep.  What About The Monadic Laws?  The monadic laws only seek to ensure that a monad implementation only performs the equivalent of function composition over the wrapped type. It does that by ensuring certain equivalences hold per the expectation of composing those two functions over the wrapped type.  That's it I think. Hope it helps some.  I believe this is nice a nice treatment in another StackOverflow of response . ", "question_id": 44965}, "0.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.0247845760.024784576"], [{"answer_votes": "5", "answer_comments": null, "answer_body": " The two things that helped me best when learning about there were:  Chapter 8, \"Functional Parsers,\" from Graham Hutton's book Programming in Haskell . This doesn't mention monads at all, actually, but if you can work through chapter and really understand everything in it, particularly how a sequence of bind operations is evaluated, you'll understand the internals of monads. Expect this to take several tries.  The tutorial All About Monads . This gives several good examples of their use, and I have to say that the analogy in Appendex I worked for me. ", "question_id": 44965}, "0.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.0240297370.024029737"], [{"answer_votes": "43", "answer_comments": [" Sometimes an explanation from a \"learner\" (like you) is more relevant to another learner than an explanation coming from an expert. Learners think alike :) \u2013 Adrian  Dec 7 '10 at 18:48 ", " What makes something a monad is the existence of a function with type M (M a) -> M a . The fact that you can turn that into one of type M a -> (a -> M b) -> M b is what makes them useful. \u2013 Jeremy List  Aug 19 '14 at 5:58 ", " \"monad\" roughly means \"pattern\" ... no. \u2013 user633183  May 19 '16 at 5:55 "], "answer_body": " [Disclaimer: I am still trying to fully grok monads. The following is just what I have understood so far. If it\u2019s wrong, hopefully someone knowledgeable will call me on the carpet.]  Arnar wrote:   Monads are simply a way to wrapping things and provide methods to do operations on the wrapped stuff without unwrapping it.   That\u2019s precisely it. The idea goes like this:   You take some kind of value and wrap it with some additional information. Just like the value is of a certain kind (eg. an integer or a string), so the additional information is of a certain kind.  E.g., that extra information might be a Maybe or an IO .  Then you have some operators that allow you to operate on the wrapped data while carrying along that additional information. These operators use the additional information to decide how to change the behaviour of the operation on the wrapped value.  E.g., a Maybe Int can be a Just Int or Nothing . Now, if you add a Maybe Int to a Maybe Int , the operator will check to see if they are both Just Int s inside, and if so, will unwrap the Int s, pass them the addition operator, re-wrap the resulting Int into a new Just Int (which is a valid Maybe Int ), and thus return a Maybe Int . But if one of them was a Nothing inside, this operator will just immediately return Nothing , which again is a valid Maybe Int . That way, you can pretend that your Maybe Int s are just normal numbers and perform regular math on them. If you were to get a Nothing , your equations will still produce the right result \u2013 without you having to litter checks for Nothing everywhere .   But the example is just what happens for Maybe . If the extra information was an IO , then that special operator defined for IO s would be called instead, and it could do something totally different before performing the addition. (OK, adding two IO Int s together is probably nonsensical \u2013 I\u2019m not sure yet.) (Also, if you paid attention to the Maybe example, you have noticed that \u201cwrapping a value with extra stuff\u201d is not always correct. But it\u2019s hard to be exact, correct and precise without being inscrutable.)  Basically, \u201cmonad\u201d roughly means \u201cpattern\u201d . But instead of a book full of informally explained and specifically named Patterns, you now have a language construct \u2013 syntax and all \u2013 that allows you to declare new patterns as things in your program . (The imprecision here is all the patterns have to follow a particular form, so a monad is not quite as generic as a pattern. But I think that\u2019s the closest term that most people know and understand.)  And that is why people find monads so confusing: because they are such a generic concept. To ask what makes something a monad is similarly vague as to ask what makes something a pattern.  But think of the implications of having syntactic support in the language for the idea of a pattern: instead of having to read the Gang of Four book and memorise the construction of a particular pattern, you just write code that implements this pattern in an agnostic, generic way once and then you are done! You can then reuse this pattern, like Visitor or Strategy or Fa\u00e7ade or whatever, just by decorating the operations in your code with it, without having to re-implement it over and over!  So that is why people who understand monads find them so useful : it\u2019s not some ivory tower concept that intellectual snobs pride themselves on understanding (OK, that too of course, teehee), but actually makes code simpler. ", "question_id": 44965}, "0.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.0232400580.023240058"], [{"answer_votes": "24", "answer_comments": null, "answer_body": " Monads are to control flow what abstract data types are to data.  In other words, many developers are comfortable with the idea of Sets, Lists, Dictionaries (or Hashes, or Maps), and Trees. Within those data types there are many special cases (for instance InsertionOrderPreservingIdentityHashMap).  However, when confronted with program \"flow\" many developers haven't been exposed to many more constructs than if, switch/case, do, while, goto (grr), and (maybe) closures.  So, a monad is simply a control flow construct. A better phrase to replace monad would be 'control type'.  As such, a monad has slots for control logic, or statements, or functions - the equivalent in data structures would be to say that some data structures allow you to add data, and remove it.  For example, the \"if\" monad:  if( clause ) then block  at its simplest has two slots - a clause, and a block. The if monad is usually built to evaluate the result of the clause, and if not false, evaluate the block. Many developers are not introduced to monads when they learn 'if', and it just isn't necessary to understand monads to write effective logic.  Monads can become more complicated, in the same way that data structures can become more complicated, but there are many broad categories of monad that may have similar semantics, but differing implementations and syntax.  Of course, in the same way that data structures may be iterated over, or traversed, monads may be evaluated.  Compilers may or may not have support for user-defined monads. Haskell certainly does. Ioke has some similar capabilities, although the term monad is not used in the language. ", "question_id": 44965}, "0.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.0226405640.022640564"], [{"answer_votes": "30", "answer_comments": [" Monads weren't 'designed', they were applied from one domain (category theory) to another (I/O in purely functional programming languages). Did Newton 'design' the calculus? \u2013 Jared Updike  Jul 31 '09 at 22:40 ", " Point 1 and 2 above are correct and useful. Points 4 and 5 are sort of ad hominem, even if more or less true. They don't really help explain monads. \u2013 Jared Updike  Jul 31 '09 at 22:42 ", " Re: 4, 5: The \"Secret handshake\" thing is a red herring. Programming is full of jargon. Haskell just happens to call stuff what it is without pretending to rediscover something. If it exists in mathematics already, why make up a new name for it? The name is really not the reason people don't get monads; they are a subtle concept. The average person probably understands addition and multiplication, why don't they get the concept of an Abelian Group? Because it is more abstract and general and that person hasn't done the work to wrap their head around the concept. A name change wouldn't help. \u2013 Jared Updike  Jul 31 '09 at 22:53 ", " Sigh... I'm not making an attack on Haskell ... I was making a joke.  So, I don't really get the bit about being \"ad hominem\".  Yes, the calculus was \"designed\". That's why, for example, calculus students are taught the Leibniz notation, rather than the icky stuff Netwton used. Better design.  Good names help understanding a lot. If I called Abelian Groups \"distended wrinkle pods\", you may have trouble understanding me.  You might be saying \"but that name is nonsense\", no one would ever call them that.  To people who have never heard of category theory \"monad\" sounds like nonsense. \u2013 Scott Wisniewski  Aug 1 '09 at 1:21 ", " @Scott: sorry if my extensive comments made it seem I was getting defensive about Haskell. I enjoy your humor about the secret handshake and you will note I said it is more or less true. :-) If you called Abelian Groups \"distended wrinkle pods\" you would be making the same mistake of trying to give monads a \"better name\" (cf. F# \"computation expressions\"): the term exists and people who care know what monads are, but not what \"warm fuzzy things\" are (or \"computation expressions\"). If I understand your use of the term \"type operator\" correctly there are lots of other type operators than monads. \u2013 Jared Updike  Aug 3 '09 at 23:27 "], "answer_body": " A monad is, effectively, a form of \"type operator\". It will do three things. First it will \"wrap\" (or otherwise convert) a value of one type into another type (typically called a \"monadic type\"). Secondly it will make all the operations (or functions) available on the underlying type available on the monadic type. Finally it will provide support for combining its self with another monad to produce a composite monad.  The \"maybe monad\" is essentially the equivalent of \"nullable types\" in Visual Basic / C#. It takes a non nullable type \"T\" and converts it into a \"Nullable<T>\", and then defines what all the binary operators mean on a Nullable<T>.  Side effects are represented simillarly. A structure is created that holds descriptions of side effects alongside a function's return value. The \"lifted\" operations then copy around side effects as values are passed between functions.  They are called \"monads\" rather than the easier-to-grasp name of \"type operators\" for several reasons:   Monads have restrictions on what they can do (see the definiton for details).  Those restrictions, along with the fact that there are three operations involved, conform to the structure of something called a monad in Category Theory, which is an obscure branch of mathematics.  They were designed by proponents of \"pure\" functional languages  Proponents of pure functional languages like obscure branches of mathematics  Because the math is obscure, and monads are associated with particular styles of programming, people tend to use the word monad as a sort of secret handshake. Because of this no one has bothered to invest in a better name.  ", "question_id": 44965}, "0.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.021826640.02182664"], [{"answer_votes": "0", "answer_comments": null, "answer_body": " Let the below \" {| a |m} \" represent some piece of monadic data. A data type which advertises an a :  (I got an a!)\n          /        \n    {| a |m}  Function, f , knows how to create a monad, if only it had an a :  (Hi f! What should I be?)\n                      /\n(You?. Oh, you'll be /\n that data there.)  /\n /                 /  (I got a b.)\n|    --------------      |\n|  /                     |\nf a                      |\n  |--later->       {| b |m}  Here we see function, f , tries to evaluate a monad but gets rebuked.  (Hmm, how do I get that a?)\n o       (Get lost buddy.\no         Wrong type.)\no       /\nf {| a |m}  Funtion, f , finds a way to extract the a by using >>= .  (Muaahaha. How you \n         like me now!?)       \n    (Better.)      \\\n        |     (Give me that a.)\n(Fine, well ok.)    |\n         \\          |\n   {| a |m}   >>=   f  Little does f know, the monad and >>= are in collusion.  (Yah got an a for me?)       \n(Yeah, but hey    | \n listen. I got    |\n something to     |\n tell you first   |\n ...)   \\        /\n         |      /\n   {| a |m}   >>=   f  But what do they actually talk about? Well, that depends on the monad. Talking solely in the abstract has limited use; you have to have some experience with particular monads to flesh out the understanding.  For instance, the data type Maybe  data Maybe a = Nothing | Just a  has a monad instance which will acts like the following...  Wherein, if the case is Just a  (Yah what is it?)       \n(... hm? Oh,      |\nforget about it.  |\nHey a, yr up.)    | \n            \\     |\n(Evaluation  \\    |\ntime already? \\   |\nHows my hair?) |  |\n      |       /   |\n      |  (It's    |\n      |  fine.)  /\n      |   /     /    \n   {| a |m}   >>=   f  But for the case of Nothing  (Yah what is it?)       \n(... There      |\nis no a. )      |\n  |        (No a?)\n(No a.)         |\n  |        (Ok, I'll deal\n  |         with this.)\n   \\            |\n    \\      (Hey f, get lost.) \n     \\          |   ( Where's my a? \n      \\         |     I evaluate a)\n       \\    (Not any more  |\n        \\    you don't.    |\n         |   We're returning\n         |   Nothing.)   /\n         |      |       /\n         |      |      /\n         |      |     /\n   {| a |m}   >>=   f      (I got a b.)\n                    |  (This is   \\\n                    |   such a     \\\n                    |   sham.) o o  \\\n                    |               o|\n                    |--later-> {| b |m}  So the Maybe monad lets a computation continue if it actually contains the a it advertises, but aborts the computation if it doesn't. The result, however is still a piece of monadic data, though not the output of f . For this reason, the Maybe monad is used to represent the context of failure.  Different monads behave differently. Lists are other types of data with monadic instances. They behave like the following:  (Ok, here's your a. Well, its\n a bunch of them, actually.)\n  |\n  |    (Thanks, no problem. Ok\n  |     f, here you go, an a.)\n  |       |\n  |       |        (Thank's. See\n  |       |         you later.)\n  |  (Whoa. Hold up f,      |\n  |   I got another         |\n  |   a for you.)           |\n  |       |      (What? No, sorry.\n  |       |       Can't do it. I \n  |       |       have my hands full\n  |       |       with all these \"b\" \n  |       |       I just made.) \n  |  (I'll hold those,      |\n  |   you take this, and   /\n  |   come back for more  /\n  |   when you're done   / \n  |   and we'll do it   / \n  |   again.)          /\n   \\      |  ( Uhhh. All right.)\n    \\     |       /    \n     \\    \\      /\n{| a |m}   >>=  f  In this case, the function knew how to make a list from it's input, but didn't know what to do with extra input and extra lists. The bind >>= , helped f out by combining the multiple outputs. I include this example to show that while >>= is responsible for extracting a , it also has access to the eventual bound output of f . Indeed, it will never extract any a unless it knows the eventual output has the same type of context.  There are other monads which are used to represent different contexts. Here's some characterizations of a few more. The IO monad doesn't actually have an a , but it knows a guy and will get that a for you. The State st monad has a secret stash of st that it will pass to f under the table, even though f just came asking for an a . The Reader r monad is similar to State st , although it only lets f look at r .  The point in all this is that any type of data which is declared itself to be a Monad is declaring some sort of context around extracting a value from the monad. The big gain from all this? Well, its easy enough to couch a calculation with some sort of context. It can get messy, however, when stringing together multiple context laden calculations. The monad operations take care of resolving the interactions of context so that the programmer doesn't have to.  Note, that use of the >>= eases a mess by by taking some of the autonomy away from f . That is, in the above case of Nothing for instance, f no longer gets to decide what to do in the case of Nothing ; it's encoded in >>= . This is the trade off. If it was necessary for f to decide what to do in the case of Nothing , then f should have been a function from Maybe a to Maybe b . In this case, Maybe being a monad is irrelevant.  Note, however, that sometimes a data type does not export it's constructors (looking at you IO), and if we want to work with the advertised value we have little choice but to work with it's monadic interface. ", "question_id": 44965}, "0.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.0199171420.019917142"], [{"answer_votes": "14", "answer_comments": null, "answer_body": " My favorite Monad tutorial:  http://www.haskell.org/haskellwiki/All_About_Monads  (out of 170,000 hits on a Google search for \"monad tutorial\"!)  @Stu: The point of monads is to allow you to add (usually) sequential semantics to otherwise pure code; you can even compose monads (using Monad Transformers) and get more interesting and complicated combined semantics, like parsing with error handling, shared state, and logging, for example. All of this is possible in pure code, monads just allow you to abstract it away and reuse it in modular libraries (always good in programming), as well as providing convenient syntax to make it look imperative.  Haskell already has operator overloading[1]: it uses type classes much the way one might use interfaces in Java or C# but Haskell just happens to also allow non-alphanumeric tokens like + && and > as infix identifiers. It's only operator overloading in your way of looking at it if you mean \"overloading the semicolon\" [2]. It sounds like black magic and asking for trouble to \"overload the semicolon\" (picture enterprising Perl hackers getting wind of this idea) but the point is that without monads there is no semicolon, since purely functional code does not require or allow explicit sequencing.  This all sounds much more complicated than it needs to. sigfpe's article is pretty cool but uses Haskell to explain it, which sort of fails to break the chicken and egg problem of understanding Haskell to grok Monads and understanding Monads to grok Haskell.  [1] This is a separate issue from monads but monads use Haskell's operator overloading feature.  [2] This is also an oversimplification since the operator for chaining monadic actions is >>= (pronounced \"bind\") but there is syntactic sugar (\"do\") that lets you use braces and semicolons and/or indentation and newlines. ", "question_id": 44965}, "0.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.0167984550.016798455"], [{"answer_votes": "2", "answer_comments": null, "answer_body": " I'm trying to understand monads as well. It's my version:  Monads are about making abstractions about repetitive things. \nFirstly, monad itself is a typed interface (like an abstract generic class), that has two functions: bind and return that have defined signatures. And then, we can create concrete monads based on that abstract monad, of course with specific implementations of bind and return. Additionally, bind and return must fulfill a few invariants in order to make it possible to compose/chain concrete monads.  Why create the monad concept while we have interfaces, types, classes and other tools to create abstractions? Because monads give more: they enforce rethinking problems in a way that enables to compose data without any boilerplate. ", "question_id": 44965}, "0.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.0165345820.016534582"], [{"answer_votes": "-1", "answer_comments": null, "answer_body": " Explanation  It's quite simple, when explained in C#/Java terms:   A monad is a function that takes arguments and returns a special type.  The special type that this monad returns is also called monad. (A monad is a combination of #1 and #2)  There's some syntactic sugar to make calling this function and conversion of types easier.   Example  A monad is useful to make the life of the functional programmer easier. The typical example: The Maybe monad takes two parameters, a value and a function. It returns null if the passed value is null . Otherwise it evaluates the function. If we needed a special return type, we would call this return type Maybe as well. A very crude implementation would look like this:  object Maybe(object value, Func<object,object> function)\n{\n    if(value==null)\n        return null;\n\n    return function(value);\n}  This is spectacularly useless in C# because this language lacks the required syntactic sugar to make monads useful. But monads allow you to write more concise code in functional programming languages.  Oftentimes programmers call monads in chains, like so:  var x = Maybe(x, x2 => Maybe(y, y2 => Add(x2, y2)));  In this example the Add method would only be called if x and y are both non- null , otherwise null will be returned.  Answer  To answer the original question: A monad is a function AND a type. Like an implementation of a special interface . ", "question_id": 44965}, "0.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.0164139250.016413925"], [{"answer_votes": "6", "answer_comments": [" That is more like Applicative than Monad.  With Monads, you have to get data from the pipes before you can choose the next pipe to connect. \u2013 Peaker  Jul 22 '10 at 23:33 "], "answer_body": " A monad is a way of combining computations together that share a common context.  It is like building a network of pipes.  When constructing the network, there is no data flowing through it.  But when I have finished piecing all the bits together with 'bind' and 'return' then I invoke something like runMyMonad monad data and the data flows through the pipes. ", "question_id": 44965}, "0.0149173250.0149173250.0149173250.0149173250.0149173250.0149173250.0149173250.0149173250.0149173250.0149173250.0149173250.0149173250.0149173250.0149173250.0149173250.0149173250.0149173250.0149173250.0149173250.0149173250.0149173250.0149173250.0149173250.0149173250.014917325"], [{"answer_votes": "3", "answer_comments": [" Do you mean \"what the world doesn't need ...\"? Nice analogy though! \u2013 groverboy  Jan 6 '15 at 1:36 ", " @groverboy I think there was a hint of sarcasm \u2013 icc97  Mar 7 '17 at 8:35 ", " @icc97 you're right - the meaning is clear enough. Sarcasm unintended, apologies to the author. \u2013 groverboy  Mar 14 '17 at 2:29 ", " What the world needs is another comment thread confirming a sarcasm, but if read carefully I've written but so that should make it clear. \u2013 Eugene Yokota  Mar 21 '17 at 3:26 "], "answer_body": " What the world needs is another monad blog post, but I think this is useful in identifying existing monads in the wild.   monads are fractals     The above is a fractal called Sierpinski triangle, the only fractal I can remember to draw. Fractals are self-similar structure like the above triangle, in which the parts are similar to the whole (in this case exactly half the scale as parent triangle).  Monads are fractals. Given a monadic data structure, its values can be composed to form another value of the data structure. This is why it's useful to programming, and this is why it occurrs in many situations.  ", "question_id": 44965}, "0.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.01478391050.0147839105"], [{"answer_votes": "2", "answer_comments": null, "answer_body": " Essentially , and Practically , monads allow callback nesting (with a mutually-recursively-threaded state (pardon the hyphens)) (in a composable (or decomposable) fashion) (with type safety (sometimes (depending on the language))) )))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))  E.G. this is NOT a monad:  //JavaScript is 'Practical'\nvar getAllThree = \n         bind(getFirst, function(first){  \n  return bind(getSecond,function(second){  \n  return bind(getThird, function(third){  \n    var fancyResult = // And now make do fancy \n                      // with first, second,\n                      // and third \n    return RETURN(fancyResult);\n  });});});  But monads enable such code. The monad is actually the set of types for:  {bind,RETURN,maybe others I don't know...} . Which is essentially inessential, and practically impractical.  So now I can use it:  var fancyResultReferenceOutsideOfMonad =  \n  getAllThree(someKindOfInputAcceptableToOurGetFunctionsButProbablyAString);  \n\n//Ignore this please, throwing away types, yay JavaScript:\n//  RETURN = K\n//  bind = \\getterFn,cb -> \n//    \\in -> let(result,newState) = getterFn(in) in cb(result)(newState)  Or Break it up:  var getFirstTwo = \n           bind(getFirst, function(first){  \n    return bind(getSecond,function(second){  \n      var fancyResult2 = // And now make do fancy \n                         // with first and second\n      return RETURN(fancyResult2);\n    });})\n  , getAllThree = \n           bind(getFirstTwo, function(fancyResult2){  \n    return bind(getThird,    function(third){  \n      var fancyResult3 = // And now make do fancy \n                         // with fancyResult2,\n                         // and third \n      return RETURN(fancyResult3);\n    });});  Or ignore certain results:  var getFirstTwo = \n           bind(getFirst, function(first){  \n    return bind(getSecond,function(second){  \n      var fancyResult2 = // And now make do fancy \n                         // with first and second\n      return RETURN(fancyResult2);\n    });})\n  , getAllThree = \n           bind(getFirstTwo, function(____dontCare____NotGonnaUse____){  \n    return bind(getThird,    function(three){  \n      var fancyResult3 = // And now make do fancy \n                         // with `three` only!\n      return RETURN(fancyResult3);\n    });});  Or simplify a trivial case from:  var getFirstTwo = \n           bind(getFirst, function(first){  \n    return bind(getSecond,function(second){  \n      var fancyResult2 = // And now make do fancy \n                         // with first and second\n      return RETURN(fancyResult2);\n    });})\n  , getAllThree = \n           bind(getFirstTwo, function(_){  \n    return bind(getThird,    function(three){  \n      return RETURN(three);\n    });});  To (using \"Right Identity\" ):  var getFirstTwo = \n           bind(getFirst, function(first){  \n    return bind(getSecond,function(second){  \n      var fancyResult2 = // And now make do fancy \n                         // with first and second\n      return RETURN(fancyResult2);\n    });})\n  , getAllThree = \n           bind(getFirstTwo, function(_){  \n    return getThird;\n    });  Or jam them back together:  var getAllThree = \n           bind(getFirst, function(first_dontCareNow){  \n    return bind(getSecond,function(second_dontCareNow){  \n    return getThird;\n    });});  The practicality of these abilities doesn't really emerge, or become clear until you try to solve really messy problems like parsing, or module/ajax/resource loading.  Can you imagine thousands of lines of indexOf/subString logic? What if frequent parsing steps were contained in little functions? Functions like chars , spaces , upperChars , or digits ? And what if those functions gave you the result in a callback, without having to mess with Regex groups, and arguments.slice? And what if their composition/decomposition was well understood? Such that you could build big parsers from the bottom up?  So the ability to manage nested callback scopes is incredibly practical , especially when working with monadic parser combinator libraries. (that is to say, in my experience)  DON'T GET HUNG UP ON: - CATEGORY-THEORY - MAYBE-MONADS - MONAD LAWS - HASKELL - !!!! ", "question_id": 44965}, "0.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.0140965910.014096591"], [{"answer_votes": "77", "answer_comments": [" What exactly do you mean by \"maps a function over it\"? \u2013 Casebash  Mar 14 '10 at 6:24 ", " Casebash, I'm being deliberately informal in the introduction. See the examples near the end to get a sense of what \"mapping a function\" entails. \u2013 Chris Conway  Mar 14 '10 at 14:54 ", " Monad is not a datatype. It is a rule of composing functions: stackoverflow.com/a/37345315/1614973 \u2013 Dmitri Zaitsev  May 20 '16 at 12:16 "], "answer_body": " A monad is a datatype that has two operations: >>= (aka bind ) and return (aka unit ). return takes an arbitrary value and creates an instance of the monad with it. >>= takes an instance of the monad and maps a function over it. (You can see already that a monad is a strange kind of datatype, since in most programming languages you couldn't write a function that takes an arbitrary value and creates a type from it. Monads use a kind of parametric polymorphism .)  In Haskell notation, the monad interface is written  class Monad m where\n  return :: a -> m a\n  (>>=) :: forall a b . m a -> (a -> m b) -> m b  These operations are supposed to obey certain \"laws\", but that's not terrifically important: the \"laws\" just codify the way sensible implementations of the operations ought to behave (basically, that >>= and return ought to agree about how values get transformed into monad instances and that >>= is associative).  Monads are not just about state and I/O: they abstract a common pattern of computation that includes working with state, I/O, exceptions, and non-determinism. Probably the simplest monads to understand are lists and option types:  instance Monad [ ] where\n    []     >>= k = []\n    (x:xs) >>= k = k x ++ (xs >>= k)\n    return x     = [x]\n\ninstance Monad Maybe where\n    Just x  >>= k = k x\n    Nothing >>= k = Nothing\n    return x      = Just x  where [] and : are the list constructors, ++ is the concatenation operator, and Just and Nothing are the Maybe constructors. Both of these monads encapsulate common and useful patterns of computation on their respective data types (note that neither has anything to do with side effects or I/O).  You really have to play around writing some non-trivial Haskell code to appreciate what monads are about and why they are useful. ", "question_id": 44965}, "0.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.0119554930.011955493"], [{"answer_votes": "162", "answer_comments": [" -> is right-associative, mirroring function application, which is left-associative, so leaving the parentheses out doesn't make a difference here. \u2013 Matthias Benkard  Oct 11 '08 at 16:06 ", " Your explanation did the trick for me. I would have added though a limited summing of some standard monads (reader, state, maybe, ...) to illustrate some practical uses and wrappings \u2013 Rabarberski  Apr 27 '09 at 8:36 ", " I don't think this is a very good explanation at all. Monads are simply A way? okay, which way? Why wouldn't I encapsulate using a class instead of a monad? \u2013 Breton  Nov 6 '10 at 22:14 ", " A longer explanation of this idea: blog.sigfpe.com/2007/04/trivial-monad.html \u2013 sdcvvc  Jan 25 '12 at 16:26  ", " @mb21: In case you're just pointing out that there are too many brackets, note that a->b->c is actually only short for a->(b->c). Writing this particular example as (a -> b) -> (Ta -> Tb) is strictly speaking just adding unncessary characters, but it's morally \"the right thing to do\" as it emphasises that fmap maps a function of type a -> b to a function of type Ta -> Tb. And originally, that's what functors do in category theory and that's where monads come from. \u2013 Nikolaj-K  Jul 21 '14 at 14:36  "], "answer_body": " Actually, contrary to common understanding of Monads, they have nothing to do with state. Monads are simply a way to wrapping things and provide methods to do operations on the wrapped stuff without unwrapping it.  For example, you can create a type to wrap another one, in Haskell:  data Wrapped a = Wrap a  To wrap stuff we define  return :: a -> Wrapped a\nreturn x = Wrap x  To perform operations without unwrapping, say you have a function f :: a -> b , then you can do this to lift that function to act on wrapped values:  fmap :: (a -> b) -> (Wrapped a -> Wrapped b)\nfmap f (Wrap x) = Wrap (f x)  That's about all there is to understand. However, it turns out that there is a more general function to do this lifting , which is bind :  bind :: (a -> Wrapped b) -> (Wrapped a -> Wrapped b)\nbind f (Wrap x) = f x  bind can do a bit more than fmap , but not vice versa. Actually, fmap can be defined only in terms of bind and return . So, when defining a monad.. you give its type (here it was Wrapped a ) and then say how its return and bind operations work.  The cool thing is that this turns out to be such a general pattern that it pops up all over the place, encapsulating state in a pure way is only one of them.  For a good article on how monads can be used to introduce functional dependencies and thus control order of evaluation, like it is used in Haskell's IO monad, check out IO Inside .  As for understanding monads, don't worry too much about it. Read about them what you find interesting and don't worry if you don't understand right away. Then just diving in a language like Haskell is the way to go. Monads are one of these things where understanding trickles into your brain by practice, one day you just suddenly realize you understand them. ", "question_id": 44965}, "0.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.0112816140.011281614"], [{"answer_votes": "1", "answer_comments": null, "answer_body": " http://mikehadlow.blogspot.com/2011/02/monads-in-c-8-video-of-my-ddd9-monad.html  This is the video you are looking for.  Demonstrating in C# what the problem is with composition and aligning the types, and then implementing them properly in C#. \nTowards the end he displays how the same C# code looks in F# and finally in Haskell. ", "question_id": 44965}, "0.0100336930.0100336930.0100336930.0100336930.0100336930.0100336930.0100336930.0100336930.0100336930.0100336930.0100336930.0100336930.0100336930.0100336930.0100336930.0100336930.010033693"], [{"answer_votes": "5", "answer_comments": null, "answer_body": " This answer begins with a motivating example, works through the example, derives an example of a monad, and formally defines \"monad\".  Consider these three functions in pseudocode:  f(<x, messages>) := <x, messages \"called f. \">\ng(<x, messages>) := <x, messages \"called g. \">\nwrap(x)          := <x, \"\">  f takes an ordered pair of the form <x, messages> and returns an ordered pair. It leaves the first item untouched and appends \"called f. \" to the second item. Same with g .  You can compose these functions and get your original value, along with a string that shows which order the functions were called in:  f(g(wrap(x)))\n= f(g(<x, \"\">))\n= f(<x, \"called g. \">)\n= <x, \"called g. called f. \">  You dislike the fact that f and g are responsible for appending their own log messages to the previous logging information. (Just imagine for the sake of argument that instead of appending strings, f and g must perform complicated logic on the second item of the pair. It would be a pain to repeat that complicated logic in two -- or more -- different functions.)  You prefer to write simpler functions:  f(x)    := <x, \"called f. \">\ng(x)    := <x, \"called g. \">\nwrap(x) := <x, \"\">  But look at what happens when you compose them:  f(g(wrap(x)))\n= f(g(<x, \"\">))\n= f(<<x, \"\">, \"called g. \">)\n= <<<x, \"\">, \"called g. \">, \"called f. \">  The problem is that passing a pair into a function does not give you what you want. But what if you could feed a pair into a function:  feed(f, feed(g, wrap(x)))\n= feed(f, feed(g, <x, \"\">))\n= feed(f, <x, \"called g. \">)\n= <x, \"called g. called f. \">  Read feed(f, m) as \"feed m into f \". To feed a pair <x, messages> into a function f is to pass  x into f , get <y, message> out of f , and return <y, messages message> .  feed(f, <x, messages>) := let <y, message> = f(x)\n                          in  <y, messages message>  Notice what happens when you do three things with your functions:  First: if you wrap a value and then feed the resulting pair into a function:  feed(f, wrap(x))\n= feed(f, <x, \"\">)\n= let <y, message> = f(x)\n  in  <y, \"\" message>\n= let <y, message> = <x, \"called f. \">\n  in  <y, \"\" message>\n= <x, \"\" \"called f. \">\n= <x, \"called f. \">\n= f(x)  That is the same as passing the value into the function.  Second: if you feed a pair into wrap :  feed(wrap, <x, messages>)\n= let <y, message> = wrap(x)\n  in  <y, messages message>\n= let <y, message> = <x, \"\">\n  in  <y, messages message>\n= <x, messages \"\">\n= <x, messages>  That does not change the pair.  Third: if you define a function that takes x and feeds g(x) into f :  h(x) := feed(f, g(x))  and feed a pair into it:  feed(h, <x, messages>)\n= let <y, message> = h(x)\n  in  <y, messages message>\n= let <y, message> = feed(f, g(x))\n  in  <y, messages message>\n= let <y, message> = feed(f, <x, \"called g. \">)\n  in  <y, messages message>\n= let <y, message> = let <z, msg> = f(x)\n                     in  <z, \"called g. \" msg>\n  in <y, messages message>\n= let <y, message> = let <z, msg> = <x, \"called f. \">\n                     in  <z, \"called g. \" msg>\n  in <y, messages message>\n= let <y, message> = <x, \"called g. \" \"called f. \">\n  in <y, messages message>\n= <x, messages \"called g. \" \"called f. \">\n= feed(f, <x, messages \"called g. \">)\n= feed(f, feed(g, <x, messages>))  That is the same as feeding the pair into g and feeding the resulting pair into f .  You have most of a monad. Now you just need to know about the data types in your program.  What type of value is <x, \"called f. \"> ? Well, that depends on what type of value x is. If x is of type t , then your pair is a value of type \"pair of t and string\". Call that type M t .  M is a type constructor: M alone does not refer to a type, but M _ refers to a type once you fill in the blank with a type. An M int is a pair of an int and a string. An M string is a pair of a string and a string. Etc.  Congratulations, you have created a monad!  Formally, your monad is the tuple <M, feed, wrap> .  A monad is a tuple <M, feed, wrap> where:   M is a type constructor.  feed takes a (function that takes a t and returns an M u ) and an M t and returns an M u .  wrap takes a v and returns an M v .   t , u , and v are any three types that may or may not be the same. A monad satisfies the three properties you proved for your specific monad:   Feeding a wrapped t into a function is the same as passing the unwrapped t into the function.  Formally: feed(f, wrap(x)) = f(x)  Feeding an M t into wrap does nothing to the M t .  Formally: feed(wrap, m) = m  Feeding an M t (call it m ) into a function that   passes the t into g  gets an M u (call it n ) from g  feeds n into f   is the same as   feeding m into g  getting n from g  feeding n into f   Formally: feed(h, m) = feed(f, feed(g, m)) where h(x) := feed(f, g(x))   Typically, feed is called bind (AKA >>= in Haskell) and wrap is called return . ", "question_id": 44965}, "0.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.00620438070.0062043807"], [{"answer_votes": "3", "answer_comments": null, "answer_body": " tl;dr  {-# LANGUAGE InstanceSigs #-}\n\nnewtype Id t = Id t\n\ninstance Monad Id where\n   return :: t -> Id t\n   return = Id\n\n   (=<<) :: (a -> Id b) -> Id a -> Id b\n   f =<< (Id x) = f x  Prologue  The application operator $ of functions  forall a b. a -> b  is canonically defined  ($) :: (a -> b) -> a -> b\nf $ x = f x\n\ninfixr 0 $  in terms of Haskell-primitive function application f x ( infixl 10 ). Composition . is defined in terms of $ as  (.) :: (b -> c) -> (a -> b) -> (a -> c)\nf . g = \\ x -> f $ g x\n\ninfixr 9 .  and satisfies the equivalences forall f g h.  f . id  =  f            :: c -> d   Right identity\n     id . g  =  g            :: b -> c   Left identity\n(f . g) . h  =  f . (g . h)  :: a -> d   Associativity  . is associative, and id is its right and left identity.  The Kleisli triple  In programming, a monad is functor type constructor with an instance of the monad type class. There are several equivalent variants of definition and implementation, each carrying slightly different intuitions about the monad abstraction.  A functor is a type constructor f of kind * -> * with an instance of the functor type class.  {-# LANGUAGE KindSignatures #-}\n\nclass Functor (f :: * -> *) where\n   map :: (a -> b) -> (f a -> f b)  In addition to following statically enforced type protocol, instances of the functor type class must obey the algebraic functor laws  forall f g.  map id  =  id           :: f t -> f t   Identity\nmap f . map g  =  map (f . g)  :: f a -> f c   Composition / short cut fusion  Functor computations have the type  forall f t. Functor f => f t  A computation c r consists in results  r within context  c .  Unary monadic functions or Kleisli arrows have the type  forall m a b. Functor m => a -> m b  Kleisi arrows are functions that take one argument a and return a monadic computation m b .  Monads are canonically defined in terms of the Kleisli triple  forall m. Functor m =>  (m, return, (=<<))  implemented as the type class  class Functor m => Monad m where\n   return :: t -> m t\n   (=<<)  :: (a -> m b) -> m a -> m b\n\ninfixr 1 =<<  The Kleisli identity  return is a Kleisli arrow that promotes a value t into monadic context m . Extension or Kleisli application  =<< applies a Kleisli arrow a -> m b to results of a computation m a .  Kleisli composition  <=< is defined in terms of extension as  (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)\nf <=< g = \\ x -> f =<< g x\n\ninfixr 1 <=<  <=< composes two Kleisli arrows, applying the left arrow to results of the right arrow\u2019s application.  Instances of the monad type class must obey the monad laws , most elegantly stated in terms of Kleisli composition: forall f g h.  return <=< g  =  g                :: b -> m c   Left identity\n   f <=< return  =  f                :: c -> m d   Right identity\n(f <=< g) <=< h  =  f <=< (g <=< h)  :: a -> m d   Associativity  <=< is associative, and return is its right and left identity.  Identity  The identity type  type Id t = t  is the identity function on types  Id :: * -> *  Interpreted as a functor,  return :: t -> Id t\n=      id :: t ->    t\n\n    (=<<) :: (a -> Id b) -> Id a -> Id b\n=     ($) :: (a ->    b) ->    a ->    b\n\n    (<=<) :: (b -> Id c) -> (a -> Id b) -> (a -> Id c)\n=     (.) :: (b ->    c) -> (a ->    b) -> (a ->    c)  In canonical Haskell, the identity monad is defined  newtype Id t = Id t\n\ninstance Functor Id where\n   map :: (a -> b) -> Id a -> Id b\n   map f (Id x) = Id (f x)\n\ninstance Monad Id where\n   return :: t -> Id t\n   return = Id\n\n   (=<<) :: (a -> Id b) -> Id a -> Id b\n   f =<< (Id x) = f x  Option  An option type  data Maybe t = Nothing | Just t  encodes computation Maybe t that may not yield a result t , computation that may \u201cfail\u201d. The option monad is defined  instance Functor Maybe where\n   map :: (a -> b) -> (Maybe a -> Maybe b)\n   map f (Just x) = Just (f x)\n   map _ Nothing  = Nothing\n\ninstance Monad Maybe where\n   return :: t -> Maybe t\n   return = Just\n\n   (=<<) :: (a -> Maybe b) -> Maybe a -> Maybe b\n   f =<< (Just x) = f x\n   _ =<< Nothing  = Nothing  a -> Maybe b is applied only if Maybe a yields a result.  newtype Nat = Nat Int  The natural numbers can be encoded as those integers greater than or equal to zero.  toNat :: Int -> Maybe Nat\ntoNat i | i >= 0    = Just (Nat i)\n        | otherwise = Nothing  The natural numbers are not closed under subtraction.  (-?) :: Nat -> Nat -> Maybe Nat\n(Nat n) -? (Nat m) = toNat (n - m)\n\ninfixl 6 -?  The option monad covers a basic form of exception handling.  (-? 20) <=< toNat :: Int -> Maybe Nat  List  The list monad, over the list type  data [] t = [] | t : [t]\n\ninfixr 5 :  and its additive monoid operation \u201cappend\u201d  (++) :: [t] -> [t] -> [t]\n(x : xs) ++ ys = x : xs ++ ys\n[]       ++ ys = ys\n\ninfixr 5 ++  encodes nonlinear computation [t] yielding a natural amount 0, 1, ... of results t .  instance Functor [] where\n   map :: (a -> b) -> ([a] -> [b])\n   map f (x : xs) = f x : map f xs\n   map _ []       = []\n\ninstance Monad [] where\n   return :: t -> [t]\n   return = (: [])\n\n   (=<<) :: (a -> [b]) -> [a] -> [b]\n   f =<< (x : xs) = f x ++ f =<< xs\n   _ =<< []       = []  Extension concatenates ++ all result lists [b] from applications f x of a Kleisli arrow a -> [b] to elements of [a] into a single result list [b] .  Let the proper divisors of a positive integer n be  divisors :: Integral t => t -> [t]\ndivisors n = filter (`divides` n) [2 .. n - 1]\n\ndivides :: Integral t => t -> t -> Bool\n(`divides` n) = (== 0) . (n `rem`)  then  forall n.  let f = f <=< divisors in f n  =  []  In defining the monad type class, instead of extension =<< , the Haskell standard uses its flip, the bind operator >>= .  class Applicative m => Monad m where\n   (>>=) :: forall a b. m a -> (a -> m b) -> m b\n\n   (>>) :: forall a b. m a -> m b -> m b\n   m >> k = m >>= \\ _ -> k\n   {-# INLINE (>>) #-}\n\n   return :: a -> m a\n   return = pure\n\n   fail :: String -> m a\n   fail s = errorWithoutStackTrace s  For simplicitys sake, this explanation uses the type class hierarchy  class              Functor f\nclass Functor m => Monad m  In Haskell, the current standard hierarchy is  class                  Functor f\nclass Functor p     => Applicative p\nclass Applicative m => Monad m  because not only is every monad a functor, but every applicative is a functor and every monad an applicative, too.  Using the list monad, the imperative pseudocode  for a in (1, ..., 10)\n   for b in (1, ..., 10)\n      p <- a * b\n      if even(p)\n         yield p  roughly translates to the do block  do a <- [1 .. 10]\n   b <- [1 .. 10]\n   let p = a * b\n   guard (even p)\n   return p  the equivalent monad comprehension  [p | a <- [1 .. 10], b <- [1 .. 10], let p = a * b, even p]  and the expression  [1 .. 10] >>= (\\ a ->\n   [1 .. 10] >>= (\\ b ->\n      let p = a * b in\n         guard (even p) >>\n            return p\n   )\n)  Do notation and monad comprehensions are syntactic sugar for nested bind expressions. The bind operator is used for local name binding of monadic results.  let x = v in e  =  (\\ x -> e) $ v    =  v & (\\ x -> e)\n  do r <- m; c  =  (\\ r -> c) =<< m  =  m >>= (\\ r -> c)  where  (&) :: a -> (a -> b) -> b\n(&) = flip ($)\n\ninfixl 0 &  The guard function is defined  guard :: Additive m => Bool -> m ()\nguard True  = return ()\nguard False = fail  where the unit type or \u201cempty tuple\u201d  data () = ()  Additive monads that support choice and failure can be abstracted over using a type class  class Monad m => Additive m where\n   fail  :: m t\n   (<|>) :: m t -> m t -> m t\n\ninfixl 3 <|>\n\ninstance Additive Maybe where\n   fail = Nothing\n\n   Nothing <|> m = m\n   m       <|> _ = m\n\ninstance Additive [] where\n   fail = []\n   (<|>) = (++)  where fail and <|> form a monoid forall k l m.  fail <|> l  =  l\n     k <|> fail  =  k\n(k <|> l) <|> m  =  k <|> (l <|> m)  and fail is the absorbing/annihilating zero element of additive monads  _ =<< fail  =  fail  If in  guard (even p) >> return p  even p is true, then the guard produces [()] , and, by the definition of >> , the local constant function  \\ _ -> return p  is applied to the result () . If false, then the guard produces the list monad\u2019s fail  [] , which yields no result for a Kleisli arrow to be applied >> to.  State  Infamously, monads are used to encode stateful computation.  A state processor is a function  forall st t. st -> (t, st)  that transitions a state st and yields a result t . The state  st can be anything. Nothing, flag, count, array, handle, machine, world.  The type of state processors is usually called  type State st t = st -> (t, st)  The state processor monad is the kinded * -> * functor State st . Kleisli arrows of the state processor monad are functions  forall st a b. a -> (State st) b  In canonical Haskell, the lazy version of the state processor monad is defined  newtype State st t = State { stateProc :: st -> (t, st) }\n\ninstance Functor (State st) where\n   map :: (a -> b) -> ((State st) a -> (State st) b)\n   map f (State p) = State $ \\ s0 -> let (x, s1) = p s0\n                                     in  (f x, s1)\n\ninstance Monad (State st) where\n   return :: t -> (State st) t\n   return x = State $ \\ s -> (x, s)\n\n   (=<<) :: (a -> (State st) b) -> (State st) a -> (State st) b\n   f =<< (State p) = State $ \\ s0 -> let (x, s1) = p s0\n                                     in  stateProc (f x) s1  A state processor is run by supplying an initial state:  run :: State st t -> st -> (t, st)\nrun = stateProc\n\neval :: State st t -> st -> t\neval = fst . run\n\nexec :: State st t -> st -> st\nexec = snd . run  State access is provided by primitives get and put , methods of abstraction over stateful monads:  {-# LANGUAGE MultiParamTypeClasses, FunctionalDependencies #-}\n\nclass Monad m => Stateful m st |\u00a0m -> st where\n   get :: m st\n   put :: st -> m ()  m -> st declares a functional dependency of the state type st on the monad m ; that a State t , for example, will determine the state type to be t uniquely.  instance Stateful (State st) st where\n   get :: State st st\n   get = State $ \\ s -> (s, s)\n\n   put :: st -> State st ()\n   put s = State $ \\ _ -> ((), s)  with the unit type used analogously to void in C.  modify :: Stateful m st => (st -> st) -> m ()\nmodify f = do\n   s <- get\n   put (f s)\n\ngets :: Stateful m st => (st -> t) -> m t\ngets f = do\n   s <- get\n   return (f s)  gets is often used with record field accessors.  The state monad equivalent of the variable threading  let s0 = 34\n    s1 = (+ 1) s0\n    n = (* 12) s1\n    s2 = (+ 7) s1\nin  (show n, s2)  where s0 :: Int , is the equally referentially transparent, but infinitely more elegant and practical  (flip run) 34\n   (do\n      modify (+ 1)\n      n <- gets (* 12)\n      modify (+ 7)\n      return (show n)\n   )  modify (+ 1) is a computation of type State Int () , except for its effect equivalent to return () .  (flip run) 34\n   (modify (+ 1) >>\n      gets (* 12) >>= (\\ n ->\n         modify (+ 7) >>\n            return (show n)\n      )\n   )  The monad law of associativity can be written in terms of >>=  forall m f g.  (m >>= f) >>= g  =  m >>= (\\ x -> f x >>= g)  or  do {                 do {                   do {\n   r1 <- do {           x <- m;                r0 <- m;\n      r0 <- m;   =      do {            =      r1 <- f r0;\n      f r0                 r1 <- f x;          g r1\n   };                      g r1             }\n   g r1                 }\n}                    }  Like in expression-oriented programming (e.g. Rust), the last statement of a block represents its yield. The bind operator is sometimes called a \u201cprogrammable semicolon\u201d.  Iteration control structure primitives from structured imperative programming are emulated monadically  for :: Monad m => (a -> m b) -> [a] -> m ()\nfor f = foldr ((>>) . f) (return ())\n\nwhile :: Monad m => m Bool -> m t -> m ()\nwhile c m = do\n   b <- c\n   if b then m >> while c m\n        else return ()\n\nforever :: Monad m => m t\nforever m = m >> forever m  Input/Output  data World  The I/O world state processor monad is a reconciliation of pure Haskell and the real world, of functional denotative and imperative operational semantics. A close analogue of the actual strict implementation:  type IO t = World -> (t, World)  Interaction is facilitated by impure primitives  getChar         :: IO Char\nputChar         :: Char -> IO ()\nreadFile        :: FilePath -> IO String\nwriteFile       :: FilePath -> String -> IO ()\nhSetBuffering   :: Handle -> BufferMode -> IO ()\nhTell           :: Handle -> IO Integer\n. . .              . . .  The impurity of code that uses IO primitives is permanently protocolized by the type system. Because purity is awesome, what happens in IO , stays in IO .  unsafePerformIO :: IO t -> t  Or, at least, should.  The type signature of a Haskell program  main :: IO ()\nmain = putStrLn \"Hello, World!\"  expands to  World -> ((), World)  A function that transforms a world.  Epilogue  The category whiches objects are Haskell types and whiches morphisms are functions between Haskell types is, \u201cfast and loose\u201d, the category Hask .  A functor T is a mapping from a category C to a category D ; for each object in C an object in D  Tobj :  Obj(C) -> Obj(D)\n   f :: *      -> *  and for each morphism in C a morphism in D  Tmor :  HomC(X, Y) -> HomD(Tobj(X), Tobj(Y))\n map :: (a -> b)   -> (f a -> f b)  where X , Y are objects in C . HomC(X, Y) is the homomorphism class of all morphisms X -> Y in C . The functor must preserve morphism identity and composition, the \u201cstructure\u201d of C , in D .  Tmor    Tobj\n\n      T(id)  =  id        : T(X) -> T(X)   Identity\nT(f) . T(g)  =  T(f . g)  : T(X) -> T(Z)   Composition  The Kleisli category of a category C is given by a Kleisli triple  <T, eta, _*>  of an endofunctor  T : C -> C  ( f ), an identity morphism eta ( return ), and an extension operator * ( =<< ).  Each Kleisli morphism in Hask  f :  X -> T(Y)\n      f :: a -> m b  by the extension operator  (_)* :  Hom(X, T(Y)) -> Hom(T(X), T(Y))\n  (=<<) :: (a -> m b)   -> (m a -> m b)  is given a morphism in Hask \u2019s Kleisli category  f* :  T(X) -> T(Y)\n(f =<<) :: m a  -> m b  Composition in the Kleisli category .T is given in terms of extension  f .T g  =  f* . g       :  X -> T(Z)\nf <=< g  =  (f =<<) . g  :: a -> m c  and satisfies the category axioms  eta .T g  =  g                :  Y -> T(Z)   Left identity\n   return <=< g  =  g                :: b -> m c\n\n       f .T eta  =  f                :  Z -> T(U)   Right identity\n   f <=< return  =  f                :: c -> m d\n\n  (f .T g) .T h  =  f .T (g .T h)    :  X -> T(U)   Associativity\n(f <=< g) <=< h  =  f <=< (g <=< h)  :: a -> m d  which, applying the equivalence transformations  eta .T g  =  g\n     eta* . g  =  g               By definition of .T\n     eta* . g  =  id . g          forall f.  id . f  =  f\n         eta*  =  id              forall f g h.  f . h  =  g . h  ==>  f  =  g\n\n(f .T g) .T h  =  f .T (g .T h)\n(f* . g)* . h  =  f* . (g* . h)   By definition of .T\n(f* . g)* . h  =  f* . g* . h     . is associative\n    (f* . g)*  =  f* . g*         forall f g h.  f . h  =  g . h  ==>  f  =  g  in terms of extension are canonically given  eta*  =  id                 :  T(X) -> T(X)   Left identity\n       (return =<<)  =  id                 :: m t -> m t\n\n           f* . eta  =  f                  :  Z -> T(U)      Right identity\n   (f =<<) . return  =  f                  :: c -> m d\n\n          (f* . g)*  =  f* . g*            :  T(X) -> T(Z)   Associativity\n(((f =<<) . g) =<<)  =  (f =<<) . (g =<<)  :: m a -> m c  Monads can also be defined in terms not of Kleislian extension, but a natural transformation mu , in programming called join . A monad is defined in terms of mu as a triple over a category C , of an endofunctor  T :  C -> C\n     f :: * -> *  and two natural tranformations  eta :  Id -> T\nreturn :: t  -> f t\n\n    mu :  T . T   -> T\n  join :: f (f t) -> f t  satisfying the equivalences  mu . T(mu)  =  mu . mu               :  T . T . T -> T . T   Associativity\n  join . map join  =  join . join           :: f (f (f t)) -> f t\n\n      mu . T(eta)  =  mu . eta       =  id  :  T -> T               Identity\njoin . map return  =  join . return  =  id  :: f t -> f t  The monad type class is then defined  class Functor m => Monad m where\n   return :: t -> m t\n   join   :: m (m t) -> m t  The canonical mu implementation of the option monad:  instance Monad Maybe where\n   return = Just\n\n   join (Just m) = m\n   join Nothing  = Nothing  The concat function  concat :: [[a]] -> [a]\nconcat (x : xs) = x ++ concat xs\nconcat []       = []  is the join of the list monad.  instance Monad [] where\n   return :: t -> [t]\n   return = (: [])\n\n   (=<<) :: (a -> [b]) -> ([a] -> [b])\n   (f =<<) = concat . map f  Implementations of join can be translated from extension form using the equivalence  mu  =  id*           :  T . T -> T\n   join  =  (id =<<)      :: m (m t) -> m t  The reverse translation from mu to extension form is given by  f*  =  mu . T(f)     :  T(X) -> T(Y)\n(f =<<)  =  join . map f  :: m a -> m b    Philip Wadler: Monads for functional programming  Simon L Peyton Jones, Philip Wadler: Imperative functional programming  Jonathan M. D. Hill, Keith Clarke: An introduction to category theory, category theory monads, and their relationship to functional programming \u00b4  Kleisli category  Eugenio Moggi: Notions of computation and monads  What a monad is not    But why should a theory so abstract be of any use for programming?  The answer is simple: as computer scientists, we value abstraction ! When we design the interface to a software component, we want it to reveal as little as possible about the implementation. We want to be able to replace the implementation with many alternatives, many other \u2018instances\u2019 of the same \u2018concept\u2019. When we design a generic interface to many program libraries, it is even more important that the interface we choose have a variety of implementations. It is the generality of the monad concept which we value so highly, it is because category theory is so abstract that its concepts are so useful for programming.  It is hardly suprising, then, that the generalisation of monads that we present below also has a close connection to category theory. But we stress that our purpose is very practical: it is not to \u2018implement category theory\u2019, it is to find a more general way to structure combinator libraries. It is simply our good fortune that mathematicians have already done much of the work for us!   from Generalising Monads to Arrows by John Hughes ", "question_id": 44965}, "0.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.0058165850.005816585"], [{"answer_votes": "-1", "answer_comments": [" Big Mistake : monad computation can be triggerred wo. main. \u2013 Titou  Jul 13 '15 at 13:28 "], "answer_body": " Mathematial thinking  For short: An Algebraic Structure for Combining Computations.  return data : create a computation who just simply generate a data in monad world.  (return data) >>= (return func) : The second parameter accept first parameter as a data generator and create a new computations which concatenate them.  You can think that (>>=) and return won't do any computation itself. They just simply combine and create computations.  Any monad computation will be compute if and only if main trigs it. ", "question_id": 44965}, "0.00555271240.00555271240.00555271240.00555271240.00555271240.00555271240.00555271240.00555271240.00555271240.00555271240.00555271240.00555271240.00555271240.00555271240.00555271240.00555271240.00555271240.00555271240.00555271240.00555271240.00555271240.00555271240.00555271240.0055527124"], [{"answer_votes": "8", "answer_comments": [" If you use jQuery, this explanation can be very helpful, especially if your Haskell isn't strong \u2013 byteclub  Dec 15 '10 at 16:16 ", " JQuery is emphatically not a monad. The linked article is wrong. \u2013 Tony Morris  Jun 19 '12 at 8:13 ", " Being \"emphatic\" isn't very convincing.  For some useful discussion on the topic, see Is jQuery a monad - Stack Overflow \u2013 nealmcb  Mar 25 '13 at 4:23 ", " See also Douglas Crackford's Google Talk Monads and Gonads and his Javascript code for doing modads, expanding on the similar behavior of AJAX libraries and Promises: douglascrockford/monad \u00b7 GitHub \u2013 nealmcb  Mar 25 '13 at 5:10 "], "answer_body": " In addition to the excellent answers above, let me offer you a link to the following article (by Patrick Thomson) which explains monads by relating the concept to the JavaScript library jQuery (and its way of using \"method chaining\" to manipulate the DOM): jQuery is a Monad  The jQuery documentation itself doesn't refer to the term \"monad\" but talks about the \"builder pattern\" which is probably more familiar.  This doesn't change the fact that you have a proper monad there maybe without even realizing it. ", "question_id": 44965}, "0.0039106760.0039106760.0039106760.0039106760.0039106760.0039106760.0039106760.0039106760.0039106760.0039106760.0039106760.0039106760.0039106760.0039106760.0039106760.0039106760.0039106760.0039106760.0039106760.0039106760.0039106760.0039106760.0039106760.0039106760.0039106760.0039106760.003910676"], [{"answer_votes": "8", "answer_comments": null, "answer_body": " Monads Are Not Metaphors , but a practically useful abstraction emerging from a common pattern, as Daniel Spiewak explains. ", "question_id": 44965}, "0.00312254440.00312254440.00312254440.00312254440.00312254440.00312254440.00312254440.00312254440.00312254440.00312254440.00312254440.0031225444"], [{"answer_votes": "5", "answer_comments": null, "answer_body": " In the context of Scala you will find the following to be the simplest definition. Basically flatMap (or bind) is 'associative' and there exists an identity.  trait M[+A] {\n  def flatMap[B](f: A => M[B]): M[B] // AKA bind\n\n  // Pseudo Meta Code\n  def isValidMonad: Boolean = {\n    // for every parameter the following holds\n    def isAssociativeOn[X, Y, Z](x: M[X], f: X => M[Y], g: Y => M[Z]): Boolean =\n      x.flatMap(f).flatMap(g) == x.flatMap(f(_).flatMap(g))\n\n    // for every parameter X and x, there exists an id\n    // such that the following holds\n    def isAnIdentity[X](x: M[X], id: X => M[X]): Boolean =\n      x.flatMap(id) == x\n  }\n}  E.g.  // These could be any functions\nval f: Int => Option[String] = number => if (number == 7) Some(\"hello\") else None\nval g: String => Option[Double] = string => Some(3.14)\n\n// Observe these are identical. Since Option is a Monad \n// they will always be identical no matter what the functions are\nscala> Some(7).flatMap(f).flatMap(g)\nres211: Option[Double] = Some(3.14)\n\nscala> Some(7).flatMap(f(_).flatMap(g))\nres212: Option[Double] = Some(3.14)\n\n\n// As Option is a Monad, there exists an identity:\nval id: Int => Option[Int] = x => Some(x)\n\n// Observe these are identical\nscala> Some(7).flatMap(id)\nres213: Option[Int] = Some(7)\n\nscala> Some(7)\nres214: Some[Int] = Some(7)  NOTE Strictly speaking the definition of a Monad in functional programming is not the same as the definition of a Monad in Category Theory , which is defined in turns of map and flatten .  Though they are kind of equivalent under certain mappings.  This presentations is very good: http://www.slideshare.net/samthemonad/monad-presentation-scala-as-a-category ", "question_id": 44965}, "0.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.00296535930.0029653593"], [{"answer_votes": "5", "answer_comments": null, "answer_body": " In practice, monad is a custom implementation of function composition operator that takes care of side effects and incompatible input and return values (for chaining). ", "question_id": 44965}, "0.00240445950.00240445950.00240445950.00240445950.00240445950.00240445950.00240445950.00240445950.00240445950.0024044595"], [{"answer_votes": "3", "answer_comments": [" The course doesn't exist on Coursera any more \u2013 icc97  Dec 15 '16 at 13:26 ", " That's a surprising - and v poor - reflection on Coursera. \u2013 javadba  Dec 5 '17 at 1:30 "], "answer_body": " In the Coursera \"Principles of Reactive Programming\" training - Erik Meier describes them as:  \"Monads are return types that guide you through the happy path.\" -Erik Meijer ", "question_id": 44965}, "0.00198377460.0019837746"], [{"answer_votes": "3", "answer_comments": [" See if this helps projects.tmorris.net/public/what-does-monad-mean/artifacts/1.1/\u2026 \u2013 Tony Morris  Sep 9 '10 at 22:17  ", " Google Code is going to be closed down on 2016-01-15. Most projects are now read-only, as of 2015-08-24. \u2013 Peter Mortensen  Aug 28 '15 at 17:37 "], "answer_body": " http://code.google.com/p/monad-tutorial/ is a work in progress to address exactly this question. ", "question_id": 44965}, "0.00140798730.00140798730.00140798730.00140798730.00140798730.00140798730.0014079873"]], "merge_gensim_nltk_code": null, "question": {"question_title": "What is a monad?", "question_code": [], "question_body": " Having briefly looked at Haskell recently, what would be a brief, succinct, practical explanation as to what a monad essentially is?  I have found most explanations I've come across to be fairly inaccessible and lacking in practical detail. "}, "time_now": "2018-05-21 10:58:39", "nltk_title_analyze_title_result": [[{"answer_votes": "3", "answer_comments": null, "answer_body": " tl;dr  {-# LANGUAGE InstanceSigs #-}\n\nnewtype Id t = Id t\n\ninstance Monad Id where\n   return :: t -> Id t\n   return = Id\n\n   (=<<) :: (a -> Id b) -> Id a -> Id b\n   f =<< (Id x) = f x  Prologue  The application operator $ of functions  forall a b. a -> b  is canonically defined  ($) :: (a -> b) -> a -> b\nf $ x = f x\n\ninfixr 0 $  in terms of Haskell-primitive function application f x ( infixl 10 ). Composition . is defined in terms of $ as  (.) :: (b -> c) -> (a -> b) -> (a -> c)\nf . g = \\ x -> f $ g x\n\ninfixr 9 .  and satisfies the equivalences forall f g h.  f . id  =  f            :: c -> d   Right identity\n     id . g  =  g            :: b -> c   Left identity\n(f . g) . h  =  f . (g . h)  :: a -> d   Associativity  . is associative, and id is its right and left identity.  The Kleisli triple  In programming, a monad is functor type constructor with an instance of the monad type class. There are several equivalent variants of definition and implementation, each carrying slightly different intuitions about the monad abstraction.  A functor is a type constructor f of kind * -> * with an instance of the functor type class.  {-# LANGUAGE KindSignatures #-}\n\nclass Functor (f :: * -> *) where\n   map :: (a -> b) -> (f a -> f b)  In addition to following statically enforced type protocol, instances of the functor type class must obey the algebraic functor laws  forall f g.  map id  =  id           :: f t -> f t   Identity\nmap f . map g  =  map (f . g)  :: f a -> f c   Composition / short cut fusion  Functor computations have the type  forall f t. Functor f => f t  A computation c r consists in results  r within context  c .  Unary monadic functions or Kleisli arrows have the type  forall m a b. Functor m => a -> m b  Kleisi arrows are functions that take one argument a and return a monadic computation m b .  Monads are canonically defined in terms of the Kleisli triple  forall m. Functor m =>  (m, return, (=<<))  implemented as the type class  class Functor m => Monad m where\n   return :: t -> m t\n   (=<<)  :: (a -> m b) -> m a -> m b\n\ninfixr 1 =<<  The Kleisli identity  return is a Kleisli arrow that promotes a value t into monadic context m . Extension or Kleisli application  =<< applies a Kleisli arrow a -> m b to results of a computation m a .  Kleisli composition  <=< is defined in terms of extension as  (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)\nf <=< g = \\ x -> f =<< g x\n\ninfixr 1 <=<  <=< composes two Kleisli arrows, applying the left arrow to results of the right arrow\u2019s application.  Instances of the monad type class must obey the monad laws , most elegantly stated in terms of Kleisli composition: forall f g h.  return <=< g  =  g                :: b -> m c   Left identity\n   f <=< return  =  f                :: c -> m d   Right identity\n(f <=< g) <=< h  =  f <=< (g <=< h)  :: a -> m d   Associativity  <=< is associative, and return is its right and left identity.  Identity  The identity type  type Id t = t  is the identity function on types  Id :: * -> *  Interpreted as a functor,  return :: t -> Id t\n=      id :: t ->    t\n\n    (=<<) :: (a -> Id b) -> Id a -> Id b\n=     ($) :: (a ->    b) ->    a ->    b\n\n    (<=<) :: (b -> Id c) -> (a -> Id b) -> (a -> Id c)\n=     (.) :: (b ->    c) -> (a ->    b) -> (a ->    c)  In canonical Haskell, the identity monad is defined  newtype Id t = Id t\n\ninstance Functor Id where\n   map :: (a -> b) -> Id a -> Id b\n   map f (Id x) = Id (f x)\n\ninstance Monad Id where\n   return :: t -> Id t\n   return = Id\n\n   (=<<) :: (a -> Id b) -> Id a -> Id b\n   f =<< (Id x) = f x  Option  An option type  data Maybe t = Nothing | Just t  encodes computation Maybe t that may not yield a result t , computation that may \u201cfail\u201d. The option monad is defined  instance Functor Maybe where\n   map :: (a -> b) -> (Maybe a -> Maybe b)\n   map f (Just x) = Just (f x)\n   map _ Nothing  = Nothing\n\ninstance Monad Maybe where\n   return :: t -> Maybe t\n   return = Just\n\n   (=<<) :: (a -> Maybe b) -> Maybe a -> Maybe b\n   f =<< (Just x) = f x\n   _ =<< Nothing  = Nothing  a -> Maybe b is applied only if Maybe a yields a result.  newtype Nat = Nat Int  The natural numbers can be encoded as those integers greater than or equal to zero.  toNat :: Int -> Maybe Nat\ntoNat i | i >= 0    = Just (Nat i)\n        | otherwise = Nothing  The natural numbers are not closed under subtraction.  (-?) :: Nat -> Nat -> Maybe Nat\n(Nat n) -? (Nat m) = toNat (n - m)\n\ninfixl 6 -?  The option monad covers a basic form of exception handling.  (-? 20) <=< toNat :: Int -> Maybe Nat  List  The list monad, over the list type  data [] t = [] | t : [t]\n\ninfixr 5 :  and its additive monoid operation \u201cappend\u201d  (++) :: [t] -> [t] -> [t]\n(x : xs) ++ ys = x : xs ++ ys\n[]       ++ ys = ys\n\ninfixr 5 ++  encodes nonlinear computation [t] yielding a natural amount 0, 1, ... of results t .  instance Functor [] where\n   map :: (a -> b) -> ([a] -> [b])\n   map f (x : xs) = f x : map f xs\n   map _ []       = []\n\ninstance Monad [] where\n   return :: t -> [t]\n   return = (: [])\n\n   (=<<) :: (a -> [b]) -> [a] -> [b]\n   f =<< (x : xs) = f x ++ f =<< xs\n   _ =<< []       = []  Extension concatenates ++ all result lists [b] from applications f x of a Kleisli arrow a -> [b] to elements of [a] into a single result list [b] .  Let the proper divisors of a positive integer n be  divisors :: Integral t => t -> [t]\ndivisors n = filter (`divides` n) [2 .. n - 1]\n\ndivides :: Integral t => t -> t -> Bool\n(`divides` n) = (== 0) . (n `rem`)  then  forall n.  let f = f <=< divisors in f n  =  []  In defining the monad type class, instead of extension =<< , the Haskell standard uses its flip, the bind operator >>= .  class Applicative m => Monad m where\n   (>>=) :: forall a b. m a -> (a -> m b) -> m b\n\n   (>>) :: forall a b. m a -> m b -> m b\n   m >> k = m >>= \\ _ -> k\n   {-# INLINE (>>) #-}\n\n   return :: a -> m a\n   return = pure\n\n   fail :: String -> m a\n   fail s = errorWithoutStackTrace s  For simplicitys sake, this explanation uses the type class hierarchy  class              Functor f\nclass Functor m => Monad m  In Haskell, the current standard hierarchy is  class                  Functor f\nclass Functor p     => Applicative p\nclass Applicative m => Monad m  because not only is every monad a functor, but every applicative is a functor and every monad an applicative, too.  Using the list monad, the imperative pseudocode  for a in (1, ..., 10)\n   for b in (1, ..., 10)\n      p <- a * b\n      if even(p)\n         yield p  roughly translates to the do block  do a <- [1 .. 10]\n   b <- [1 .. 10]\n   let p = a * b\n   guard (even p)\n   return p  the equivalent monad comprehension  [p | a <- [1 .. 10], b <- [1 .. 10], let p = a * b, even p]  and the expression  [1 .. 10] >>= (\\ a ->\n   [1 .. 10] >>= (\\ b ->\n      let p = a * b in\n         guard (even p) >>\n            return p\n   )\n)  Do notation and monad comprehensions are syntactic sugar for nested bind expressions. The bind operator is used for local name binding of monadic results.  let x = v in e  =  (\\ x -> e) $ v    =  v & (\\ x -> e)\n  do r <- m; c  =  (\\ r -> c) =<< m  =  m >>= (\\ r -> c)  where  (&) :: a -> (a -> b) -> b\n(&) = flip ($)\n\ninfixl 0 &  The guard function is defined  guard :: Additive m => Bool -> m ()\nguard True  = return ()\nguard False = fail  where the unit type or \u201cempty tuple\u201d  data () = ()  Additive monads that support choice and failure can be abstracted over using a type class  class Monad m => Additive m where\n   fail  :: m t\n   (<|>) :: m t -> m t -> m t\n\ninfixl 3 <|>\n\ninstance Additive Maybe where\n   fail = Nothing\n\n   Nothing <|> m = m\n   m       <|> _ = m\n\ninstance Additive [] where\n   fail = []\n   (<|>) = (++)  where fail and <|> form a monoid forall k l m.  fail <|> l  =  l\n     k <|> fail  =  k\n(k <|> l) <|> m  =  k <|> (l <|> m)  and fail is the absorbing/annihilating zero element of additive monads  _ =<< fail  =  fail  If in  guard (even p) >> return p  even p is true, then the guard produces [()] , and, by the definition of >> , the local constant function  \\ _ -> return p  is applied to the result () . If false, then the guard produces the list monad\u2019s fail  [] , which yields no result for a Kleisli arrow to be applied >> to.  State  Infamously, monads are used to encode stateful computation.  A state processor is a function  forall st t. st -> (t, st)  that transitions a state st and yields a result t . The state  st can be anything. Nothing, flag, count, array, handle, machine, world.  The type of state processors is usually called  type State st t = st -> (t, st)  The state processor monad is the kinded * -> * functor State st . Kleisli arrows of the state processor monad are functions  forall st a b. a -> (State st) b  In canonical Haskell, the lazy version of the state processor monad is defined  newtype State st t = State { stateProc :: st -> (t, st) }\n\ninstance Functor (State st) where\n   map :: (a -> b) -> ((State st) a -> (State st) b)\n   map f (State p) = State $ \\ s0 -> let (x, s1) = p s0\n                                     in  (f x, s1)\n\ninstance Monad (State st) where\n   return :: t -> (State st) t\n   return x = State $ \\ s -> (x, s)\n\n   (=<<) :: (a -> (State st) b) -> (State st) a -> (State st) b\n   f =<< (State p) = State $ \\ s0 -> let (x, s1) = p s0\n                                     in  stateProc (f x) s1  A state processor is run by supplying an initial state:  run :: State st t -> st -> (t, st)\nrun = stateProc\n\neval :: State st t -> st -> t\neval = fst . run\n\nexec :: State st t -> st -> st\nexec = snd . run  State access is provided by primitives get and put , methods of abstraction over stateful monads:  {-# LANGUAGE MultiParamTypeClasses, FunctionalDependencies #-}\n\nclass Monad m => Stateful m st |\u00a0m -> st where\n   get :: m st\n   put :: st -> m ()  m -> st declares a functional dependency of the state type st on the monad m ; that a State t , for example, will determine the state type to be t uniquely.  instance Stateful (State st) st where\n   get :: State st st\n   get = State $ \\ s -> (s, s)\n\n   put :: st -> State st ()\n   put s = State $ \\ _ -> ((), s)  with the unit type used analogously to void in C.  modify :: Stateful m st => (st -> st) -> m ()\nmodify f = do\n   s <- get\n   put (f s)\n\ngets :: Stateful m st => (st -> t) -> m t\ngets f = do\n   s <- get\n   return (f s)  gets is often used with record field accessors.  The state monad equivalent of the variable threading  let s0 = 34\n    s1 = (+ 1) s0\n    n = (* 12) s1\n    s2 = (+ 7) s1\nin  (show n, s2)  where s0 :: Int , is the equally referentially transparent, but infinitely more elegant and practical  (flip run) 34\n   (do\n      modify (+ 1)\n      n <- gets (* 12)\n      modify (+ 7)\n      return (show n)\n   )  modify (+ 1) is a computation of type State Int () , except for its effect equivalent to return () .  (flip run) 34\n   (modify (+ 1) >>\n      gets (* 12) >>= (\\ n ->\n         modify (+ 7) >>\n            return (show n)\n      )\n   )  The monad law of associativity can be written in terms of >>=  forall m f g.  (m >>= f) >>= g  =  m >>= (\\ x -> f x >>= g)  or  do {                 do {                   do {\n   r1 <- do {           x <- m;                r0 <- m;\n      r0 <- m;   =      do {            =      r1 <- f r0;\n      f r0                 r1 <- f x;          g r1\n   };                      g r1             }\n   g r1                 }\n}                    }  Like in expression-oriented programming (e.g. Rust), the last statement of a block represents its yield. The bind operator is sometimes called a \u201cprogrammable semicolon\u201d.  Iteration control structure primitives from structured imperative programming are emulated monadically  for :: Monad m => (a -> m b) -> [a] -> m ()\nfor f = foldr ((>>) . f) (return ())\n\nwhile :: Monad m => m Bool -> m t -> m ()\nwhile c m = do\n   b <- c\n   if b then m >> while c m\n        else return ()\n\nforever :: Monad m => m t\nforever m = m >> forever m  Input/Output  data World  The I/O world state processor monad is a reconciliation of pure Haskell and the real world, of functional denotative and imperative operational semantics. A close analogue of the actual strict implementation:  type IO t = World -> (t, World)  Interaction is facilitated by impure primitives  getChar         :: IO Char\nputChar         :: Char -> IO ()\nreadFile        :: FilePath -> IO String\nwriteFile       :: FilePath -> String -> IO ()\nhSetBuffering   :: Handle -> BufferMode -> IO ()\nhTell           :: Handle -> IO Integer\n. . .              . . .  The impurity of code that uses IO primitives is permanently protocolized by the type system. Because purity is awesome, what happens in IO , stays in IO .  unsafePerformIO :: IO t -> t  Or, at least, should.  The type signature of a Haskell program  main :: IO ()\nmain = putStrLn \"Hello, World!\"  expands to  World -> ((), World)  A function that transforms a world.  Epilogue  The category whiches objects are Haskell types and whiches morphisms are functions between Haskell types is, \u201cfast and loose\u201d, the category Hask .  A functor T is a mapping from a category C to a category D ; for each object in C an object in D  Tobj :  Obj(C) -> Obj(D)\n   f :: *      -> *  and for each morphism in C a morphism in D  Tmor :  HomC(X, Y) -> HomD(Tobj(X), Tobj(Y))\n map :: (a -> b)   -> (f a -> f b)  where X , Y are objects in C . HomC(X, Y) is the homomorphism class of all morphisms X -> Y in C . The functor must preserve morphism identity and composition, the \u201cstructure\u201d of C , in D .  Tmor    Tobj\n\n      T(id)  =  id        : T(X) -> T(X)   Identity\nT(f) . T(g)  =  T(f . g)  : T(X) -> T(Z)   Composition  The Kleisli category of a category C is given by a Kleisli triple  <T, eta, _*>  of an endofunctor  T : C -> C  ( f ), an identity morphism eta ( return ), and an extension operator * ( =<< ).  Each Kleisli morphism in Hask  f :  X -> T(Y)\n      f :: a -> m b  by the extension operator  (_)* :  Hom(X, T(Y)) -> Hom(T(X), T(Y))\n  (=<<) :: (a -> m b)   -> (m a -> m b)  is given a morphism in Hask \u2019s Kleisli category  f* :  T(X) -> T(Y)\n(f =<<) :: m a  -> m b  Composition in the Kleisli category .T is given in terms of extension  f .T g  =  f* . g       :  X -> T(Z)\nf <=< g  =  (f =<<) . g  :: a -> m c  and satisfies the category axioms  eta .T g  =  g                :  Y -> T(Z)   Left identity\n   return <=< g  =  g                :: b -> m c\n\n       f .T eta  =  f                :  Z -> T(U)   Right identity\n   f <=< return  =  f                :: c -> m d\n\n  (f .T g) .T h  =  f .T (g .T h)    :  X -> T(U)   Associativity\n(f <=< g) <=< h  =  f <=< (g <=< h)  :: a -> m d  which, applying the equivalence transformations  eta .T g  =  g\n     eta* . g  =  g               By definition of .T\n     eta* . g  =  id . g          forall f.  id . f  =  f\n         eta*  =  id              forall f g h.  f . h  =  g . h  ==>  f  =  g\n\n(f .T g) .T h  =  f .T (g .T h)\n(f* . g)* . h  =  f* . (g* . h)   By definition of .T\n(f* . g)* . h  =  f* . g* . h     . is associative\n    (f* . g)*  =  f* . g*         forall f g h.  f . h  =  g . h  ==>  f  =  g  in terms of extension are canonically given  eta*  =  id                 :  T(X) -> T(X)   Left identity\n       (return =<<)  =  id                 :: m t -> m t\n\n           f* . eta  =  f                  :  Z -> T(U)      Right identity\n   (f =<<) . return  =  f                  :: c -> m d\n\n          (f* . g)*  =  f* . g*            :  T(X) -> T(Z)   Associativity\n(((f =<<) . g) =<<)  =  (f =<<) . (g =<<)  :: m a -> m c  Monads can also be defined in terms not of Kleislian extension, but a natural transformation mu , in programming called join . A monad is defined in terms of mu as a triple over a category C , of an endofunctor  T :  C -> C\n     f :: * -> *  and two natural tranformations  eta :  Id -> T\nreturn :: t  -> f t\n\n    mu :  T . T   -> T\n  join :: f (f t) -> f t  satisfying the equivalences  mu . T(mu)  =  mu . mu               :  T . T . T -> T . T   Associativity\n  join . map join  =  join . join           :: f (f (f t)) -> f t\n\n      mu . T(eta)  =  mu . eta       =  id  :  T -> T               Identity\njoin . map return  =  join . return  =  id  :: f t -> f t  The monad type class is then defined  class Functor m => Monad m where\n   return :: t -> m t\n   join   :: m (m t) -> m t  The canonical mu implementation of the option monad:  instance Monad Maybe where\n   return = Just\n\n   join (Just m) = m\n   join Nothing  = Nothing  The concat function  concat :: [[a]] -> [a]\nconcat (x : xs) = x ++ concat xs\nconcat []       = []  is the join of the list monad.  instance Monad [] where\n   return :: t -> [t]\n   return = (: [])\n\n   (=<<) :: (a -> [b]) -> ([a] -> [b])\n   (f =<<) = concat . map f  Implementations of join can be translated from extension form using the equivalence  mu  =  id*           :  T . T -> T\n   join  =  (id =<<)      :: m (m t) -> m t  The reverse translation from mu to extension form is given by  f*  =  mu . T(f)     :  T(X) -> T(Y)\n(f =<<)  =  join . map f  :: m a -> m b    Philip Wadler: Monads for functional programming  Simon L Peyton Jones, Philip Wadler: Imperative functional programming  Jonathan M. D. Hill, Keith Clarke: An introduction to category theory, category theory monads, and their relationship to functional programming \u00b4  Kleisli category  Eugenio Moggi: Notions of computation and monads  What a monad is not    But why should a theory so abstract be of any use for programming?  The answer is simple: as computer scientists, we value abstraction ! When we design the interface to a software component, we want it to reveal as little as possible about the implementation. We want to be able to replace the implementation with many alternatives, many other \u2018instances\u2019 of the same \u2018concept\u2019. When we design a generic interface to many program libraries, it is even more important that the interface we choose have a variety of implementations. It is the generality of the monad concept which we value so highly, it is because category theory is so abstract that its concepts are so useful for programming.  It is hardly suprising, then, that the generalisation of monads that we present below also has a close connection to category theory. But we stress that our purpose is very practical: it is not to \u2018implement category theory\u2019, it is to find a more general way to structure combinator libraries. It is simply our good fortune that mathematicians have already done much of the work for us!   from Generalising Monads to Arrows by John Hughes ", "question_id": 44965}, 941], [{"answer_votes": "5", "answer_comments": null, "answer_body": " This answer begins with a motivating example, works through the example, derives an example of a monad, and formally defines \"monad\".  Consider these three functions in pseudocode:  f(<x, messages>) := <x, messages \"called f. \">\ng(<x, messages>) := <x, messages \"called g. \">\nwrap(x)          := <x, \"\">  f takes an ordered pair of the form <x, messages> and returns an ordered pair. It leaves the first item untouched and appends \"called f. \" to the second item. Same with g .  You can compose these functions and get your original value, along with a string that shows which order the functions were called in:  f(g(wrap(x)))\n= f(g(<x, \"\">))\n= f(<x, \"called g. \">)\n= <x, \"called g. called f. \">  You dislike the fact that f and g are responsible for appending their own log messages to the previous logging information. (Just imagine for the sake of argument that instead of appending strings, f and g must perform complicated logic on the second item of the pair. It would be a pain to repeat that complicated logic in two -- or more -- different functions.)  You prefer to write simpler functions:  f(x)    := <x, \"called f. \">\ng(x)    := <x, \"called g. \">\nwrap(x) := <x, \"\">  But look at what happens when you compose them:  f(g(wrap(x)))\n= f(g(<x, \"\">))\n= f(<<x, \"\">, \"called g. \">)\n= <<<x, \"\">, \"called g. \">, \"called f. \">  The problem is that passing a pair into a function does not give you what you want. But what if you could feed a pair into a function:  feed(f, feed(g, wrap(x)))\n= feed(f, feed(g, <x, \"\">))\n= feed(f, <x, \"called g. \">)\n= <x, \"called g. called f. \">  Read feed(f, m) as \"feed m into f \". To feed a pair <x, messages> into a function f is to pass  x into f , get <y, message> out of f , and return <y, messages message> .  feed(f, <x, messages>) := let <y, message> = f(x)\n                          in  <y, messages message>  Notice what happens when you do three things with your functions:  First: if you wrap a value and then feed the resulting pair into a function:  feed(f, wrap(x))\n= feed(f, <x, \"\">)\n= let <y, message> = f(x)\n  in  <y, \"\" message>\n= let <y, message> = <x, \"called f. \">\n  in  <y, \"\" message>\n= <x, \"\" \"called f. \">\n= <x, \"called f. \">\n= f(x)  That is the same as passing the value into the function.  Second: if you feed a pair into wrap :  feed(wrap, <x, messages>)\n= let <y, message> = wrap(x)\n  in  <y, messages message>\n= let <y, message> = <x, \"\">\n  in  <y, messages message>\n= <x, messages \"\">\n= <x, messages>  That does not change the pair.  Third: if you define a function that takes x and feeds g(x) into f :  h(x) := feed(f, g(x))  and feed a pair into it:  feed(h, <x, messages>)\n= let <y, message> = h(x)\n  in  <y, messages message>\n= let <y, message> = feed(f, g(x))\n  in  <y, messages message>\n= let <y, message> = feed(f, <x, \"called g. \">)\n  in  <y, messages message>\n= let <y, message> = let <z, msg> = f(x)\n                     in  <z, \"called g. \" msg>\n  in <y, messages message>\n= let <y, message> = let <z, msg> = <x, \"called f. \">\n                     in  <z, \"called g. \" msg>\n  in <y, messages message>\n= let <y, message> = <x, \"called g. \" \"called f. \">\n  in <y, messages message>\n= <x, messages \"called g. \" \"called f. \">\n= feed(f, <x, messages \"called g. \">)\n= feed(f, feed(g, <x, messages>))  That is the same as feeding the pair into g and feeding the resulting pair into f .  You have most of a monad. Now you just need to know about the data types in your program.  What type of value is <x, \"called f. \"> ? Well, that depends on what type of value x is. If x is of type t , then your pair is a value of type \"pair of t and string\". Call that type M t .  M is a type constructor: M alone does not refer to a type, but M _ refers to a type once you fill in the blank with a type. An M int is a pair of an int and a string. An M string is a pair of a string and a string. Etc.  Congratulations, you have created a monad!  Formally, your monad is the tuple <M, feed, wrap> .  A monad is a tuple <M, feed, wrap> where:   M is a type constructor.  feed takes a (function that takes a t and returns an M u ) and an M t and returns an M u .  wrap takes a v and returns an M v .   t , u , and v are any three types that may or may not be the same. A monad satisfies the three properties you proved for your specific monad:   Feeding a wrapped t into a function is the same as passing the unwrapped t into the function.  Formally: feed(f, wrap(x)) = f(x)  Feeding an M t into wrap does nothing to the M t .  Formally: feed(wrap, m) = m  Feeding an M t (call it m ) into a function that   passes the t into g  gets an M u (call it n ) from g  feeds n into f   is the same as   feeding m into g  getting n from g  feeding n into f   Formally: feed(h, m) = feed(f, feed(g, m)) where h(x) := feed(f, g(x))   Typically, feed is called bind (AKA >>= in Haskell) and wrap is called return . ", "question_id": 44965}, 533], [{"answer_votes": "0", "answer_comments": null, "answer_body": " Let the below \" {| a |m} \" represent some piece of monadic data. A data type which advertises an a :  (I got an a!)\n          /        \n    {| a |m}  Function, f , knows how to create a monad, if only it had an a :  (Hi f! What should I be?)\n                      /\n(You?. Oh, you'll be /\n that data there.)  /\n /                 /  (I got a b.)\n|    --------------      |\n|  /                     |\nf a                      |\n  |--later->       {| b |m}  Here we see function, f , tries to evaluate a monad but gets rebuked.  (Hmm, how do I get that a?)\n o       (Get lost buddy.\no         Wrong type.)\no       /\nf {| a |m}  Funtion, f , finds a way to extract the a by using >>= .  (Muaahaha. How you \n         like me now!?)       \n    (Better.)      \\\n        |     (Give me that a.)\n(Fine, well ok.)    |\n         \\          |\n   {| a |m}   >>=   f  Little does f know, the monad and >>= are in collusion.  (Yah got an a for me?)       \n(Yeah, but hey    | \n listen. I got    |\n something to     |\n tell you first   |\n ...)   \\        /\n         |      /\n   {| a |m}   >>=   f  But what do they actually talk about? Well, that depends on the monad. Talking solely in the abstract has limited use; you have to have some experience with particular monads to flesh out the understanding.  For instance, the data type Maybe  data Maybe a = Nothing | Just a  has a monad instance which will acts like the following...  Wherein, if the case is Just a  (Yah what is it?)       \n(... hm? Oh,      |\nforget about it.  |\nHey a, yr up.)    | \n            \\     |\n(Evaluation  \\    |\ntime already? \\   |\nHows my hair?) |  |\n      |       /   |\n      |  (It's    |\n      |  fine.)  /\n      |   /     /    \n   {| a |m}   >>=   f  But for the case of Nothing  (Yah what is it?)       \n(... There      |\nis no a. )      |\n  |        (No a?)\n(No a.)         |\n  |        (Ok, I'll deal\n  |         with this.)\n   \\            |\n    \\      (Hey f, get lost.) \n     \\          |   ( Where's my a? \n      \\         |     I evaluate a)\n       \\    (Not any more  |\n        \\    you don't.    |\n         |   We're returning\n         |   Nothing.)   /\n         |      |       /\n         |      |      /\n         |      |     /\n   {| a |m}   >>=   f      (I got a b.)\n                    |  (This is   \\\n                    |   such a     \\\n                    |   sham.) o o  \\\n                    |               o|\n                    |--later-> {| b |m}  So the Maybe monad lets a computation continue if it actually contains the a it advertises, but aborts the computation if it doesn't. The result, however is still a piece of monadic data, though not the output of f . For this reason, the Maybe monad is used to represent the context of failure.  Different monads behave differently. Lists are other types of data with monadic instances. They behave like the following:  (Ok, here's your a. Well, its\n a bunch of them, actually.)\n  |\n  |    (Thanks, no problem. Ok\n  |     f, here you go, an a.)\n  |       |\n  |       |        (Thank's. See\n  |       |         you later.)\n  |  (Whoa. Hold up f,      |\n  |   I got another         |\n  |   a for you.)           |\n  |       |      (What? No, sorry.\n  |       |       Can't do it. I \n  |       |       have my hands full\n  |       |       with all these \"b\" \n  |       |       I just made.) \n  |  (I'll hold those,      |\n  |   you take this, and   /\n  |   come back for more  /\n  |   when you're done   / \n  |   and we'll do it   / \n  |   again.)          /\n   \\      |  ( Uhhh. All right.)\n    \\     |       /    \n     \\    \\      /\n{| a |m}   >>=  f  In this case, the function knew how to make a list from it's input, but didn't know what to do with extra input and extra lists. The bind >>= , helped f out by combining the multiple outputs. I include this example to show that while >>= is responsible for extracting a , it also has access to the eventual bound output of f . Indeed, it will never extract any a unless it knows the eventual output has the same type of context.  There are other monads which are used to represent different contexts. Here's some characterizations of a few more. The IO monad doesn't actually have an a , but it knows a guy and will get that a for you. The State st monad has a secret stash of st that it will pass to f under the table, even though f just came asking for an a . The Reader r monad is similar to State st , although it only lets f look at r .  The point in all this is that any type of data which is declared itself to be a Monad is declaring some sort of context around extracting a value from the monad. The big gain from all this? Well, its easy enough to couch a calculation with some sort of context. It can get messy, however, when stringing together multiple context laden calculations. The monad operations take care of resolving the interactions of context so that the programmer doesn't have to.  Note, that use of the >>= eases a mess by by taking some of the autonomy away from f . That is, in the above case of Nothing for instance, f no longer gets to decide what to do in the case of Nothing ; it's encoded in >>= . This is the trade off. If it was necessary for f to decide what to do in the case of Nothing , then f should have been a function from Maybe a to Maybe b . In this case, Maybe being a monad is irrelevant.  Note, however, that sometimes a data type does not export it's constructors (looking at you IO), and if we want to work with the advertised value we have little choice but to work with it's monadic interface. ", "question_id": 44965}, 474], [{"answer_votes": "5", "answer_comments": null, "answer_body": " Monoid appears to be something that ensures that all operations defined on a Monoid and a supported type will always return a supported type inside the Monoid. Eg, Any number + Any number = A number, no errors.  Whereas division accepts two fractionals, and returns a fractional, which defined division by zero as Infinity in haskell somewhy(which happens to be a fractional somewhy)...  In any case, it appears Monads are just a way to ensure that your chain of operations behaves in a predictable way, and a function that claims to be Num -> Num, composed with another function of Num->Num called with x does not say, fire the missiles.  On the other hand, if we have a function which does fire the missiles, we can compose it with other functions which also fire the missiles, because our intent is clear -- we want to fire the missiles -- but it won't try printing \"Hello World\" for some odd reason.  In Haskell, main is of type IO (), or IO [()], the distiction is strange and I will not discuss it but here's what I think happens:  If I have main, I want it to do a chain of actions, the reason I run the program is to produce an effect -- usually though IO. Thus I can chain IO operations together in main in order to -- do IO, nothing else.  If I try to do something which does not \"return IO\", the program will complain that the chain does not flow, or basically \"How does this relate to what we are trying to do -- an IO action\", it appears to force the programmer to keep their train of thought, without straying off and thinking about firing the missiles, while creating algorithms for sorting -- which does not flow.  Basically, Monads appear to be a tip to the compiler that \"hey, you know this function that returns a number here, it doesn't actually always work, it can sometimes produce a Number, and sometimes Nothing at all, just keep this in mind\". Knowing this, if you try to assert a monadic action, the monadic action may act as a compile time exception saying \"hey, this isn't actually a number, this CAN be a number, but you can't assume this, do something to ensure that the flow is acceptable.\" which prevents unpredictable program behavior -- to a fair extent.  It appears monads are not about purity, nor control, but about maintaining an identity of a category on which all behavior is predictable and defined, or does not compile. You cannot do nothing when you are expected to do something, and you cannot do something if you are expected to do nothing (visible).  The biggest reason I could think of for Monads is -- go look at Procedural/OOP code, and you will notice that you do not know where the program starts, nor ends, all you see is a lot of jumping and a lot of math,magic,and missiles. You will not be able to maintain it, and if you can, you will spend quite a lot of time wrapping your mind around the whole program before you can understand any part of it, because modularity in this context is based on interdependant \"sections\" of code, where code is optimized to be as related as possible for promise of efficiency/inter-relation. Monads are very concrete, and well defined by definition, and ensure that the flow of program is possible to analyze, and isolate parts which are hard to analyze -- as they themselves are monads. A monad appears to be a \"comprehensible unit which is predictable upon its full understanding\" -- If you understand \"Maybe\" monad, there's no possible way it will do anything except be \"Maybe\", which appears trivial, but in most non monadic code, a simple function \"helloworld\" can fire the missiles, do nothing, or destroy the universe or even distort time -- we have no idea nor have any guarantees that IT IS WHAT IT IS. A monad GUARANTEES that IT IS WHAT IT IS. which is very powerful.  All things in \"real world\" appear to be monads, in the sense that it is bound by definite observable laws preventing confusion. This does not mean we have to mimic all the operations of this object to create classes, instead we can simply say \"a square is a square\", nothing but a square, not even a rectangle nor a circle, and \"a square has area of the length of one of it's existing dimensions multiplied by itself. No matter what square you have, if it's a square in 2D space, it's area absolutely cannot be anything but its length squared, it's almost trivial to prove. This is very powerful because we do not need to make assertions to make sure that our world is the way it is, we just use implications of reality to prevent our programs from falling off track.  Im pretty much guaranteed to be wrong but I think this could help somebody out there, so hopefully it helps somebody. ", "question_id": 44965}, 458], [{"answer_votes": "951", "answer_comments": [" As someone who has had a great deal of problems understanding monads, I can say that this answer helped.. a little. However, there's still some things that I don't understand. In what way is the list comprehension a monad? Is there an expanded form of that example? Another thing that really bothers me about most monad explanations, including this one- Is that they keep mixing up \"what is a monad?\" with \"what is a monad good for?\" and \"How is a monad implemented?\".  you jumped that shark when you wrote \"A monad is basically just a type that supports the >>= operator.\" Which just had me... \u2013 Breton  Aug 10 '09 at 2:00 ", " Also I disagree with your conclusion about why monads are hard. If monads themselves aren't complex, then you should be able to explain what they are without a bunch of baggage. I don't want to know about the implementation when I ask the question \"What is a monad\", I want to know what itch it's meant to be scratching. So far it seems like the answer is \"Because the authors of haskell are sadomasochists and decided that you should do something stupidly complex to accomplish simple things, so you HAVE to learn monads to use haskell, not because they're in any way useful in themselves\"... \u2013 Breton  Aug 10 '09 at 2:08 ", " But.. that can't be right, can it? I think monads are hard because nobody can seem to figure out how to explain them without getting caught up in confusing implementation details. I mean.. what is a school bus? It's a metal platform with a device in the front which consumes a refined petroleum product to drive in a cycle some metallic pistons, which in turn rotate a crank shaft attached to some gears which drive some wheels. The wheels have inflated rubber bags around them which interface with an ashphalt surface to cause a collection of seats to move forward. The seats move forward because... \u2013 Breton  Aug 10 '09 at 2:12 ", " I read all of this and still don't know what a monad is, aside from the fact that it's something Haskell programmers don't understand well enough to explain. The examples don't help much, given that these are all things one can do without monads, and this answer doesn't make it clear how monads make them any easier, only more confusing. The one part of this answer that came close to being useful was where the syntactic sugar of example #2 was removed. I say came close because, aside from the first line, the expansion doesn't bear any real resemblance to the original. \u2013 Laurence Gonsalves  Dec 19 '11 at 4:44 ", " Another problem that seems to be endemic to explanations of monads is that it's written in Haskell. I'm not saying Haskell is a bad language -- I'm saying it's a bad language for explaining monads. If I knew Haskell I'd already understand monads, so if you want to explain monads, start by using a language that people who don't know monads are more likely to understand. If you must use Haskell, don't use the syntactic sugar at all -- use the smallest, simplest subset of the language you can, and don't assume an understanding of Haskell IO. \u2013 Laurence Gonsalves  Dec 19 '11 at 4:50 "], "answer_body": " First: The term monad is a bit vacuous if you are not a mathematician. An alternative term is computation builder which is a bit more descriptive of what they are actually useful for.  You ask for practical examples:  Example 1: List comprehension :  [x*2 | x<-[1..10], odd x]  This expression returns the doubles of all odd numbers in the range from 1 to 10. Very useful!  It turns out this is really just syntactic sugar for some operations within the List monad. The same list comprehension can be written as:  do\n   x <- [1..10]\n   if odd x \n       then [x * 2] \n       else []  Or even:  [1..10] >>= (\\x -> if odd x then [x*2] else [])  Example 2: Input/Output :  do\n   putStrLn \"What is your name?\"\n   name <- getLine\n   putStrLn (\"Welcome, \" ++ name ++ \"!\")  Both examples use monads, AKA computation builders. The common theme is that the monad chains operations in some specific, useful way. In the list comprehension, the operations are chained such that if an operation returns a list, then the following operations are performed on every item in the list. The IO monad on the other hand performs the operations sequentially, but passes a \"hidden variable\" along, which represents \"the state of the world\", which allows us to write I/O code in a pure functional manner.  It turns out the pattern of chaining operations is quite useful and is used for lots of different things in Haskell.  Another example is exceptions: Using the Error monad, operations are chained such that they are performed sequentially, except if an error is thrown, in which case the rest of the chain is abandoned.  Both the list-comprehension syntax and the do-notation are syntactic sugar for chaining operations using the >>= operator. A monad is basically just a type that supports the >>= operator.  Example 3: A parser  This is a very simple parser which parses either a quoted string or a number:  parseExpr = parseString <|> parseNumber\n\nparseString = do\n        char '\"'\n        x <- many (noneOf \"\\\"\")\n        char '\"'\n        return (StringValue x)\n\nparseNumber = do\n    num <- many1 digit\n    return (NumberValue (read num))  The operations char , digit , etc. are pretty simple. They either match or don't match. The magic is the monad which manages the control flow: The operations are performed sequentially until a match fails, in which case the monad backtracks to the latest <|> and tries the next option. Again, a way of chaining operations with some additional, useful semantics.  Example 4: Asynchronous programming  The above examples are in Haskell, but it turns out F# also supports monads. This example is stolen from Don Syme :  let AsyncHttp(url:string) =\n    async {  let req = WebRequest.Create(url)\n             let! rsp = req.GetResponseAsync()\n             use stream = rsp.GetResponseStream()\n             use reader = new System.IO.StreamReader(stream)\n             return reader.ReadToEnd() }  This method fetches a web page. The punch line is the use of GetResponseAsync - it actually waits for the response on a separate thread, while the main thread returns from the function. The last three lines are executed on the spawned thread when the response have been received.  In most other languages you would have to explicitly create a separate function for the lines that handle the response. The async monad is able to \"split\" the block on its own and postpone the execution of the latter half. (The async {} syntax indicates that the control flow in the block is defined by the async monad.)  How they work  So how can a monad do all these fancy control-flow thing? What actually happens in a do-block (or a computation expression as they are called in F#), is that every operation (basically every line) is wrapped in a separate anonymous function. These functions are then combined using the bind operator (spelled >>= in Haskell). Since the bind operation combines functions, it can execute them as it sees fit: sequentially, multiple times, in reverse, discard some, execute some on a separate thread when it feels like it and so on.  As an example, this is the expanded version of the IO-code from example 2:  putStrLn \"What is your name?\"\n>>= (\\_ -> getLine)\n>>= (\\name -> putStrLn (\"Welcome, \" ++ name ++ \"!\"))  This is uglier, but it's also more obvious what is actually going on. The >>= operator is the magic ingredient: It takes a value (on the left side) and combines it with a function (on the right side), to produce a new value. This new value is then taken by the next >>= operator and again combined with a function to produce a new value. >>= can be viewed as a mini-evaluator.  Note that >>= is overloaded for different types, so every monad has its own implementation of >>= . (All the operations in the chain have to be of the type of the same monad though, otherwise the >>= operator won't work.)  The simplest possible implementation of >>= just takes the value on the left and applies it to the function on the right and returns the result, but as said before, what makes the whole pattern useful is when there is something extra going on in the monad's implementation of >>= .  There is some additional cleverness in how the values are passed from one operation to the next, but this requires a deeper explanation of the Haskell type system.  Summing up  In Haskell-terms a monad is a parameterized type which is an instance of the Monad type class, which defines >>= along with a few other operators. In layman's terms, a monad is just a type for which the >>= operation is defined.  In itself >>= is just a cumbersome way of chaining functions, but with the presence of the do-notation which hides the \"plumbing\", the monadic operations turns out to be a very nice and useful abstraction, useful many places in the language, and useful for creating your own mini-languages in the language.  Why are monads hard?  For many Haskell-learners, monads are an obstacle they hit like a brick wall. It's not that monads themselves are complex, but that the implementation relies on many other advanced Haskell features like parameterized types, type classes, and so on. The problem is that Haskell I/O is based on monads, and I/O is probably one of the first things you want to understand when learning a new language - after all, it's not much fun to create programs which don't produce any output. I have no immediate solution for this chicken-and-egg problem, except treating I/O like \"magic happens here\" until you have enough experience with other parts of language. Sorry.  Excellent blog on monads: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html ", "question_id": 44965}, 403], [{"answer_votes": "28", "answer_comments": [" \"...but I hope others find it useful\" it was indeed useful for me, despite of all the emphasized sentences :D \u2013 ftor  Oct 19 '16 at 17:50 ", " This is the most concise and clear explanation of monads I've ever read/watched/heard.  Thank you! \u2013 James  Nov 7 '16 at 2:04 ", " There is important difference between Monad and Monoid. Monad is a rule to \"compose\" functions between different types, so they do not form a binary operation as required for Monoids, see here for more details: stackoverflow.com/questions/2704652/\u2026 \u2013 Dmitri Zaitsev  Nov 18 '16 at 16:51 ", " Yes. You are correct. Your article was over my head :). However, I found this treatment very helpful (and added it to mine as a direction to others). Thanks your the heads up: stackoverflow.com/a/7829607/1612190 \u2013 George  Nov 21 '16 at 7:44 ", " You might have confused Algebraic group theory with Category theory where Monad is coming from. The former is the theory of algebraic groups, which is unrelated. \u2013 Dmitri Zaitsev  Mar 1 '17 at 12:19 "], "answer_body": " I wrote this mostly for me but I hope others find it useful :)  In Summary  A monad is merely custom function composition utilizing a wrapping type to hold stateful/meta information that guides the composition. Interestingly, imperative execution is itself function composition wherein the wrapping type holds whether an exception has occurred, the presence of which aborts further composition. The monadic laws serve to ensure a monad only performs the equivalent of function composition over the wrapped value.  A Little Context  Imperative code is a sequence of instructions performed consecutively while functional code is actually an expression whose order of evaluation is ultimately on an as needed basis. Consequently, an imperative program evaluates each statement fully before proceeding to the next one while a functional program catalogs any preceding subexpression then evaluates the last one to generate a result, at which point any necessary preceding subexpressions are evaluated. (Most functional languages do resolve subexpressions into values as they are encountered with a few, notably Haskell, being the exception).  What Does That Have To Do With Monads  It turns out that imperative evaluation and \"expression\" evaluation are equivalent. Namely, the performance of an evaluation of an expression at any specific time can be described as the sequential evaluation of its subexpressions. Similarly, any sequential execution of statements can be considered an instance of such an expression being evaluated especially if you generalize the notion of return value to be any modification to the application state as oppose to merely formal return values. To the point, all imperative code can be considered a specific ordered evaluation of some equivalent expression (over the application state).  Still, What Does All That Have To Do With Monads  An expression is a composition of functions and a monad is a technique for customizing the composition of functions. Per convention, it is a function called, bind , that composes (binds) two functions ( bind f g = (x) => g(f x) ) within some umbrella type that holds a context or state guiding the binding process. This context allows the associated implementation of bind to massage the composition. In the case of, Result 'a , context that hold an error message or a actual value it would permit the bind to log errors of the preceding result and aborts or continue the composition with a default value, depending on design. Selective application of the subsequent function to be composed is the key facility of monads in that the application process is not blind, unlike silly imperative code. :)  In a monad, the functions to be composed are defined to receive a non-monadic or unwrapped value but return a monadic or wrapped value. An example of one such naturally occurring function is the division operator ( / ) which accepts numbers but may return undefined if the divisor is 0 . Since undefined is not a number, \\ , actually returns a type whose value range is large than a number since it includes all numbers plus undefined .  I suspect this asymmetry, where operators require valid values but may return invalid ones, is a key pragmatic aspect of monads that make them useful but difficult to explain and justify; while imperative coders accept constant result checking as a necessary evil, functional coders use bind over a suitable wrapper type to detect and manage exceptions or invalid results  While being a composition function, nonetheless, for pragmatic reasons bind is described as receiving the result of the first function, a wrapped value, that it then selectively applies to the second function whose result it then collects and returns as its result. Consequently, binds can themselves be composed.  For a complex example, a monad can take a sequence of asynchronous results as a preceding value and apply each to the provided composing function in parallel with respect to the available processors, then collect and return their results as they occur, for instance. All this functionality is in that specific implementation of that monad's bind function; however, there are typically ancillary functions that cooperate, in particular lift with wraps a value into a default instance of the monadic type such as, lift 1 = Just 1 in the case of the Maybe monad, for participation in monadic expressions. (In Haskell, a monad is strongly associated with the wrapper type because monads are implemented using its type class mechanisms whereas in F# the implementation uses defined computations expression instances)  Are you saying that...  ...a monad is just custom function composition using a wrapping type to hold stateful information that the bind or composing function or operator uses in determining whether and how to perform the application of the next function. Yep.  What About The Monadic Laws?  The monadic laws only seek to ensure that a monad implementation only performs the equivalent of function composition over the wrapped type. It does that by ensuring certain equivalences hold per the expectation of composing those two functions over the wrapped type.  That's it I think. Hope it helps some.  I believe this is nice a nice treatment in another StackOverflow of response . ", "question_id": 44965}, 334], [{"answer_votes": "36", "answer_comments": [" Sequencing isn't the only reason to define a monad.  A monad is just any functor which has bind and return.  Bind and return give you sequencing.  But they give other things as well.  Also, note that your favorite imperative language is effectively a fancy IO monad with OO classes.  Making it easy to define monads means it's easy to use the interpreter pattern -- define a dsl as a monad and interpret it! \u2013 nomen  May 17 '14 at 16:40  ", " Here is an implementation: github.com/brianspinos777/Programming_cheat_sheets/blob/master/\u2026 \u2013 Brian Joseph Spinos  Dec 21 '17 at 21:20  "], "answer_body": " After much striving, I think I finally understand the monad. After rereading my own lengthy critique of the overwhelmingly top voted answer, I will offer this explanation.  There are three questions that need to be answered to understand monads:   Why do you need a monad?  What is a monad?  How is a monad implemented?   As I noted in my original comments, too many monad explanations get caught up in question number 3, without, and before really adequately covering question 2, or question 1.  Why do you need a monad?  Pure functional languages like Haskell are different from imperative languages like C, or Java in that, a pure functional program is not necessarily executed in a specific order, one step at a time. A Haskell program is more akin to a mathematical function, in which you may solve the \"equation\" in any number of potential orders. This confers a number of benefits, among which is that it eliminates the possibility of certain kinds of bugs, particularly those relating to things like \"state\".  However, there are certain problems that are not so straightforward to solve with this style of programming. Some things, like console programming, and file i/o, need things to happen in a particular order, or need to maintain state. One way to deal with this problem is to create a kind of object that represents the state of a computation, and a series of functions that take a state object as input, and return a new modified state object.  So let's create a hypothetical \"state\" value, that represents the state of a console screen. exactly how this value is constructed is not important, but let's say it's an array of byte length ascii characters that represents what is currently visible on the screen, and an array that represents the last line of input entered by the user, in pseudocode. We've defined some functions that take console state, modify it, and return a new console state.  consolestate MyConsole = new consolestate;  So to do console programming, but in a pure functional manner, you would need to nest a lot of function calls inside eachother.  consolestate FinalConsole = print(input(print(myconsole, \"Hello, what's your name?\")),\"hello, %inputbuffer%!\");  Programming in this way keeps the \"pure\" functional style, while forcing changes to the console to happen in a particular order. But, we'll probably want to do more than just a few operations at a time like in the above example. Nesting functions in that way will start to become ungainly. What we want, is code that does essentially the same thing as above, but is written a bit more like this:  consolestate FinalConsole = myconsole:\n                            print(\"Hello, what's your name?\"):\n                            input():\n                            print(\"hello, %inputbuffer%!\");  This would indeed be a more convenient way to write it. How do we do that though?  What is a monad?  Once you have a type (such as consolestate ) that you define along with a bunch of functions designed specifically to operate on that type, you can turn the whole package of these things into a \"monad\" by defining an operator like : (bind) that automatically feeds return values on its left, into function parameters on its right, and a lift operator that turns normal functions, into functions that work with that specific kind of bind operator.  How is a monad implemented?  See other answers, that seem quite free to jump into the details of that. ", "question_id": 44965}, 311], [{"answer_votes": "43", "answer_comments": [" Sometimes an explanation from a \"learner\" (like you) is more relevant to another learner than an explanation coming from an expert. Learners think alike :) \u2013 Adrian  Dec 7 '10 at 18:48 ", " What makes something a monad is the existence of a function with type M (M a) -> M a . The fact that you can turn that into one of type M a -> (a -> M b) -> M b is what makes them useful. \u2013 Jeremy List  Aug 19 '14 at 5:58 ", " \"monad\" roughly means \"pattern\" ... no. \u2013 user633183  May 19 '16 at 5:55 "], "answer_body": " [Disclaimer: I am still trying to fully grok monads. The following is just what I have understood so far. If it\u2019s wrong, hopefully someone knowledgeable will call me on the carpet.]  Arnar wrote:   Monads are simply a way to wrapping things and provide methods to do operations on the wrapped stuff without unwrapping it.   That\u2019s precisely it. The idea goes like this:   You take some kind of value and wrap it with some additional information. Just like the value is of a certain kind (eg. an integer or a string), so the additional information is of a certain kind.  E.g., that extra information might be a Maybe or an IO .  Then you have some operators that allow you to operate on the wrapped data while carrying along that additional information. These operators use the additional information to decide how to change the behaviour of the operation on the wrapped value.  E.g., a Maybe Int can be a Just Int or Nothing . Now, if you add a Maybe Int to a Maybe Int , the operator will check to see if they are both Just Int s inside, and if so, will unwrap the Int s, pass them the addition operator, re-wrap the resulting Int into a new Just Int (which is a valid Maybe Int ), and thus return a Maybe Int . But if one of them was a Nothing inside, this operator will just immediately return Nothing , which again is a valid Maybe Int . That way, you can pretend that your Maybe Int s are just normal numbers and perform regular math on them. If you were to get a Nothing , your equations will still produce the right result \u2013 without you having to litter checks for Nothing everywhere .   But the example is just what happens for Maybe . If the extra information was an IO , then that special operator defined for IO s would be called instead, and it could do something totally different before performing the addition. (OK, adding two IO Int s together is probably nonsensical \u2013 I\u2019m not sure yet.) (Also, if you paid attention to the Maybe example, you have noticed that \u201cwrapping a value with extra stuff\u201d is not always correct. But it\u2019s hard to be exact, correct and precise without being inscrutable.)  Basically, \u201cmonad\u201d roughly means \u201cpattern\u201d . But instead of a book full of informally explained and specifically named Patterns, you now have a language construct \u2013 syntax and all \u2013 that allows you to declare new patterns as things in your program . (The imprecision here is all the patterns have to follow a particular form, so a monad is not quite as generic as a pattern. But I think that\u2019s the closest term that most people know and understand.)  And that is why people find monads so confusing: because they are such a generic concept. To ask what makes something a monad is similarly vague as to ask what makes something a pattern.  But think of the implications of having syntactic support in the language for the idea of a pattern: instead of having to read the Gang of Four book and memorise the construction of a particular pattern, you just write code that implements this pattern in an agnostic, generic way once and then you are done! You can then reuse this pattern, like Visitor or Strategy or Fa\u00e7ade or whatever, just by decorating the operations in your code with it, without having to re-implement it over and over!  So that is why people who understand monads find them so useful : it\u2019s not some ivory tower concept that intellectual snobs pride themselves on understanding (OK, that too of course, teehee), but actually makes code simpler. ", "question_id": 44965}, 275], [{"answer_votes": "625", "answer_comments": [" I appreciate your answer\u2014especially the final concession that all of this is of course possible too without monads. One point to be made is that it's mostly easier with monads, but it's often not as efficient as doing it without them. Once you need to involve transformers, the extra layering of function calls (and function objects created) has a cost that's hard to see and control, rendered invisible by clever syntax. \u2013 seh  Apr 20 '12 at 16:35 ", " In Haskell at least, most of the overhead of monads gets stripped away by the optimiser. So the only real \"cost\" is in brain power required. (This is not insignificant if \"maintainability\" is something you care about.) But usually, monads make things easier , not harder. (Otherwise, why would you bother?) \u2013 MathematicalOrchid  Apr 21 '12 at 18:40 ", " I'm not sure whether or not Haskell supports this but mathematically you can define a monad either in terms of >>= and return or join and ap. >>= and return are what make monads practically useful but join and ap give a more intuitive understanding of what a monad is. \u2013 Jeremy List  Apr 2 '14 at 10:57 ", " Coming from a non-math, non-functional programming background, this answer made the most sense to me. \u2013 jrahhali  Aug 2 '17 at 23:55 ", " This is the first answer that actually gave me some idea of what the hell a monad is. Thank you for finding a way to explain it! \u2013 robotmay  Aug 14 '17 at 23:48 "], "answer_body": " Explaining \"what is a monad\" is a bit like saying \"what is a number?\" We use numbers all the time. But imagine you met someone who didn't know anything about numbers. How the heck would you explain what numbers are? And how would you even begin to describe why that might be useful?  What is a monad? The short answer: It's a specific way of chaining operations together.  In essence, you're writing execution steps and linking them together with the \"bind function\". (In Haskell, it's named >>= .) You can write the calls to the bind operator yourself, or you can use syntax sugar which makes the compiler insert those function calls for you. But either way, each step is separated by a call to this bind function.  So the bind function is like a semicolon; it separates the steps in a process. The bind function's job is to take the output from the previous step, and feed it into the next step.  That doesn't sound too hard, right? But there is more than one kind of monad. Why? How?  Well, the bind function can just take the result from one step, and feed it to the next step. But if that's \"all\" the monad does... that actually isn't very useful. And that's important to understand: Every useful monad does something else in addition to just being a monad. Every useful monad has a \"special power\", which makes it unique.  (A monad that does nothing special is called the \"identity monad\". Rather like the identity function, this sounds like an utterly pointless thing, yet turns out not to be... But that's another story\u2122.)  Basically, each monad has its own implementation of the bind function. And you can write a bind function such that it does hoopy things between execution steps. For example:   If each step returns a success/failure indicator, you can have bind execute the next step only if the previous one succeeded. In this way, a failing step aborts the whole sequence \"automatically\", without any conditional testing from you. (The Failure Monad .)  Extending this idea, you can implement \"exceptions\". (The Error Monad or Exception Monad .) Because you're defining them yourself rather than it being a language feature, you can define how they work. (E.g., maybe you want to ignore the first two exceptions and only abort when a third exception is thrown.)  You can make each step return multiple results , and have the bind function loop over them, feeding each one into the next step for you. In this way, you don't have to keep writing loops all over the place when dealing with multiple results. The bind function \"automatically\" does all that for you. (The List Monad .)  As well as passing a \"result\" from one step to another, you can have the bind function pass extra data around as well. This data now doesn't show up in your source code, but you can still access it from anywhere, without having to manually pass it to every function. (The Reader Monad .)  You can make it so that the \"extra data\" can be replaced. This allows you to simulate destructive updates , without actually doing destructive updates. (The State Monad and its cousin the Writer Monad .)  Because you're only simulating destructive updates, you can trivially do things that would be impossible with real destructive updates. For example, you can undo the last update , or revert to an older version .  You can make a monad where calculations can be paused , so you can pause your program, go in and tinker with internal state data, and then resume it.  You can implement \"continuations\" as a monad. This allows you to break people's minds!   All of this and more is possible with monads. Of course, all of this is also perfectly possible without monads too. It's just drastically easier using monads. ", "question_id": 44965}, 270], [{"answer_votes": "2", "answer_comments": [" here is an implementation: github.com/brianspinos777/Programming_cheat_sheets/blob/master/\u2026 \u2013 Brian Joseph Spinos  Dec 21 '17 at 21:23 ", " IOW, Monad is generalized function call protocol. \u2013 Will Ness  Jan 28 at 16:09 ", " You answer is the most helpful in my opinion. Although I have to say that I think the emphasis needs to be on the fact that the functions you're refering to don't just involve values in contexts, they actively put values in contexts.  So for example, a function, f :: m a -> m b would very easily compose with another function, g :: m b -> m c.  But monads (bind specifically) allows us to perpetually compose functions which put their input in the same context, without us needing to take the value out of that context first (which would effectively remove information from the value) \u2013 James  Mar 23 at 18:41  ", " @James I think that should be the emphasis for functors? \u2013 Jonas  Mar 24 at 5:03 ", " @Jonas I guess I didn't explain propperly.   When I say that the functions put values in contexts, I mean that they have type (a -> m b). These are very useful since putting a value into a context adds new information to it but it would usually be difficult to chain a (a -> m b) and a (b -> m c) together since we can't just take the value out of the context. So we would have to use some convoluted process to chain these functions together in a sensible way depending on the specific context and monads just allow us to do this in a consistent way, regardless of the context. \u2013 James  Mar 24 at 16:23 "], "answer_body": " I will try to explain Monad in the context of Haskell.  In functional programming, function composition is important. It allows our program to consist of small, easy-to-read functions.  Let's say we have two functions: g :: Int -> String and f :: String -> Bool .  We can do (f . g) x , which is just the same as f (g x) , where x is an Int value.  When doing composition/applying the result of one function to another, having the types match up is important. In the above case, the type of the result returned by g must be the same as the type accepted by f .  But sometimes values are in contexts, and this makes it a bit less easy to line up types. (Having values in contexts is very useful. For example, the Maybe Int type represents an Int value that may not be there, the IO String type represents a String value that is there as a result of performing some side effects.)  Let's say we now have g1 :: Int -> Maybe String and f1 :: String -> Maybe Bool . g1 and f1 are very similar to g and f respectively.  We can't do (f1 . g1) x or f1 (g1 x) , where x is an Int value. The type of the result returned by g1 is not what f1 expects.  We could compose f and g with the . operator, but now we can't compose f1 and g1 with . . The problem is that we can't straightforwardly pass a value in a context to a function that expects a value that is not in a context.  Wouldn't it be nice if we introduce an operator to compose g1 and f1 , such that we can write (f1 OPERATOR g1) x ? g1 returns a value in a context. The value will be taken out of context and applied to f1 . And yes, we have such an operator. It's <=< .  We also have the >>= operator that does for us the exact same thing, though in a slightly different syntax.  We write: g1 x >>= f1 . g1 x is a Maybe Int value. The >>= operator helps take that Int value out of the \"perhaps-not-there\" context, and apply it to f1 . The result of f1 , which is a Maybe Bool , will be the result of the entire >>= operation.  And finally, why is Monad useful? Because Monad is the type class that defines the >>= operator, very much the same as the Eq type class that defines the == and /= operators.  To conclude, the Monad type class defines the >>= operator that allows us to pass values in a context (we call these monadic values) to functions that don't expect values in a context. The context will be taken care of.  If there is one thing to remember here, it is that Monad s allow function composition that involves values in contexts . ", "question_id": 44965}, 211], [{"answer_votes": "2", "answer_comments": null, "answer_body": " Another attempt at explaining monads, using just Python lists and the map function. I fully accept this isn't a full explanation, but I hope it gets at the core concepts.  I got the basis of this from the funfunfunction video on Monads and the Learn You A Haskell chapter 'For a Few Monads More' . I highly recommend watching the funfunfunction video.  At it's very simplest, Monads are objects that have a map and flatMap functions ( bind in Haskell). There are some extra required properties , but these are the core ones.  flatMap 'flattens' the output of map, for lists this just concatenates the values of the list e.g.  concat([[1], [4], [9]]) = [1, 4, 9]  So in Python we can very basically implement a Monad with just these two functions:  def flatMap(func, lst):\n    return concat(map(func, lst))\n\ndef concat(lst):\n    return sum(lst, [])  func is any function that takes a value and returns a list e.g.  lambda x: [x*x]  Explanation  For clarity I created the concat function in Python via a simple function , which sums the lists i.e. [] + [1] + [4] + [9] = [1, 4, 9] (Haskell has a native concat method).  I'm assuming you know what the map function is e.g.:  >>> list(map(lambda x: [x*x], [1,2,3]))\n[[1], [4], [9]]  Flattening is the key concept of Monads and for each object which is a Monad this flattening allows you to get at the value that is wrapped in the Monad.  Now we can call:  >>> flatMap(lambda x: [x*x], [1,2,3])\n[1, 4, 9]  This lambda is taking a value x and putting it into a list. A monad works with any function that goes from a value to a type of the monad, so a list in this case.  That's your monad defined .  I think the question of why they're useful has been answered in other questions.  More explanation  Other examples that aren't lists are JavaScript Promises, which have the then method and JavaScript Streams which have a flatMap method.  So Promises and Streams use a slightly different function which flattens out a Stream or a Promise and returns the value from within.  The Haskell list monad has the following definition:  instance Monad [] where  \n    return x = [x]  \n    xs >>= f = concat (map f xs)  \n    fail _ = []  i.e. there are three functions return (not to be confused with return in most other languages), >>= (the flatMap ) and fail .  Hopefully you can see the similarity between:  xs >>= f = concat (map f xs)  and:  def flatMap(f, xs):\n    return concat(map(f, xs)) ", "question_id": 44965}, 193], [{"answer_votes": "2", "answer_comments": null, "answer_body": " Essentially , and Practically , monads allow callback nesting (with a mutually-recursively-threaded state (pardon the hyphens)) (in a composable (or decomposable) fashion) (with type safety (sometimes (depending on the language))) )))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))  E.G. this is NOT a monad:  //JavaScript is 'Practical'\nvar getAllThree = \n         bind(getFirst, function(first){  \n  return bind(getSecond,function(second){  \n  return bind(getThird, function(third){  \n    var fancyResult = // And now make do fancy \n                      // with first, second,\n                      // and third \n    return RETURN(fancyResult);\n  });});});  But monads enable such code. The monad is actually the set of types for:  {bind,RETURN,maybe others I don't know...} . Which is essentially inessential, and practically impractical.  So now I can use it:  var fancyResultReferenceOutsideOfMonad =  \n  getAllThree(someKindOfInputAcceptableToOurGetFunctionsButProbablyAString);  \n\n//Ignore this please, throwing away types, yay JavaScript:\n//  RETURN = K\n//  bind = \\getterFn,cb -> \n//    \\in -> let(result,newState) = getterFn(in) in cb(result)(newState)  Or Break it up:  var getFirstTwo = \n           bind(getFirst, function(first){  \n    return bind(getSecond,function(second){  \n      var fancyResult2 = // And now make do fancy \n                         // with first and second\n      return RETURN(fancyResult2);\n    });})\n  , getAllThree = \n           bind(getFirstTwo, function(fancyResult2){  \n    return bind(getThird,    function(third){  \n      var fancyResult3 = // And now make do fancy \n                         // with fancyResult2,\n                         // and third \n      return RETURN(fancyResult3);\n    });});  Or ignore certain results:  var getFirstTwo = \n           bind(getFirst, function(first){  \n    return bind(getSecond,function(second){  \n      var fancyResult2 = // And now make do fancy \n                         // with first and second\n      return RETURN(fancyResult2);\n    });})\n  , getAllThree = \n           bind(getFirstTwo, function(____dontCare____NotGonnaUse____){  \n    return bind(getThird,    function(three){  \n      var fancyResult3 = // And now make do fancy \n                         // with `three` only!\n      return RETURN(fancyResult3);\n    });});  Or simplify a trivial case from:  var getFirstTwo = \n           bind(getFirst, function(first){  \n    return bind(getSecond,function(second){  \n      var fancyResult2 = // And now make do fancy \n                         // with first and second\n      return RETURN(fancyResult2);\n    });})\n  , getAllThree = \n           bind(getFirstTwo, function(_){  \n    return bind(getThird,    function(three){  \n      return RETURN(three);\n    });});  To (using \"Right Identity\" ):  var getFirstTwo = \n           bind(getFirst, function(first){  \n    return bind(getSecond,function(second){  \n      var fancyResult2 = // And now make do fancy \n                         // with first and second\n      return RETURN(fancyResult2);\n    });})\n  , getAllThree = \n           bind(getFirstTwo, function(_){  \n    return getThird;\n    });  Or jam them back together:  var getAllThree = \n           bind(getFirst, function(first_dontCareNow){  \n    return bind(getSecond,function(second_dontCareNow){  \n    return getThird;\n    });});  The practicality of these abilities doesn't really emerge, or become clear until you try to solve really messy problems like parsing, or module/ajax/resource loading.  Can you imagine thousands of lines of indexOf/subString logic? What if frequent parsing steps were contained in little functions? Functions like chars , spaces , upperChars , or digits ? And what if those functions gave you the result in a callback, without having to mess with Regex groups, and arguments.slice? And what if their composition/decomposition was well understood? Such that you could build big parsers from the bottom up?  So the ability to manage nested callback scopes is incredibly practical , especially when working with monadic parser combinator libraries. (that is to say, in my experience)  DON'T GET HUNG UP ON: - CATEGORY-THEORY - MAYBE-MONADS - MONAD LAWS - HASKELL - !!!! ", "question_id": 44965}, 192], [{"answer_votes": "69", "answer_comments": [" slight addition to def of 'higher order function': they can take OR RETURN functions. That's why they are 'higher' 'cos they do things with themselves. \u2013 Kevin Won  Jan 30 '10 at 6:31  ", " By that definition, addition is a higher-order function. It takes a number and returns a function that adds that number to another. So no, higher order functions are strictly functions whose domain consists of functions. \u2013 Apocalisp  Jan 30 '10 at 16:58  ", " The video ' Brian Beckman: Don't fear the Monad ' follows this same line of logic. \u2013 icc97  Oct 10 '16 at 5:29 "], "answer_body": " You should first understand what a functor is. Before that, understand higher-order functions.  A higher-order function is simply a function that takes a function as an argument.  A functor is any type construction T for which there exists a higher-order function, call it map , that transforms a function of type a -> b (given any two types a and b ) into a function T a -> T b . This map function must also obey the laws of identity and composition such that the following expressions return true for all x , p , and q (Haskell notation):  map id = id\nmap (p . q) = map p . map q  For example, a type constructor called List is a functor if it comes equipped with a function of type (a -> b) -> List a -> List b which obeys the laws above. The only practical implementation is obvious. The resulting List a -> List b function iterates over the given list, calling the (a -> b) function for each element, and returns the list of the results.  A monad is essentially just a functor T with two extra methods, join , of type T (T a) -> T a , and unit (sometimes called return , fork , or pure ) of type a -> T a . For lists in Haskell:  join :: [[a]] -> [a]\npure :: a -> [a]  Why is that useful? Because you could, for example, map over a list with a function that returns a list. Join takes the resulting list of lists and concatenates them. List is a monad because this is possible.  You can write a function that does map , then join . This function is called bind , or flatMap , or (>>=) , or (=<<) . This is normally how a monad instance is given in Haskell.  A monad has to satisfy certain laws, namely that join must be associative. This means that if you have a value x of type [[[a]]] then join (join x) should equal join (map join x) . And pure must be an identity for join such that join (pure x) == x . ", "question_id": 44965}, 181], [{"answer_votes": "24", "answer_comments": null, "answer_body": " Monads are to control flow what abstract data types are to data.  In other words, many developers are comfortable with the idea of Sets, Lists, Dictionaries (or Hashes, or Maps), and Trees. Within those data types there are many special cases (for instance InsertionOrderPreservingIdentityHashMap).  However, when confronted with program \"flow\" many developers haven't been exposed to many more constructs than if, switch/case, do, while, goto (grr), and (maybe) closures.  So, a monad is simply a control flow construct. A better phrase to replace monad would be 'control type'.  As such, a monad has slots for control logic, or statements, or functions - the equivalent in data structures would be to say that some data structures allow you to add data, and remove it.  For example, the \"if\" monad:  if( clause ) then block  at its simplest has two slots - a clause, and a block. The if monad is usually built to evaluate the result of the clause, and if not false, evaluate the block. Many developers are not introduced to monads when they learn 'if', and it just isn't necessary to understand monads to write effective logic.  Monads can become more complicated, in the same way that data structures can become more complicated, but there are many broad categories of monad that may have similar semantics, but differing implementations and syntax.  Of course, in the same way that data structures may be iterated over, or traversed, monads may be evaluated.  Compilers may or may not have support for user-defined monads. Haskell certainly does. Ioke has some similar capabilities, although the term monad is not used in the language. ", "question_id": 44965}, 167], [{"answer_votes": "162", "answer_comments": [" -> is right-associative, mirroring function application, which is left-associative, so leaving the parentheses out doesn't make a difference here. \u2013 Matthias Benkard  Oct 11 '08 at 16:06 ", " Your explanation did the trick for me. I would have added though a limited summing of some standard monads (reader, state, maybe, ...) to illustrate some practical uses and wrappings \u2013 Rabarberski  Apr 27 '09 at 8:36 ", " I don't think this is a very good explanation at all. Monads are simply A way? okay, which way? Why wouldn't I encapsulate using a class instead of a monad? \u2013 Breton  Nov 6 '10 at 22:14 ", " A longer explanation of this idea: blog.sigfpe.com/2007/04/trivial-monad.html \u2013 sdcvvc  Jan 25 '12 at 16:26  ", " @mb21: In case you're just pointing out that there are too many brackets, note that a->b->c is actually only short for a->(b->c). Writing this particular example as (a -> b) -> (Ta -> Tb) is strictly speaking just adding unncessary characters, but it's morally \"the right thing to do\" as it emphasises that fmap maps a function of type a -> b to a function of type Ta -> Tb. And originally, that's what functors do in category theory and that's where monads come from. \u2013 Nikolaj-K  Jul 21 '14 at 14:36  "], "answer_body": " Actually, contrary to common understanding of Monads, they have nothing to do with state. Monads are simply a way to wrapping things and provide methods to do operations on the wrapped stuff without unwrapping it.  For example, you can create a type to wrap another one, in Haskell:  data Wrapped a = Wrap a  To wrap stuff we define  return :: a -> Wrapped a\nreturn x = Wrap x  To perform operations without unwrapping, say you have a function f :: a -> b , then you can do this to lift that function to act on wrapped values:  fmap :: (a -> b) -> (Wrapped a -> Wrapped b)\nfmap f (Wrap x) = Wrap (f x)  That's about all there is to understand. However, it turns out that there is a more general function to do this lifting , which is bind :  bind :: (a -> Wrapped b) -> (Wrapped a -> Wrapped b)\nbind f (Wrap x) = f x  bind can do a bit more than fmap , but not vice versa. Actually, fmap can be defined only in terms of bind and return . So, when defining a monad.. you give its type (here it was Wrapped a ) and then say how its return and bind operations work.  The cool thing is that this turns out to be such a general pattern that it pops up all over the place, encapsulating state in a pure way is only one of them.  For a good article on how monads can be used to introduce functional dependencies and thus control order of evaluation, like it is used in Haskell's IO monad, check out IO Inside .  As for understanding monads, don't worry too much about it. Read about them what you find interesting and don't worry if you don't understand right away. Then just diving in a language like Haskell is the way to go. Monads are one of these things where understanding trickles into your brain by practice, one day you just suddenly realize you understand them. ", "question_id": 44965}, 153], [{"answer_votes": "162", "answer_comments": [" \u2026best way not only on the internet, but anywhere. (Wadler's original paper Monads for functional programming that I mentioned in my answer below is also good.) None of the zillions of tutorials-by-analogy come close. \u2013 ShreevatsaR  Apr 30 '11 at 15:14 ", " This JavaScript translation of Sigfpe's post is the new best way to learn monads, for people who don't already grok advanced Haskell! \u2013 Sam Watkins  Jan 6 '14 at 2:55  ", " This is how I learned what a monad is. Walking the reader through the process of inventing a concept is often the best way to teach the concept. \u2013 Jordan  Mar 8 '15 at 5:58 ", " However, a function accepting the screen object as argument and returning its copy with text modified would be pure. \u2013 Dmitri Zaitsev  May 20 '16 at 12:09 "], "answer_body": " But, You could have invented Monads!   sigfpe says:   But all of these introduce monads as something esoteric in need of explanation. But what I want to argue is that they aren't esoteric at all. In fact, faced with various problems in functional programming you would have been led, inexorably, to certain solutions, all of which are examples of monads. In fact, I hope to get you to invent them now if you haven't already. It's then a small step to notice that all of these solutions are in fact the same solution in disguise. And after reading this, you might be in a better position to understand other documents on monads because you'll recognise everything you see as something you've already invented.  Many of the problems that monads try to solve are related to the issue of side effects. So we'll start with them. (Note that monads let you do more than handle side-effects, in particular many types of container object can be viewed as monads. Some of the introductions to monads find it hard to reconcile these two different uses of monads and concentrate on just one or the other.)  In an imperative programming language such as C++, functions behave nothing like the functions of mathematics. For example, suppose we have a C++ function that takes a single floating point argument and returns a floating point result. Superficially it might seem a little like a mathematical function mapping reals to reals, but a C++ function can do more than just return a number that depends on its arguments. It can read and write the values of global variables as well as writing output to the screen and receiving input from the user. In a pure functional language, however, a function can only read what is supplied to it in its arguments and the only way it can have an effect on the world is through the values it returns.   ", "question_id": 44965}, 142], [{"answer_votes": "9", "answer_comments": null, "answer_body": " I've been thinking of Monads in a different way, lately. I've been thinking of them as abstracting out execution order in a mathematical way, which makes new kinds of polymorphism possible.  If you're using an imperative language, and you write some expressions in order, the code ALWAYS runs exactly in that order.  And in the simple case, when you use a monad, it feels the same -- you define a list of expressions that happen in order. Except that, depending on which monad you use, your code might run in order (like in IO monad), in parallel over several items at once (like in the List monad), it might halt partway through (like in the Maybe monad), it might pause partway through to be resumed later (like in a Resumption monad), it might rewind and start from the beginning (like in a Transaction monad), or it might rewind partway to try other options (like in a Logic monad).  And because monads are polymorphic, it's possible to run the same code in different monads, depending on your needs.  Plus, in some cases, it's possible to combine monads together (with monad transformers) to get multiple features at the same time. ", "question_id": 44965}, 118], [{"answer_votes": "77", "answer_comments": [" What exactly do you mean by \"maps a function over it\"? \u2013 Casebash  Mar 14 '10 at 6:24 ", " Casebash, I'm being deliberately informal in the introduction. See the examples near the end to get a sense of what \"mapping a function\" entails. \u2013 Chris Conway  Mar 14 '10 at 14:54 ", " Monad is not a datatype. It is a rule of composing functions: stackoverflow.com/a/37345315/1614973 \u2013 Dmitri Zaitsev  May 20 '16 at 12:16 "], "answer_body": " A monad is a datatype that has two operations: >>= (aka bind ) and return (aka unit ). return takes an arbitrary value and creates an instance of the monad with it. >>= takes an instance of the monad and maps a function over it. (You can see already that a monad is a strange kind of datatype, since in most programming languages you couldn't write a function that takes an arbitrary value and creates a type from it. Monads use a kind of parametric polymorphism .)  In Haskell notation, the monad interface is written  class Monad m where\n  return :: a -> m a\n  (>>=) :: forall a b . m a -> (a -> m b) -> m b  These operations are supposed to obey certain \"laws\", but that's not terrifically important: the \"laws\" just codify the way sensible implementations of the operations ought to behave (basically, that >>= and return ought to agree about how values get transformed into monad instances and that >>= is associative).  Monads are not just about state and I/O: they abstract a common pattern of computation that includes working with state, I/O, exceptions, and non-determinism. Probably the simplest monads to understand are lists and option types:  instance Monad [ ] where\n    []     >>= k = []\n    (x:xs) >>= k = k x ++ (xs >>= k)\n    return x     = [x]\n\ninstance Monad Maybe where\n    Just x  >>= k = k x\n    Nothing >>= k = Nothing\n    return x      = Just x  where [] and : are the list constructors, ++ is the concatenation operator, and Just and Nothing are the Maybe constructors. Both of these monads encapsulate common and useful patterns of computation on their respective data types (note that neither has anything to do with side effects or I/O).  You really have to play around writing some non-trivial Haskell code to appreciate what monads are about and why they are useful. ", "question_id": 44965}, 107], [{"answer_votes": "34", "answer_comments": [" The only problem with Wadler's paper is the notation is different but I agree that the paper is pretty compelling and a clear concise motivation for applying monads. \u2013 Jared Updike  Jul 31 '09 at 22:34 ", " +1 for the \"monad tutorial fallacy\". Tutorials on monads are akin to having several tutorials trying to explain the concept of integer numbers. One tutorial would say, \"1 is similar to an apple\"; another tutorial says, \"2 is like a pear\"; a third one says, \"3 is basically an orange\". But you never get the whole picture from any single tutorial. What I've taken from that is that monads are an abstract concept which can be used for many quite different purposes. \u2013 stakx  Jan 14 '11 at 7:30  ", " @stakx: Yes, true. But I didn't mean that monads are an abstraction that you cannot learn or shouldn't learn; only that it's best to learn it after you've seen enough concrete examples to perceive a single underlying abstraction. See my other answer here . \u2013 ShreevatsaR  Jan 14 '11 at 12:22 ", " Sometimes I feel that there are so many tutorials that try to convince the reader that monads are useful by using code that do complicated or useful stuff. That hindered my understanding for months. I don't learn that way. I prefer to see extremely simple code, doing something stupid that I can mentally go through and I couldn't find this kind of example. I can't learn if the first example is a monad to parse a complicate grammar. I can learn if it's a monad to sum integers. \u2013 Rafael S. Calsaverini  Jan 23 '11 at 23:11  ", " Mentioning only type constructor is incomplete: stackoverflow.com/a/37345315/1614973 \u2013 Dmitri Zaitsev  May 20 '16 at 12:18 "], "answer_body": " (See also the answers at What is a monad? )  A good motivation to Monads is sigfpe (Dan Piponi)'s You Could Have Invented Monads! (And Maybe You Already Have) . There are a LOT of other monad tutorials , many of which misguidedly try to explain monads in \"simple terms\" using various analogies: this is the monad tutorial fallacy ; avoid them.  As DR MacIver says in Tell us why your language sucks :   So, things I hate about Haskell:   Let\u2019s start with the obvious. Monad tutorials. No, not monads. Specifically the tutorials. They\u2019re endless, overblown and dear god are they tedious. Further, I\u2019ve never seen any convincing evidence that they actually help. Read the class definition, write some code, get over the scary name.  You say you understand the Maybe monad? Good, you're on your way. Just start using other monads and sooner or later you'll understand what monads are in general.  [If you are mathematically oriented, you might want to ignore the dozens of tutorials and learn the definition, or follow lectures in category theory :)\nThe main part of the definition is that a Monad M involves a \"type constructor\" that defines for each existing type \"T\" a new type \"M T\", and some ways for going back and forth between \"regular\" types and \"M\" types.]  Also, surprisingly enough, one of the best introductions to monads is actually one of the early academic papers introducing monads, Philip Wadler's Monads for functional programming . It actually has practical, non-trivial motivating examples, unlike many of the artificial tutorials out there. ", "question_id": 44965}, 106], [{"answer_votes": "2", "answer_comments": [" You seem to be the only one who finally addressed my main problem with understanding Monads. Nobody ever talks about HOW can the value be extracted. Is it implementation dependant? \u2013 Vinicius Seufitele  Aug 22 '12 at 16:39 ", " @ViniciusSeufitele, thanks for your comment. I'm afraid that my understanding hasn't advanced a great deal since I wrote this answer, so I can't really add much. The value extraction logically has to exist, so maybe that's why nobody bothers to mention it. \u2013 Benjol  Aug 23 '12 at 5:45 ", " I have a discussion that treats the monad as a type expansion where the original type, b, is converted to an expanded type M<b> and the associated operators are wrapped to now service M<b>. These wrappers are what will handle the peculiarities of the monad. In particular, extracting the original type from the expanded type and passing it to it's wrapped operator and subsequently promoting the result. The benefit of the monad is that you retain simple declarative expressions. In my treatment I discussed expanding the numeric types system to include a DivByZero value to obviate the need to check \u2013 George  Oct 13 '14 at 16:45 ", " @ViniciusSeufitele , yes it is implementation dependent. The person writing the function >>= has access to the internals of the monad. For example see Maybe Monad and look for instance Monad Maybe . You'll see that when the left hand side is Just x then we return k x . The pattern matching does the unwrap for you. Something analogous happens in every monad implementation. \u2013 Michael Welch  Feb 3 '15 at 16:59  "], "answer_body": " Princess 's explanation of F# Computation Expressions helped me, though I still can't say I've really understood.  EDIT : this series - explaining monads with javascript - is the one that 'tipped the balance' for me.   http://blog.jcoglan.com/2011/03/05/translation-from-haskell-to-javascript-of-selected-portions-of-the-best-introduction-to-monads-ive-ever-read/  http://blog.jcoglan.com/2011/03/06/monad-syntax-for-javascript/  http://blog.jcoglan.com/2011/03/11/promises-are-the-monad-of-asynchronous-programming/   I think that understanding monads is something that creeps up on you. In that sense, reading as many 'tutorials' as you can is a good idea, but often strange stuff (unfamiliar language or syntax) prevents your brain from concentrating on the essential.  Some things that I had difficulty understanding:   Rules-based explanations never worked for me, because most practical examples actually require more than just return/bind.  Also, calling them rules didn't help. It is more a case of \"there are these things that have something in common, let's call the things 'monads', and the bits in common 'rules'\".  Return ( a -> M<a> ) and Bind ( M<a> -> (a -> M<b>) -> M<b> ) are great, but what I could never understand is HOW Bind could extract the a from M<a> in order to pass it into a -> M<b> . I don't think I've ever read anywhere (maybe it's obvious to everyone else), that the reverse of Return ( M<a> -> a ) has to exist inside the monad, it just doesn't need to be exposed.  ", "question_id": 44965}, 103], [{"answer_votes": "-1", "answer_comments": null, "answer_body": " Explanation  It's quite simple, when explained in C#/Java terms:   A monad is a function that takes arguments and returns a special type.  The special type that this monad returns is also called monad. (A monad is a combination of #1 and #2)  There's some syntactic sugar to make calling this function and conversion of types easier.   Example  A monad is useful to make the life of the functional programmer easier. The typical example: The Maybe monad takes two parameters, a value and a function. It returns null if the passed value is null . Otherwise it evaluates the function. If we needed a special return type, we would call this return type Maybe as well. A very crude implementation would look like this:  object Maybe(object value, Func<object,object> function)\n{\n    if(value==null)\n        return null;\n\n    return function(value);\n}  This is spectacularly useless in C# because this language lacks the required syntactic sugar to make monads useful. But monads allow you to write more concise code in functional programming languages.  Oftentimes programmers call monads in chains, like so:  var x = Maybe(x, x2 => Maybe(y, y2 => Add(x2, y2)));  In this example the Add method would only be called if x and y are both non- null , otherwise null will be returned.  Answer  To answer the original question: A monad is a function AND a type. Like an implementation of a special interface . ", "question_id": 44965}, 100], [{"answer_votes": "30", "answer_comments": [" Monads weren't 'designed', they were applied from one domain (category theory) to another (I/O in purely functional programming languages). Did Newton 'design' the calculus? \u2013 Jared Updike  Jul 31 '09 at 22:40 ", " Point 1 and 2 above are correct and useful. Points 4 and 5 are sort of ad hominem, even if more or less true. They don't really help explain monads. \u2013 Jared Updike  Jul 31 '09 at 22:42 ", " Re: 4, 5: The \"Secret handshake\" thing is a red herring. Programming is full of jargon. Haskell just happens to call stuff what it is without pretending to rediscover something. If it exists in mathematics already, why make up a new name for it? The name is really not the reason people don't get monads; they are a subtle concept. The average person probably understands addition and multiplication, why don't they get the concept of an Abelian Group? Because it is more abstract and general and that person hasn't done the work to wrap their head around the concept. A name change wouldn't help. \u2013 Jared Updike  Jul 31 '09 at 22:53 ", " Sigh... I'm not making an attack on Haskell ... I was making a joke.  So, I don't really get the bit about being \"ad hominem\".  Yes, the calculus was \"designed\". That's why, for example, calculus students are taught the Leibniz notation, rather than the icky stuff Netwton used. Better design.  Good names help understanding a lot. If I called Abelian Groups \"distended wrinkle pods\", you may have trouble understanding me.  You might be saying \"but that name is nonsense\", no one would ever call them that.  To people who have never heard of category theory \"monad\" sounds like nonsense. \u2013 Scott Wisniewski  Aug 1 '09 at 1:21 ", " @Scott: sorry if my extensive comments made it seem I was getting defensive about Haskell. I enjoy your humor about the secret handshake and you will note I said it is more or less true. :-) If you called Abelian Groups \"distended wrinkle pods\" you would be making the same mistake of trying to give monads a \"better name\" (cf. F# \"computation expressions\"): the term exists and people who care know what monads are, but not what \"warm fuzzy things\" are (or \"computation expressions\"). If I understand your use of the term \"type operator\" correctly there are lots of other type operators than monads. \u2013 Jared Updike  Aug 3 '09 at 23:27 "], "answer_body": " A monad is, effectively, a form of \"type operator\". It will do three things. First it will \"wrap\" (or otherwise convert) a value of one type into another type (typically called a \"monadic type\"). Secondly it will make all the operations (or functions) available on the underlying type available on the monadic type. Finally it will provide support for combining its self with another monad to produce a composite monad.  The \"maybe monad\" is essentially the equivalent of \"nullable types\" in Visual Basic / C#. It takes a non nullable type \"T\" and converts it into a \"Nullable<T>\", and then defines what all the binary operators mean on a Nullable<T>.  Side effects are represented simillarly. A structure is created that holds descriptions of side effects alongside a function's return value. The \"lifted\" operations then copy around side effects as values are passed between functions.  They are called \"monads\" rather than the easier-to-grasp name of \"type operators\" for several reasons:   Monads have restrictions on what they can do (see the definiton for details).  Those restrictions, along with the fact that there are three operations involved, conform to the structure of something called a monad in Category Theory, which is an obscure branch of mathematics.  They were designed by proponents of \"pure\" functional languages  Proponents of pure functional languages like obscure branches of mathematics  Because the math is obscure, and monads are associated with particular styles of programming, people tend to use the word monad as a sort of secret handshake. Because of this no one has bothered to invest in a better name.  ", "question_id": 44965}, 92], [{"answer_votes": "14", "answer_comments": null, "answer_body": " My favorite Monad tutorial:  http://www.haskell.org/haskellwiki/All_About_Monads  (out of 170,000 hits on a Google search for \"monad tutorial\"!)  @Stu: The point of monads is to allow you to add (usually) sequential semantics to otherwise pure code; you can even compose monads (using Monad Transformers) and get more interesting and complicated combined semantics, like parsing with error handling, shared state, and logging, for example. All of this is possible in pure code, monads just allow you to abstract it away and reuse it in modular libraries (always good in programming), as well as providing convenient syntax to make it look imperative.  Haskell already has operator overloading[1]: it uses type classes much the way one might use interfaces in Java or C# but Haskell just happens to also allow non-alphanumeric tokens like + && and > as infix identifiers. It's only operator overloading in your way of looking at it if you mean \"overloading the semicolon\" [2]. It sounds like black magic and asking for trouble to \"overload the semicolon\" (picture enterprising Perl hackers getting wind of this idea) but the point is that without monads there is no semicolon, since purely functional code does not require or allow explicit sequencing.  This all sounds much more complicated than it needs to. sigfpe's article is pretty cool but uses Haskell to explain it, which sort of fails to break the chicken and egg problem of understanding Haskell to grok Monads and understanding Monads to grok Haskell.  [1] This is a separate issue from monads but monads use Haskell's operator overloading feature.  [2] This is also an oversimplification since the operator for chaining monadic actions is >>= (pronounced \"bind\") but there is syntactic sugar (\"do\") that lets you use braces and semicolons and/or indentation and newlines. ", "question_id": 44965}, 90], [{"answer_votes": "2", "answer_comments": [" Lenses, not Monads, are a way for functional programmers to use imperative code without actually admitting it. \u2013 OleTraveler  Oct 18 '12 at 19:31 "], "answer_body": " Explaining monads seems to be like explaining control-flow statements. Imagine that a non-programmer asks you to explain them?  You can give them an explanation involving the theory - Boolean Logic, register values, pointers, stacks, and frames. But that would be crazy.  You could explain them in terms of the syntax. Basically all control-flow statements in C have curly brackets, and you can distinguish the condition and the conditional code by where they are relative to the brackets. That may be even crazier.  Or you could also explain loops, if statements, routines, subroutines, and possibly co-routines.  Monads can replace a fairly large number of programming techniques. There's a specific syntax in languages that support them, and some theories about them.  They are also a way for functional programmers to use imperative code without actually admitting it, but that's not their only use. ", "question_id": 44965}, 76], [{"answer_votes": "9", "answer_comments": [" The python examples made it easy to comprehend! Thanks for sharing. \u2013 Ryan Efendy  Mar 2 at 17:50 "], "answer_body": " I am still new to monads, but I thought I would share a link I found that felt really good to read (WITH PICTURES!!): http://www.matusiak.eu/numerodix/blog/2012/3/11/monads-for-the-layman/ (no affiliation)  Basically, the warm and fuzzy concept that I got from the article was the concept that monads are basically adapters that allow disparate functions to work in a composable fashion, i.e. be able to string up multiple functions and mix and match them without worrying about inconsistent return types and such. So the BIND function is in charge of keeping apples with apples and oranges with oranges when we're trying to make these adapters. And the LIFT function is in charge of taking \"lower level\" functions and \"upgrading\" them to work with BIND functions and be composable as well.  I hope I got it right, and more importantly, hope that the article has a valid view on monads. If nothing else, this article helped whet my appetite for learning more about monads. ", "question_id": 44965}, 75], [{"answer_votes": "0", "answer_comments": null, "answer_body": " If you are asking for a succinct, practical explanation for something so abstract, then you can only hope for an abstract answer:  a -> b  is one way of representing a computation from a s to b s. You can chain computations, aka compose them together:  (b -> c) -> (a -> b) -> (a -> c)  More complex computations demand more complex types, e.g.:  a -> f b  is the type of computations from a s to b s that are into f s. You can also compose them:  (b -> f c) -> (a -> f b) -> (a -> f c)  It turns out this pattern appears literally everywhere and has the same properties as the first composition above (associativity, right- and left-identity).  One had to give this pattern a name, but then would it help to know that the first composition is formally characterised as a Semigroupoid ?  \"Monads are just as interesting and important as parentheses\" (Oleg Kiselyov) ", "question_id": 44965}, 65], [{"answer_votes": "5", "answer_comments": null, "answer_body": " In the context of Scala you will find the following to be the simplest definition. Basically flatMap (or bind) is 'associative' and there exists an identity.  trait M[+A] {\n  def flatMap[B](f: A => M[B]): M[B] // AKA bind\n\n  // Pseudo Meta Code\n  def isValidMonad: Boolean = {\n    // for every parameter the following holds\n    def isAssociativeOn[X, Y, Z](x: M[X], f: X => M[Y], g: Y => M[Z]): Boolean =\n      x.flatMap(f).flatMap(g) == x.flatMap(f(_).flatMap(g))\n\n    // for every parameter X and x, there exists an id\n    // such that the following holds\n    def isAnIdentity[X](x: M[X], id: X => M[X]): Boolean =\n      x.flatMap(id) == x\n  }\n}  E.g.  // These could be any functions\nval f: Int => Option[String] = number => if (number == 7) Some(\"hello\") else None\nval g: String => Option[Double] = string => Some(3.14)\n\n// Observe these are identical. Since Option is a Monad \n// they will always be identical no matter what the functions are\nscala> Some(7).flatMap(f).flatMap(g)\nres211: Option[Double] = Some(3.14)\n\nscala> Some(7).flatMap(f(_).flatMap(g))\nres212: Option[Double] = Some(3.14)\n\n\n// As Option is a Monad, there exists an identity:\nval id: Int => Option[Int] = x => Some(x)\n\n// Observe these are identical\nscala> Some(7).flatMap(id)\nres213: Option[Int] = Some(7)\n\nscala> Some(7)\nres214: Some[Int] = Some(7)  NOTE Strictly speaking the definition of a Monad in functional programming is not the same as the definition of a Monad in Category Theory , which is defined in turns of map and flatten .  Though they are kind of equivalent under certain mappings.  This presentations is very good: http://www.slideshare.net/samthemonad/monad-presentation-scala-as-a-category ", "question_id": 44965}, 61], [{"answer_votes": "2", "answer_comments": null, "answer_body": " I'm trying to understand monads as well. It's my version:  Monads are about making abstractions about repetitive things. \nFirstly, monad itself is a typed interface (like an abstract generic class), that has two functions: bind and return that have defined signatures. And then, we can create concrete monads based on that abstract monad, of course with specific implementations of bind and return. Additionally, bind and return must fulfill a few invariants in order to make it possible to compose/chain concrete monads.  Why create the monad concept while we have interfaces, types, classes and other tools to create abstractions? Because monads give more: they enforce rethinking problems in a way that enables to compose data without any boilerplate. ", "question_id": 44965}, 58], [{"answer_votes": "3", "answer_comments": [" Do you mean \"what the world doesn't need ...\"? Nice analogy though! \u2013 groverboy  Jan 6 '15 at 1:36 ", " @groverboy I think there was a hint of sarcasm \u2013 icc97  Mar 7 '17 at 8:35 ", " @icc97 you're right - the meaning is clear enough. Sarcasm unintended, apologies to the author. \u2013 groverboy  Mar 14 '17 at 2:29 ", " What the world needs is another comment thread confirming a sarcasm, but if read carefully I've written but so that should make it clear. \u2013 Eugene Yokota  Mar 21 '17 at 3:26 "], "answer_body": " What the world needs is another monad blog post, but I think this is useful in identifying existing monads in the wild.   monads are fractals     The above is a fractal called Sierpinski triangle, the only fractal I can remember to draw. Fractals are self-similar structure like the above triangle, in which the parts are similar to the whole (in this case exactly half the scale as parent triangle).  Monads are fractals. Given a monadic data structure, its values can be composed to form another value of the data structure. This is why it's useful to programming, and this is why it occurrs in many situations.  ", "question_id": 44965}, 52], [{"answer_votes": "2", "answer_comments": null, "answer_body": " A very simple answer is:  Monads are an abstraction that provide an interface for encapsulating values, for computing new encapsulated values, and for unwrapping the encapsulated value.  What's convenient about them in practice is that they provide a uniform interface for creating data types that model state while not being stateful .  It's important to understand that a Monad is an abstraction , that is, an abstract interface for dealing with a certain kind of data structure. That interface is then used to build data types that have monadic behavior.  You can find a very good and practical introduction in Monads in Ruby, Part 1: Introduction . ", "question_id": 44965}, 45], [{"answer_votes": "5", "answer_comments": null, "answer_body": " The two things that helped me best when learning about there were:  Chapter 8, \"Functional Parsers,\" from Graham Hutton's book Programming in Haskell . This doesn't mention monads at all, actually, but if you can work through chapter and really understand everything in it, particularly how a sequence of bind operations is evaluated, you'll understand the internals of monads. Expect this to take several tries.  The tutorial All About Monads . This gives several good examples of their use, and I have to say that the analogy in Appendex I worked for me. ", "question_id": 44965}, 44], [{"answer_votes": "2", "answer_comments": [" As I understand, monads are more than that. Encapsulating mutable state in a \"pure\" functional languages is only one application of monads. \u2013 thSoft  Dec 30 '10 at 2:17 "], "answer_body": " A monad is a thing used to encapsulate objects that have changing state. It is most often encountered in languages that otherwise do not allow you to have modifiable state (e.g., Haskell).  An example would be for file I/O.  You would be able to use a monad for file I/O to isolate the changing state nature to just the code that used the Monad. The code inside the Monad can effectively ignore the changing state of the world outside the Monad - this makes it a lot easier to reason about the overall effect of your program. ", "question_id": 44965}, 39], [{"answer_votes": "4", "answer_comments": null, "answer_body": " If I've understood correctly, IEnumerable is derived from monads. I wonder if that might be an interesting angle of approach for those of us from the C# world?  For what it's worth, here are some links to tutorials that helped me (and no, I still haven't understood what monads are).   http://osteele.com/archives/2007/12/overloading-semicolon  http://spbhug.folding-maps.org/wiki/MonadsEn  http://www.loria.fr/~kow/monads/  ", "question_id": 44965}, 28], [{"answer_votes": "8", "answer_comments": [" If you use jQuery, this explanation can be very helpful, especially if your Haskell isn't strong \u2013 byteclub  Dec 15 '10 at 16:16 ", " JQuery is emphatically not a monad. The linked article is wrong. \u2013 Tony Morris  Jun 19 '12 at 8:13 ", " Being \"emphatic\" isn't very convincing.  For some useful discussion on the topic, see Is jQuery a monad - Stack Overflow \u2013 nealmcb  Mar 25 '13 at 4:23 ", " See also Douglas Crackford's Google Talk Monads and Gonads and his Javascript code for doing modads, expanding on the similar behavior of AJAX libraries and Promises: douglascrockford/monad \u00b7 GitHub \u2013 nealmcb  Mar 25 '13 at 5:10 "], "answer_body": " In addition to the excellent answers above, let me offer you a link to the following article (by Patrick Thomson) which explains monads by relating the concept to the JavaScript library jQuery (and its way of using \"method chaining\" to manipulate the DOM): jQuery is a Monad  The jQuery documentation itself doesn't refer to the term \"monad\" but talks about the \"builder pattern\" which is probably more familiar.  This doesn't change the fact that you have a proper monad there maybe without even realizing it. ", "question_id": 44965}, 27], [{"answer_votes": "6", "answer_comments": [" That is more like Applicative than Monad.  With Monads, you have to get data from the pipes before you can choose the next pipe to connect. \u2013 Peaker  Jul 22 '10 at 23:33 "], "answer_body": " A monad is a way of combining computations together that share a common context.  It is like building a network of pipes.  When constructing the network, there is no data flowing through it.  But when I have finished piecing all the bits together with 'bind' and 'return' then I invoke something like runMyMonad monad data and the data flows through the pipes. ", "question_id": 44965}, 25], [{"answer_votes": "-1", "answer_comments": [" Big Mistake : monad computation can be triggerred wo. main. \u2013 Titou  Jul 13 '15 at 13:28 "], "answer_body": " Mathematial thinking  For short: An Algebraic Structure for Combining Computations.  return data : create a computation who just simply generate a data in monad world.  (return data) >>= (return func) : The second parameter accept first parameter as a data generator and create a new computations which concatenate them.  You can think that (>>=) and return won't do any computation itself. They just simply combine and create computations.  Any monad computation will be compute if and only if main trigs it. ", "question_id": 44965}, 24], [{"answer_votes": "1", "answer_comments": null, "answer_body": " http://mikehadlow.blogspot.com/2011/02/monads-in-c-8-video-of-my-ddd9-monad.html  This is the video you are looking for.  Demonstrating in C# what the problem is with composition and aligning the types, and then implementing them properly in C#. \nTowards the end he displays how the same C# code looks in F# and finally in Haskell. ", "question_id": 44965}, 17], [{"answer_votes": "8", "answer_comments": null, "answer_body": " Monads Are Not Metaphors , but a practically useful abstraction emerging from a common pattern, as Daniel Spiewak explains. ", "question_id": 44965}, 12], [{"answer_votes": "5", "answer_comments": null, "answer_body": " In practice, monad is a custom implementation of function composition operator that takes care of side effects and incompatible input and return values (for chaining). ", "question_id": 44965}, 10], [{"answer_votes": "3", "answer_comments": [" See if this helps projects.tmorris.net/public/what-does-monad-mean/artifacts/1.1/\u2026 \u2013 Tony Morris  Sep 9 '10 at 22:17  ", " Google Code is going to be closed down on 2016-01-15. Most projects are now read-only, as of 2015-08-24. \u2013 Peter Mortensen  Aug 28 '15 at 17:37 "], "answer_body": " http://code.google.com/p/monad-tutorial/ is a work in progress to address exactly this question. ", "question_id": 44965}, 7], [{"answer_votes": "3", "answer_comments": [" The course doesn't exist on Coursera any more \u2013 icc97  Dec 15 '16 at 13:26 ", " That's a surprising - and v poor - reflection on Coursera. \u2013 javadba  Dec 5 '17 at 1:30 "], "answer_body": " In the Coursera \"Principles of Reactive Programming\" training - Erik Meier describes them as:  \"Monads are return types that guide you through the happy path.\" -Erik Meijer ", "question_id": 44965}, 2]], "question_id": 44965}