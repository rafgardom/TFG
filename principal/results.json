{"answers": [{"answer_votes": "824", "answer_comments": [" See also LinkedHashSet, if you wish to retain the order. \u2013 volley  Dec 9 '09 at 20:38 ", " But this will just create the set without duplicates , I want to know which number was duplicate in O(n) time \u2013 Chetan  Mar 29 '12 at 19:43 ", " @Chetan finding all duplicates from ArrayList in O(n), its important to have correctly defined equals method on objects which you have in the list (no problem for numbers): public Set<Object> findDuplicates(List<Object> list)       {           Set<Object> items = new HashSet<Object>();           Set<Object> duplicates = new HashSet<Object>();           for (Object item : list) {               if (items.contains(item)) {                   duplicates.add(item);               } else {                   items.add(item);               }           }           return duplicates;       } \u2013 Ondrej Bozek  Jun 20 '12 at 12:06  ", " A good practice would be to define variables using the interface types List and Set (instead of implementation types ArrayList and HashSet as in your example). \u2013 Jonik  Aug 29 '13 at 7:27 ", " You can clean this up by using new HashSet(al) instead of initializing it to empty and calling addAll . \u2013 ashes999  Dec 26 '13 at 12:44 "], "answer_body": " If you don't want duplicates in a Collection , you should consider why you're using a Collection that allows duplicates. The easiest way to remove repeated elements is to add the contents to a Set (which will not allow duplicates) and then add the Set back to the ArrayList :  List<String> al = new ArrayList<>();\n// add elements to al, including duplicates\nSet<String> hs = new HashSet<>();\nhs.addAll(al);\nal.clear();\nal.addAll(hs);  Of course, this destroys the ordering of the elements in the ArrayList . ", "question_id": 203984}, {"answer_votes": "258", "answer_comments": [" Does LinkedHashSet make any guarantees as to which of several duplicates are kept from the list?  For instance, if position 1, 3, and 5 are duplicates in the original list, can we assume that this process will remove 3 and 5?  Or maybe remove 1 and 3?  Thanks. \u2013 Matt Brian\u00e7on  May 1 '11 at 2:20 ", " @Matt: yes, it does guarantee that. The docs say: \"This linked list defines the iteration ordering, which is the order in which elements were inserted into the set (insertion-order). Note that insertion order is not affected if an element is re-inserted into the set.\" \u2013 abahgat  May 2 '11 at 9:00 ", " Very interesting. I have a different situation here. I am not trying to sort String but another object called AwardYearSource. This class has an int attribute called year. So I want to remove duplicates based on the year. i.e if there is year 2010 mentioned more than once, I want to remove that AwardYearSource object. How can I do that? \u2013 WowBow  Apr 16 '12 at 15:27 ", " @WowBow For example you can define Wrapper object which holds AwardYearSource. And define this Wrapper objects equals method based on AwardYearSources year field. Then you can use Set with these Wrapper objects. \u2013 Ondrej Bozek  Jun 20 '12 at 12:19 ", " @WowBow or implement Comparable/Comparator \u2013 shrini1000  Jan 11 '13 at 5:09 "], "answer_body": " Although converting the ArrayList to a HashSet effectively removes duplicates, if you need to preserve insertion order, I'd rather suggest you to use this variant  // list is some List of Strings\nSet<String> s = new LinkedHashSet<>(list);  Then, if you need to get back a List reference, you can use again the conversion constructor. ", "question_id": 203984}, {"answer_votes": "83", "answer_comments": [" very elegant. Thanks \u2013 paskos  Feb 12 '15 at 20:04 ", " How do i do this for case insensitive distinct ? \u2013 StackFlowed  Sep 13 '16 at 20:04  ", " @StackFlowed If you don't need to preserve the order of the list you can addAll to new TreeSet<String>(String.CASE_INSENSITIVE_ORDER) .  The first element added will remain in the set so if your list contains \"Dog\" and \"dog\" (in that order) the TreeSet will contain \"Dog\". If order must be preserved then before the line in the answer put list.replaceAll(String::toUpperCase); . \u2013 Paul  Nov 3 '17 at 23:28  ", " I am getting this error :incompatible types: List<Object> cannot be converted to List<String> \u2013 Samir  Apr 4 at 14:34 "], "answer_body": " In Java 8:  List<String> deduped = list.stream().distinct().collect(Collectors.toList());  Please note that the hashCode-equals contract for list members should be respected for the filtering to work properly. ", "question_id": 203984}, {"answer_votes": "48", "answer_comments": [" Similarly at the bottom of the thread, I have given an answer where I am using Set for Custom Object. In a case if anyone have custom object like \"Contact\" or \"Student\" can use that answer that works fine for me. \u2013 Muhammad Adil  Oct 25 '16 at 14:16 "], "answer_body": " If you don't want duplicates, use a Set instead of a List . To convert a List to a Set you can use the following code:  // list is some List of Strings\nSet<String> s = new HashSet<String>(list);  If really necessary you can use the same construction to convert a Set back into a List . ", "question_id": 203984}, {"answer_votes": "24", "answer_comments": [" This answer lacks two things: 1) It does not use generics, but raw types ( ArrayList<T> should be used instead of ArrayList ) 2) The explicit iterator creating can be avoided by using a for (T current : l1) { ... } . Even if you wanted to use an Iterator explicitly, iterador is misspelled. \u2013 RAnders00  Dec 7 '15 at 16:22 ", " And this implementation runs in quadratic time, compared to the linked hash set implementation running in linear time. (i.e. this takes 10 times longer on a list with 10 elements, 10,000 times longer on a list with 10,000 elements. JDK 6 implementation for ArrayList.contains , JDK8 impl is the same.) \u2013 Patrick M  Jul 11 '16 at 16:09 "], "answer_body": " Here's a way that doesn't affect your list ordering:  ArrayList l1 = new ArrayList();\nArrayList l2 = new ArrayList();\n\nIterator iterator = l1.iterator();\n\n        while (iterator.hasNext())\n        {\n            YourClass o = (YourClass) iterator.next();\n            if(!l2.contains(o)) l2.add(o);\n        }  l1 is the original list, and l2 is the list whithout repeated items\n(Make sure YourClass has the equals method acording to what you want to stand for equality) ", "question_id": 203984}, {"answer_votes": "24", "answer_comments": [" +1 for Java 8 streams. But if case-sensitivity is not required then only Java 8 solution can be easily modified. List<String> deDupStringList3 = stringList.parallelStream().map(String::toLowerCase).distinct().collect(Collectors.toList()); should work. \u2013 Diablo  Jun 10 '16 at 8:13 "], "answer_body": " Suppose we have a list of String like:  List<String> strList = new ArrayList<>(5);\n// insert up to five items to list.  Then we can remove duplicate elements in in multiple ways.  Prior to Java 8  List<String> deDupStringList = new ArrayList<>(new HashSet<>(strList));  Using Guava  List<String> deDupStringList2 = Lists.newArrayList(Sets.newHashSet(strList));  Using Java 8  List<String> deDupStringList3 = strList.stream().distinct().collect(Collectors.toList());  Note: If we want to maintain the insertion order then we need to use LinkedHashSet in place of HashSet . ", "question_id": 203984}, {"answer_votes": "19", "answer_comments": null, "answer_body": " Java 8 streams provide a very simple way to remove duplicate elements from a list. Using the distinct method.\nIf we have a list of cities and we want to remove duplicates from that list it can be done in a single line -  List<String> cityList = new ArrayList<>();\n cityList.add(\"Delhi\");\n cityList.add(\"Mumbai\");\n cityList.add(\"Bangalore\");\n cityList.add(\"Chennai\");\n cityList.add(\"Kolkata\");\n cityList.add(\"Mumbai\");\n\n cityList = cityList.stream().distinct().collect(Collectors.toList());  How to remove duplicate elements from an arraylist ", "question_id": 203984}, {"answer_votes": "19", "answer_comments": [" Note that there is an ImmutableSet.asList() method, returning an ImmutableList , if you need it back as a List . \u2013 Andy Turner  Oct 27 '17 at 19:25 "], "answer_body": " There is also ImmutableSet from Guava as an option ( here is the documentation):  ImmutableSet.copyOf(list); ", "question_id": 203984}, {"answer_votes": "18", "answer_comments": [" It's slow and you might get a ConcurrentModificationException. \u2013 maaartinus  Oct 18 '13 at 9:39 ", " @maaartinus Have you tried that code ?. It won't produce any exceptions.Also it is pretty fast. I tried the code before posting. \u2013 CarlJohn  Oct 18 '13 at 10:35  ", " You're right, it doesn't as you iterate the array instead of the list. However, it's slow like hell. Try it with a few millions elements. Compare it to ImmutableSet.copyOf(lst).toList() . \u2013 maaartinus  Oct 18 '13 at 10:49  ", " answers the question I was asked in the interview .. How to remove repeated values from an ArrayList without using Sets. Thanx \u2013 Aniket Paul  May 5 '16 at 9:10 ", " Internally, indexOf iterates the lst using a for loop. \u2013 Patrick M  Jul 11 '16 at 17:32 "], "answer_body": " It is possible to remove duplicates from arraylist without using HashSet or one more arraylist .  Try this code..  ArrayList<String> lst = new ArrayList<String>();\n    lst.add(\"ABC\");\n    lst.add(\"ABC\");\n    lst.add(\"ABCD\");\n    lst.add(\"ABCD\");\n    lst.add(\"ABCE\");\n\n    System.out.println(\"Duplicates List \"+lst);\n\n    Object[] st = lst.toArray();\n      for (Object s : st) {\n        if (lst.indexOf(s) != lst.lastIndexOf(s)) {\n            lst.remove(lst.lastIndexOf(s));\n         }\n      }\n\n    System.out.println(\"Distinct List \"+lst);  Output is  Duplicates List [ABC, ABC, ABCD, ABCD, ABCE]\nDistinct List [ABC, ABCD, ABCE] ", "question_id": 203984}, {"answer_votes": "14", "answer_comments": [" Works perfect.. Thanks for saving my head from loops :) :) \u2013 Sanoop  Dec 21 '16 at 11:17 "], "answer_body": " You can also do it this way, and preserve order:  // delete duplicates (if any) from 'myArrayList'\nmyArrayList = new ArrayList<String>(new LinkedHashSet<String>(myArrayList)); ", "question_id": 203984}, {"answer_votes": "10", "answer_comments": [" Why use ArrayList in parameter? Why not just List? Will that not work? \u2013 Shervin Asgari  Nov 12 '09 at 15:54 ", " A List will absolutely work as in-parameter for the first method listed. The method is however optimized for use with a random access list such as ArrayList, so if a LinkedList is passed instead you will get poor performance. For example, setting the n:th element in a LinkedList takes O(n) time, whereas setting the n:th element in a random access list (such as ArrayList) takes O(1) time. Again, though, this is probably overkill... If you need this kind of specialized code it will hopefully be in an isolated situation. \u2013 volley  Dec 9 '09 at 20:37 ", " This is precisely what I needed, thanks \u2013 Jasper Holton  Jun 1 '14 at 2:15 "], "answer_body": " Probably a bit overkill, but I enjoy this kind of isolated problem. :)  This code uses a temporary Set (for the uniqueness check) but removes elements directly inside the original list. Since element removal inside an ArrayList can induce a huge amount of array copying, the remove(int)-method is avoided.  public static <T> void removeDuplicates(ArrayList<T> list) {\n    int size = list.size();\n    int out = 0;\n    {\n        final Set<T> encountered = new HashSet<T>();\n        for (int in = 0; in < size; in++) {\n            final T t = list.get(in);\n            final boolean first = encountered.add(t);\n            if (first) {\n                list.set(out++, t);\n            }\n        }\n    }\n    while (out < size) {\n        list.remove(--size);\n    }\n}  While we're at it, here's a version for LinkedList (a lot nicer!):  public static <T> void removeDuplicates(LinkedList<T> list) {\n    final Set<T> encountered = new HashSet<T>();\n    for (Iterator<T> iter = list.iterator(); iter.hasNext(); ) {\n        final T t = iter.next();\n        final boolean first = encountered.add(t);\n        if (!first) {\n            iter.remove();\n        }\n    }\n}  Use the marker interface to present a unified solution for List:  public static <T> void removeDuplicates(List<T> list) {\n    if (list instanceof RandomAccess) {\n        // use first version here\n    } else {\n        // use other version here\n    }\n}  EDIT: I guess the generics-stuff doesn't really add any value here.. Oh well. :) ", "question_id": 203984}, {"answer_votes": "9", "answer_comments": [" I liked this solution better. \u2013 Tushar Gogna  Dec 5 '17 at 7:19 "], "answer_body": " this can solve the problem:  private List<SomeClass> clearListFromDuplicateFirstName(List<SomeClass> list1) {\n\nMap<String, SomeClass> cleanMap = new LinkedHashMap<String, SomeClass>();\nfor (int i = 0; i < list1.size(); i++) {\n     cleanMap.put(list1.get(i).getFirstName(), list1.get(i));\n}\nList<SomeClass> list = new ArrayList<SomeClass>(cleanMap.values());\nreturn list;\n} ", "question_id": 203984}, {"answer_votes": "8", "answer_comments": [" This implementation return no element in the list because of the last j-- \u2013 neo7  Sep 23 '15 at 9:29 ", " This implementation work's very fine.there is no issue behind this and for this task i am only use one arraylist.so this answer is completely good.before giving negative feedback you shold also add testcase also so that every one can understand the result.Thanks Manash \u2013 Manash Ranjan Dakua  Sep 24 '15 at 13:14 ", " This saved the day! \u2013 YehCheez  Mar 9 '16 at 16:09 "], "answer_body": " public static void main(String[] args){\n    ArrayList<Object> al = new ArrayList<Object>();\n    al.add(\"abc\");\n    al.add('a');\n    al.add('b');\n    al.add('a');\n    al.add(\"abc\");\n    al.add(10.3);\n    al.add('c');\n    al.add(10);\n    al.add(\"abc\");\n    al.add(10);\n    System.out.println(\"Before Duplicate Remove:\"+al);\n    for(int i=0;i<al.size();i++){\n        for(int j=i+1;j<al.size();j++){\n            if(al.get(i).equals(al.get(j))){\n                al.remove(j);\n                j--;\n            }\n        }\n    }\n    System.out.println(\"After Removing duplicate:\"+al);\n} ", "question_id": 203984}, {"answer_votes": "5", "answer_comments": null, "answer_body": " If you're willing to use a third-party library, you can use the method distinct() in Eclipse Collections (formerly GS Collections).  ListIterable<Integer> integers = FastList.newListWith(1, 3, 1, 2, 2, 1);\nAssert.assertEquals(\n    FastList.newListWith(1, 3, 2),\n    integers.distinct());  The advantage of using distinct() instead of converting to a Set and then back to a List is that distinct() preserves the order of the original List, retaining the first occurrence of each element. It's implemented by using both a Set and a List.  MutableSet<T> seenSoFar = UnifiedSet.newSet();\nint size = list.size();\nfor (int i = 0; i < size; i++)\n{\n    T item = list.get(i);\n    if (seenSoFar.add(item))\n    {\n        targetCollection.add(item);\n    }\n}\nreturn targetCollection;  If you cannot convert your original List into an Eclipse Collections type, you can use ListAdapter to get the same API.  MutableList<Integer> distinct = ListAdapter.adapt(integers).distinct();  Note: I am a committer for Eclipse Collections. ", "question_id": 203984}, {"answer_votes": "3", "answer_comments": null, "answer_body": " This three lines of code can remove the duplicated element from ArrayList or any collection.  List<Entity> entities = repository.findByUserId(userId);\n\nSet<Entity> s = new LinkedHashSet<Entity>(entities);\nentities.clear();\nentities.addAll(s); ", "question_id": 203984}, {"answer_votes": "2", "answer_comments": null, "answer_body": " When you are filling the ArrayList, use a condition for each element. For example:  ArrayList< Integer > al = new ArrayList< Integer >(); \n\n    // fill 1 \n    for ( int i = 0; i <= 5; i++ ) \n        if ( !al.contains( i ) ) \n            al.add( i ); \n\n    // fill 2 \n    for (int i = 0; i <= 10; i++ ) \n        if ( !al.contains( i ) ) \n            al.add( i ); \n\n    for( Integer i: al )\n    {\n        System.out.print( i + \" \");     \n    }  We will get an array {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10} ", "question_id": 203984}, {"answer_votes": "2", "answer_comments": null, "answer_body": " If you want to preserve your Order then it is best to use LinkedHashSet .\nBecause if you want to pass this List to an Insert Query by Iterating it, the order would be preserved.  Try this  LinkedHashSet link=new LinkedHashSet();\nList listOfValues=new ArrayList();\nlistOfValues.add(link);  This conversion will be very helpful when you want to return a List but not a Set. ", "question_id": 203984}, {"answer_votes": "2", "answer_comments": null, "answer_body": " Code:  List<String> duplicatList = new ArrayList<String>();\nduplicatList = Arrays.asList(\"AA\",\"BB\",\"CC\",\"DD\",\"DD\",\"EE\",\"AA\",\"FF\");\n//above AA and DD are duplicate\nSet<String> uniqueList = new HashSet<String>(duplicatList);\nduplicatList = new ArrayList<String>(uniqueList); //let GC will doing free memory\nSystem.out.println(\"Removed Duplicate : \"+duplicatList);  Note: Definitely, there will be memory overhead. ", "question_id": 203984}, {"answer_votes": "2", "answer_comments": null, "answer_body": " ArrayList<String> city=new ArrayList<String>();\ncity.add(\"rajkot\");\ncity.add(\"gondal\");\ncity.add(\"rajkot\");\ncity.add(\"gova\");\ncity.add(\"baroda\");\ncity.add(\"morbi\");\ncity.add(\"gova\");\n\nHashSet<String> hashSet = new HashSet<String>();\nhashSet.addAll(city);\ncity.clear();\ncity.addAll(hashSet);\nToast.makeText(getActivity(),\"\" + city.toString(),Toast.LENGTH_SHORT).show(); ", "question_id": 203984}, {"answer_votes": "1", "answer_comments": null, "answer_body": " As said before, you should use a class implementing Set interface instead of List to be sure of unicity of elements. If you have to keep the order of elements, the SortedSet interface can then be used ; the TreeSet class implements that interface. ", "question_id": 203984}, {"answer_votes": "1", "answer_comments": null, "answer_body": " LinkedHashSet will do the trick.  String[] arr2 = {\"5\",\"1\",\"2\",\"3\",\"3\",\"4\",\"1\",\"2\"};\nSet<String> set = new LinkedHashSet<String>(Arrays.asList(arr2));\nfor(String s1 : set)\n    System.out.println(s1);\n\nSystem.out.println( \"------------------------\" );\nString[] arr3 = set.toArray(new String[0]);\nfor(int i = 0; i < arr3.length; i++)\n     System.out.println(arr3[i].toString());  //output: 5,1,2,3,4 ", "question_id": 203984}, {"answer_votes": "1", "answer_comments": null, "answer_body": " List<String> result = new ArrayList<String>();\n        Set<String> set = new LinkedHashSet<String>();\n        String s = \"ravi is a good!boy. But ravi is very nasty fellow.\";\n        StringTokenizer st = new StringTokenizer(s, \" ,. ,!\");\n        while (st.hasMoreTokens()) {\n            result.add(st.nextToken());\n        }\n         System.out.println(result);\n         set.addAll(result);\n        result.clear();\n        result.addAll(set);\n        System.out.println(result);\n\noutput:\n[ravi, is, a, good, boy, But, ravi, is, very, nasty, fellow]\n[ravi, is, a, good, boy, But, very, nasty, fellow] ", "question_id": 203984}, {"answer_votes": "1", "answer_comments": [" This thread is years old... \u2013 WolfieeifloW  Nov 30 '17 at 18:43 "], "answer_body": " you can use nested loop in follow :  ArrayList<Class1> l1 = new ArrayList<Class1>();\nArrayList<Class1> l2 = new ArrayList<Class1>();\n\n        Iterator iterator1 = l1.iterator();\n        boolean repeated = false;\n\n        while (iterator1.hasNext())\n        {\n            Class1 c1 = (Class1) iterator1.next();\n            for (Class1 _c: l2) {\n                if(_c.getId() == c1.getId())\n                    repeated = true;\n            }\n            if(!repeated)\n                l2.add(c1);\n        } ", "question_id": 203984}, {"answer_votes": "0", "answer_comments": null, "answer_body": " for(int a=0;a<myArray.size();a++){\n        for(int b=a+1;b<myArray.size();b++){\n            if(myArray.get(a).equalsIgnoreCase(myArray.get(b))){\n                myArray.remove(b); \n                dups++;\n                b--;\n            }\n        }\n} ", "question_id": 203984}, {"answer_votes": "0", "answer_comments": null, "answer_body": " import java.util.*;\nclass RemoveDupFrmString\n{\n    public static void main(String[] args)\n    {\n\n        String s=\"appsc\";\n\n        Set<Character> unique = new LinkedHashSet<Character> ();\n\n        for(char c : s.toCharArray()) {\n\n            System.out.println(unique.add(c));\n        }\n        for(char dis:unique){\n            System.out.println(dis);\n        }\n\n\n    }\n} ", "question_id": 203984}, {"answer_votes": "0", "answer_comments": null, "answer_body": " public Set<Object> findDuplicates(List<Object> list) {\n        Set<Object> items = new HashSet<Object>();\n        Set<Object> duplicates = new HashSet<Object>();\n        for (Object item : list) {\n            if (items.contains(item)) {\n                duplicates.add(item);\n                } else { \n                    items.add(item);\n                    } \n            } \n        return duplicates;\n        } ", "question_id": 203984}, {"answer_votes": "0", "answer_comments": null, "answer_body": " ArrayList<String> list = new ArrayList<String>();\n    HashSet<String> unique = new LinkedHashSet<String>();\n    HashSet<String> dup = new LinkedHashSet<String>();\n    boolean b = false;\n    list.add(\"Hello\");\n    list.add(\"Hello\");\n    list.add(\"how\");\n    list.add(\"are\");\n    list.add(\"u\");\n    list.add(\"u\");\n\n    for(Iterator iterator= list.iterator();iterator.hasNext();)\n    {\n        String value = (String)iterator.next();\n        System.out.println(value);\n\n        if(b==unique.add(value))\n            dup.add(value);\n        else\n            unique.add(value);\n\n\n    }\n    System.out.println(unique);\n    System.out.println(dup); ", "question_id": 203984}, {"answer_votes": "0", "answer_comments": [" Why would you post a quadratic solution to a question that already has 2-year-old linear and log-linear solutions, that are also simpler? \u2013 abarnert  Sep 11 '14 at 7:40 "], "answer_body": " If you want to remove duplicates from ArrayList means find the below logic,  public static Object[] removeDuplicate(Object[] inputArray)\n{\n    long startTime = System.nanoTime();\n    int totalSize = inputArray.length;\n    Object[] resultArray = new Object[totalSize];\n    int newSize = 0;\n    for(int i=0; i<totalSize; i++)\n    {\n        Object value = inputArray[i];\n        if(value == null)\n        {\n            continue;\n        }\n\n        for(int j=i+1; j<totalSize; j++)\n        {\n            if(value.equals(inputArray[j]))\n            {\n                inputArray[j] = null;\n            }\n        }\n        resultArray[newSize++] = value;\n    }\n\n    long endTime = System.nanoTime()-startTime;\n    System.out.println(\"Total Time-B:\"+endTime);\n    return resultArray;\n} ", "question_id": 203984}, {"answer_votes": "0", "answer_comments": null, "answer_body": " The @jonathan-stafford solution is OK. But this don't preserve the list order.  If you want preserve the list order you have to use this:  public static <T> void removeDuplicate(List <T> list) {\nSet <T> set = new HashSet <T>();\nList <T> newList = new ArrayList <T>();\nfor (Iterator <T>iter = list.iterator();    iter.hasNext(); ) {\n   Object element = iter.next();\n   if (set.add((T) element))\n      newList.add((T) element);\n   }\n   list.clear();\n   list.addAll(newList);\n}  It's only to complete the answer. Very good! ", "question_id": 203984}, {"answer_votes": "0", "answer_comments": null, "answer_body": " Here is my answer without using any other data structure like set or hashmap etc.  public static <T> ArrayList<T> uniquefy(ArrayList<T> myList) {\n\n    ArrayList <T> uniqueArrayList = new ArrayList<T>();\n    for (int i = 0; i < myList.size(); i++){\n        if (!uniqueArrayList.contains(myList.get(i))){\n            uniqueArrayList.add(myList.get(i));\n        }\n    }\n\n    return uniqueArrayList;\n} ", "question_id": 203984}, {"answer_votes": "0", "answer_comments": null, "answer_body": " Would something like this work better ?  public static void removeDuplicates(ArrayList<String> list) {\nArraylist<Object> ar     = new Arraylist<Object>();\nArraylist<Object> tempAR = new Arraylist<Object>();\nwhile (list.size()>0){\n    ar.add(list(0));\n    list.removeall(Collections.singleton(list(0)));\n}\nlist.addAll(ar);  }  That should maintain the order and also not be quadratic in run time. ", "question_id": 203984}, {"answer_votes": "0", "answer_comments": null, "answer_body": " This is used for your Custom Objects list  public List<Contact> removeDuplicates(List<Contact> list) {\n    // Set set1 = new LinkedHashSet(list);\n    Set set = new TreeSet(new Comparator() {\n\n        @Override\n        public int compare(Object o1, Object o2) {\n            if (((Contact) o1).getId().equalsIgnoreCase(((Contact) o2).getId()) /*&&\n                    ((Contact)o1).getName().equalsIgnoreCase(((Contact)o2).getName())*/) {\n                return 0;\n            }\n            return 1;\n        }\n    });\n    set.addAll(list);\n\n    final List newList = new ArrayList(set);\n    return newList;\n} ", "question_id": 203984}, {"answer_votes": "0", "answer_comments": null, "answer_body": " If you are using model type List< T>/ArrayList< T> . Hope,it's help you.   Here is my code without using any other data structure like set or hashmap  for(int i = 0; i < Models.size(); i++) {\n     for(int j = i + 1; j < Models.size(); j++) {                                \n       if(Models.get(i).getName().equals(Models.get(j).getName())){    \n                                Models.remove(j);\n\n                                j--;\n                            }\n                        }\n                    } ", "question_id": 203984}, {"answer_votes": "-1", "answer_comments": null, "answer_body": " In Java, List permits ordered access of their elements. They can have duplicates because their lookup key is the position not some hash code, every element can be modified while they remain in the list where as Set represents a collection of unique elements and while elements are in set, they must not be modified.While there is no restriction preventing you from modifying elements in a set, if an element is modified, then it could become forever lost in the set.  public static void main(String[] args) {  \n           List<String> l = new ArrayList<String>();  \n           l.add(\"A\");  \n           l.add(\"B\");  \n           l.add(\"C\");  \n           l.add(\"A\");  \n           System.out.println(\"Before removing duplicates: \");  \n           for (String s : l) {  \n                System.out.println(s);  \n           }  \n           Set<String> set = new HashSet<String>(l);  \n           List<String> newlist = new ArrayList<String>(set);  \n           System.out.println(\"after removing duplicates: \");  \n           for (String s : newlist) {  \n                System.out.println(s);  \n           }  \n      }  for reference , refer this link How to remove duplicates from ArrayList  ", "question_id": 203984}], "K_means_clustering_result": [[[{"answer_votes": "258", "answer_comments": [" Does LinkedHashSet make any guarantees as to which of several duplicates are kept from the list?  For instance, if position 1, 3, and 5 are duplicates in the original list, can we assume that this process will remove 3 and 5?  Or maybe remove 1 and 3?  Thanks. \u2013 Matt Brian\u00e7on  May 1 '11 at 2:20 ", " @Matt: yes, it does guarantee that. The docs say: \"This linked list defines the iteration ordering, which is the order in which elements were inserted into the set (insertion-order). Note that insertion order is not affected if an element is re-inserted into the set.\" \u2013 abahgat  May 2 '11 at 9:00 ", " Very interesting. I have a different situation here. I am not trying to sort String but another object called AwardYearSource. This class has an int attribute called year. So I want to remove duplicates based on the year. i.e if there is year 2010 mentioned more than once, I want to remove that AwardYearSource object. How can I do that? \u2013 WowBow  Apr 16 '12 at 15:27 ", " @WowBow For example you can define Wrapper object which holds AwardYearSource. And define this Wrapper objects equals method based on AwardYearSources year field. Then you can use Set with these Wrapper objects. \u2013 Ondrej Bozek  Jun 20 '12 at 12:19 ", " @WowBow or implement Comparable/Comparator \u2013 shrini1000  Jan 11 '13 at 5:09 "], "answer_body": " Although converting the ArrayList to a HashSet effectively removes duplicates, if you need to preserve insertion order, I'd rather suggest you to use this variant  // list is some List of Strings\nSet<String> s = new LinkedHashSet<>(list);  Then, if you need to get back a List reference, you can use again the conversion constructor. ", "question_id": 203984}, "0.36018345097545534", 0], [{"answer_votes": "83", "answer_comments": [" very elegant. Thanks \u2013 paskos  Feb 12 '15 at 20:04 ", " How do i do this for case insensitive distinct ? \u2013 StackFlowed  Sep 13 '16 at 20:04  ", " @StackFlowed If you don't need to preserve the order of the list you can addAll to new TreeSet<String>(String.CASE_INSENSITIVE_ORDER) .  The first element added will remain in the set so if your list contains \"Dog\" and \"dog\" (in that order) the TreeSet will contain \"Dog\". If order must be preserved then before the line in the answer put list.replaceAll(String::toUpperCase); . \u2013 Paul  Nov 3 '17 at 23:28  ", " I am getting this error :incompatible types: List<Object> cannot be converted to List<String> \u2013 Samir  Apr 4 at 14:34 "], "answer_body": " In Java 8:  List<String> deduped = list.stream().distinct().collect(Collectors.toList());  Please note that the hashCode-equals contract for list members should be respected for the filtering to work properly. ", "question_id": 203984}, "0.36018345097545534", 0], [{"answer_votes": "48", "answer_comments": [" Similarly at the bottom of the thread, I have given an answer where I am using Set for Custom Object. In a case if anyone have custom object like \"Contact\" or \"Student\" can use that answer that works fine for me. \u2013 Muhammad Adil  Oct 25 '16 at 14:16 "], "answer_body": " If you don't want duplicates, use a Set instead of a List . To convert a List to a Set you can use the following code:  // list is some List of Strings\nSet<String> s = new HashSet<String>(list);  If really necessary you can use the same construction to convert a Set back into a List . ", "question_id": 203984}, "0.36018345097545534", 0], [{"answer_votes": "24", "answer_comments": [" This answer lacks two things: 1) It does not use generics, but raw types ( ArrayList<T> should be used instead of ArrayList ) 2) The explicit iterator creating can be avoided by using a for (T current : l1) { ... } . Even if you wanted to use an Iterator explicitly, iterador is misspelled. \u2013 RAnders00  Dec 7 '15 at 16:22 ", " And this implementation runs in quadratic time, compared to the linked hash set implementation running in linear time. (i.e. this takes 10 times longer on a list with 10 elements, 10,000 times longer on a list with 10,000 elements. JDK 6 implementation for ArrayList.contains , JDK8 impl is the same.) \u2013 Patrick M  Jul 11 '16 at 16:09 "], "answer_body": " Here's a way that doesn't affect your list ordering:  ArrayList l1 = new ArrayList();\nArrayList l2 = new ArrayList();\n\nIterator iterator = l1.iterator();\n\n        while (iterator.hasNext())\n        {\n            YourClass o = (YourClass) iterator.next();\n            if(!l2.contains(o)) l2.add(o);\n        }  l1 is the original list, and l2 is the list whithout repeated items\n(Make sure YourClass has the equals method acording to what you want to stand for equality) ", "question_id": 203984}, "0.36018345097545534", 0], [{"answer_votes": "24", "answer_comments": [" +1 for Java 8 streams. But if case-sensitivity is not required then only Java 8 solution can be easily modified. List<String> deDupStringList3 = stringList.parallelStream().map(String::toLowerCase).distinct().collect(Collectors.toList()); should work. \u2013 Diablo  Jun 10 '16 at 8:13 "], "answer_body": " Suppose we have a list of String like:  List<String> strList = new ArrayList<>(5);\n// insert up to five items to list.  Then we can remove duplicate elements in in multiple ways.  Prior to Java 8  List<String> deDupStringList = new ArrayList<>(new HashSet<>(strList));  Using Guava  List<String> deDupStringList2 = Lists.newArrayList(Sets.newHashSet(strList));  Using Java 8  List<String> deDupStringList3 = strList.stream().distinct().collect(Collectors.toList());  Note: If we want to maintain the insertion order then we need to use LinkedHashSet in place of HashSet . ", "question_id": 203984}, "0.36018345097545534", 0], [{"answer_votes": "19", "answer_comments": [" Note that there is an ImmutableSet.asList() method, returning an ImmutableList , if you need it back as a List . \u2013 Andy Turner  Oct 27 '17 at 19:25 "], "answer_body": " There is also ImmutableSet from Guava as an option ( here is the documentation):  ImmutableSet.copyOf(list); ", "question_id": 203984}, "0.36018345097545534", 0], [{"answer_votes": "9", "answer_comments": [" I liked this solution better. \u2013 Tushar Gogna  Dec 5 '17 at 7:19 "], "answer_body": " this can solve the problem:  private List<SomeClass> clearListFromDuplicateFirstName(List<SomeClass> list1) {\n\nMap<String, SomeClass> cleanMap = new LinkedHashMap<String, SomeClass>();\nfor (int i = 0; i < list1.size(); i++) {\n     cleanMap.put(list1.get(i).getFirstName(), list1.get(i));\n}\nList<SomeClass> list = new ArrayList<SomeClass>(cleanMap.values());\nreturn list;\n} ", "question_id": 203984}, "0.36018345097545534", 0], [{"answer_votes": "2", "answer_comments": null, "answer_body": " If you want to preserve your Order then it is best to use LinkedHashSet .\nBecause if you want to pass this List to an Insert Query by Iterating it, the order would be preserved.  Try this  LinkedHashSet link=new LinkedHashSet();\nList listOfValues=new ArrayList();\nlistOfValues.add(link);  This conversion will be very helpful when you want to return a List but not a Set. ", "question_id": 203984}, "0.36018345097545534", 0], [{"answer_votes": "0", "answer_comments": null, "answer_body": " This is used for your Custom Objects list  public List<Contact> removeDuplicates(List<Contact> list) {\n    // Set set1 = new LinkedHashSet(list);\n    Set set = new TreeSet(new Comparator() {\n\n        @Override\n        public int compare(Object o1, Object o2) {\n            if (((Contact) o1).getId().equalsIgnoreCase(((Contact) o2).getId()) /*&&\n                    ((Contact)o1).getName().equalsIgnoreCase(((Contact)o2).getName())*/) {\n                return 0;\n            }\n            return 1;\n        }\n    });\n    set.addAll(list);\n\n    final List newList = new ArrayList(set);\n    return newList;\n} ", "question_id": 203984}, "0.36018345097545534", 0], [{"answer_votes": "8", "answer_comments": [" This implementation return no element in the list because of the last j-- \u2013 neo7  Sep 23 '15 at 9:29 ", " This implementation work's very fine.there is no issue behind this and for this task i am only use one arraylist.so this answer is completely good.before giving negative feedback you shold also add testcase also so that every one can understand the result.Thanks Manash \u2013 Manash Ranjan Dakua  Sep 24 '15 at 13:14 ", " This saved the day! \u2013 YehCheez  Mar 9 '16 at 16:09 "], "answer_body": " public static void main(String[] args){\n    ArrayList<Object> al = new ArrayList<Object>();\n    al.add(\"abc\");\n    al.add('a');\n    al.add('b');\n    al.add('a');\n    al.add(\"abc\");\n    al.add(10.3);\n    al.add('c');\n    al.add(10);\n    al.add(\"abc\");\n    al.add(10);\n    System.out.println(\"Before Duplicate Remove:\"+al);\n    for(int i=0;i<al.size();i++){\n        for(int j=i+1;j<al.size();j++){\n            if(al.get(i).equals(al.get(j))){\n                al.remove(j);\n                j--;\n            }\n        }\n    }\n    System.out.println(\"After Removing duplicate:\"+al);\n} ", "question_id": 203984}, "0.2675104020163417", 1], [{"answer_votes": "1", "answer_comments": null, "answer_body": " LinkedHashSet will do the trick.  String[] arr2 = {\"5\",\"1\",\"2\",\"3\",\"3\",\"4\",\"1\",\"2\"};\nSet<String> set = new LinkedHashSet<String>(Arrays.asList(arr2));\nfor(String s1 : set)\n    System.out.println(s1);\n\nSystem.out.println( \"------------------------\" );\nString[] arr3 = set.toArray(new String[0]);\nfor(int i = 0; i < arr3.length; i++)\n     System.out.println(arr3[i].toString());  //output: 5,1,2,3,4 ", "question_id": 203984}, "0.2675104020163417", 1], [{"answer_votes": "0", "answer_comments": null, "answer_body": " import java.util.*;\nclass RemoveDupFrmString\n{\n    public static void main(String[] args)\n    {\n\n        String s=\"appsc\";\n\n        Set<Character> unique = new LinkedHashSet<Character> ();\n\n        for(char c : s.toCharArray()) {\n\n            System.out.println(unique.add(c));\n        }\n        for(char dis:unique){\n            System.out.println(dis);\n        }\n\n\n    }\n} ", "question_id": 203984}, "0.2675104020163417", 1], [{"answer_votes": "824", "answer_comments": [" See also LinkedHashSet, if you wish to retain the order. \u2013 volley  Dec 9 '09 at 20:38 ", " But this will just create the set without duplicates , I want to know which number was duplicate in O(n) time \u2013 Chetan  Mar 29 '12 at 19:43 ", " @Chetan finding all duplicates from ArrayList in O(n), its important to have correctly defined equals method on objects which you have in the list (no problem for numbers): public Set<Object> findDuplicates(List<Object> list)       {           Set<Object> items = new HashSet<Object>();           Set<Object> duplicates = new HashSet<Object>();           for (Object item : list) {               if (items.contains(item)) {                   duplicates.add(item);               } else {                   items.add(item);               }           }           return duplicates;       } \u2013 Ondrej Bozek  Jun 20 '12 at 12:06  ", " A good practice would be to define variables using the interface types List and Set (instead of implementation types ArrayList and HashSet as in your example). \u2013 Jonik  Aug 29 '13 at 7:27 ", " You can clean this up by using new HashSet(al) instead of initializing it to empty and calling addAll . \u2013 ashes999  Dec 26 '13 at 12:44 "], "answer_body": " If you don't want duplicates in a Collection , you should consider why you're using a Collection that allows duplicates. The easiest way to remove repeated elements is to add the contents to a Set (which will not allow duplicates) and then add the Set back to the ArrayList :  List<String> al = new ArrayList<>();\n// add elements to al, including duplicates\nSet<String> hs = new HashSet<>();\nhs.addAll(al);\nal.clear();\nal.addAll(hs);  Of course, this destroys the ordering of the elements in the ArrayList . ", "question_id": 203984}, "0.27532320842146873", 2], [{"answer_votes": "19", "answer_comments": null, "answer_body": " Java 8 streams provide a very simple way to remove duplicate elements from a list. Using the distinct method.\nIf we have a list of cities and we want to remove duplicates from that list it can be done in a single line -  List<String> cityList = new ArrayList<>();\n cityList.add(\"Delhi\");\n cityList.add(\"Mumbai\");\n cityList.add(\"Bangalore\");\n cityList.add(\"Chennai\");\n cityList.add(\"Kolkata\");\n cityList.add(\"Mumbai\");\n\n cityList = cityList.stream().distinct().collect(Collectors.toList());  How to remove duplicate elements from an arraylist ", "question_id": 203984}, "0.27532320842146873", 2], [{"answer_votes": "3", "answer_comments": null, "answer_body": " This three lines of code can remove the duplicated element from ArrayList or any collection.  List<Entity> entities = repository.findByUserId(userId);\n\nSet<Entity> s = new LinkedHashSet<Entity>(entities);\nentities.clear();\nentities.addAll(s); ", "question_id": 203984}, "0.27532320842146873", 2], [{"answer_votes": "1", "answer_comments": null, "answer_body": " As said before, you should use a class implementing Set interface instead of List to be sure of unicity of elements. If you have to keep the order of elements, the SortedSet interface can then be used ; the TreeSet class implements that interface. ", "question_id": 203984}, "0.27532320842146873", 2], [{"answer_votes": "0", "answer_comments": null, "answer_body": " public Set<Object> findDuplicates(List<Object> list) {\n        Set<Object> items = new HashSet<Object>();\n        Set<Object> duplicates = new HashSet<Object>();\n        for (Object item : list) {\n            if (items.contains(item)) {\n                duplicates.add(item);\n                } else { \n                    items.add(item);\n                    } \n            } \n        return duplicates;\n        } ", "question_id": 203984}, "0.27532320842146873", 2], [{"answer_votes": "0", "answer_comments": null, "answer_body": " The @jonathan-stafford solution is OK. But this don't preserve the list order.  If you want preserve the list order you have to use this:  public static <T> void removeDuplicate(List <T> list) {\nSet <T> set = new HashSet <T>();\nList <T> newList = new ArrayList <T>();\nfor (Iterator <T>iter = list.iterator();    iter.hasNext(); ) {\n   Object element = iter.next();\n   if (set.add((T) element))\n      newList.add((T) element);\n   }\n   list.clear();\n   list.addAll(newList);\n}  It's only to complete the answer. Very good! ", "question_id": 203984}, "0.27532320842146873", 2], [{"answer_votes": "10", "answer_comments": [" Why use ArrayList in parameter? Why not just List? Will that not work? \u2013 Shervin Asgari  Nov 12 '09 at 15:54 ", " A List will absolutely work as in-parameter for the first method listed. The method is however optimized for use with a random access list such as ArrayList, so if a LinkedList is passed instead you will get poor performance. For example, setting the n:th element in a LinkedList takes O(n) time, whereas setting the n:th element in a random access list (such as ArrayList) takes O(1) time. Again, though, this is probably overkill... If you need this kind of specialized code it will hopefully be in an isolated situation. \u2013 volley  Dec 9 '09 at 20:37 ", " This is precisely what I needed, thanks \u2013 Jasper Holton  Jun 1 '14 at 2:15 "], "answer_body": " Probably a bit overkill, but I enjoy this kind of isolated problem. :)  This code uses a temporary Set (for the uniqueness check) but removes elements directly inside the original list. Since element removal inside an ArrayList can induce a huge amount of array copying, the remove(int)-method is avoided.  public static <T> void removeDuplicates(ArrayList<T> list) {\n    int size = list.size();\n    int out = 0;\n    {\n        final Set<T> encountered = new HashSet<T>();\n        for (int in = 0; in < size; in++) {\n            final T t = list.get(in);\n            final boolean first = encountered.add(t);\n            if (first) {\n                list.set(out++, t);\n            }\n        }\n    }\n    while (out < size) {\n        list.remove(--size);\n    }\n}  While we're at it, here's a version for LinkedList (a lot nicer!):  public static <T> void removeDuplicates(LinkedList<T> list) {\n    final Set<T> encountered = new HashSet<T>();\n    for (Iterator<T> iter = list.iterator(); iter.hasNext(); ) {\n        final T t = iter.next();\n        final boolean first = encountered.add(t);\n        if (!first) {\n            iter.remove();\n        }\n    }\n}  Use the marker interface to present a unified solution for List:  public static <T> void removeDuplicates(List<T> list) {\n    if (list instanceof RandomAccess) {\n        // use first version here\n    } else {\n        // use other version here\n    }\n}  EDIT: I guess the generics-stuff doesn't really add any value here.. Oh well. :) ", "question_id": 203984}, "0.20788288832409307", 3], [{"answer_votes": "5", "answer_comments": null, "answer_body": " If you're willing to use a third-party library, you can use the method distinct() in Eclipse Collections (formerly GS Collections).  ListIterable<Integer> integers = FastList.newListWith(1, 3, 1, 2, 2, 1);\nAssert.assertEquals(\n    FastList.newListWith(1, 3, 2),\n    integers.distinct());  The advantage of using distinct() instead of converting to a Set and then back to a List is that distinct() preserves the order of the original List, retaining the first occurrence of each element. It's implemented by using both a Set and a List.  MutableSet<T> seenSoFar = UnifiedSet.newSet();\nint size = list.size();\nfor (int i = 0; i < size; i++)\n{\n    T item = list.get(i);\n    if (seenSoFar.add(item))\n    {\n        targetCollection.add(item);\n    }\n}\nreturn targetCollection;  If you cannot convert your original List into an Eclipse Collections type, you can use ListAdapter to get the same API.  MutableList<Integer> distinct = ListAdapter.adapt(integers).distinct();  Note: I am a committer for Eclipse Collections. ", "question_id": 203984}, "0.20788288832409307", 3], [{"answer_votes": "2", "answer_comments": null, "answer_body": " When you are filling the ArrayList, use a condition for each element. For example:  ArrayList< Integer > al = new ArrayList< Integer >(); \n\n    // fill 1 \n    for ( int i = 0; i <= 5; i++ ) \n        if ( !al.contains( i ) ) \n            al.add( i ); \n\n    // fill 2 \n    for (int i = 0; i <= 10; i++ ) \n        if ( !al.contains( i ) ) \n            al.add( i ); \n\n    for( Integer i: al )\n    {\n        System.out.print( i + \" \");     \n    }  We will get an array {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10} ", "question_id": 203984}, "0.20788288832409307", 3], [{"answer_votes": "0", "answer_comments": null, "answer_body": " for(int a=0;a<myArray.size();a++){\n        for(int b=a+1;b<myArray.size();b++){\n            if(myArray.get(a).equalsIgnoreCase(myArray.get(b))){\n                myArray.remove(b); \n                dups++;\n                b--;\n            }\n        }\n} ", "question_id": 203984}, "0.20788288832409307", 3], [{"answer_votes": "0", "answer_comments": [" Why would you post a quadratic solution to a question that already has 2-year-old linear and log-linear solutions, that are also simpler? \u2013 abarnert  Sep 11 '14 at 7:40 "], "answer_body": " If you want to remove duplicates from ArrayList means find the below logic,  public static Object[] removeDuplicate(Object[] inputArray)\n{\n    long startTime = System.nanoTime();\n    int totalSize = inputArray.length;\n    Object[] resultArray = new Object[totalSize];\n    int newSize = 0;\n    for(int i=0; i<totalSize; i++)\n    {\n        Object value = inputArray[i];\n        if(value == null)\n        {\n            continue;\n        }\n\n        for(int j=i+1; j<totalSize; j++)\n        {\n            if(value.equals(inputArray[j]))\n            {\n                inputArray[j] = null;\n            }\n        }\n        resultArray[newSize++] = value;\n    }\n\n    long endTime = System.nanoTime()-startTime;\n    System.out.println(\"Total Time-B:\"+endTime);\n    return resultArray;\n} ", "question_id": 203984}, "0.20788288832409307", 3], [{"answer_votes": "0", "answer_comments": null, "answer_body": " Here is my answer without using any other data structure like set or hashmap etc.  public static <T> ArrayList<T> uniquefy(ArrayList<T> myList) {\n\n    ArrayList <T> uniqueArrayList = new ArrayList<T>();\n    for (int i = 0; i < myList.size(); i++){\n        if (!uniqueArrayList.contains(myList.get(i))){\n            uniqueArrayList.add(myList.get(i));\n        }\n    }\n\n    return uniqueArrayList;\n} ", "question_id": 203984}, "0.20788288832409307", 3], [{"answer_votes": "0", "answer_comments": null, "answer_body": " If you are using model type List< T>/ArrayList< T> . Hope,it's help you.   Here is my code without using any other data structure like set or hashmap  for(int i = 0; i < Models.size(); i++) {\n     for(int j = i + 1; j < Models.size(); j++) {                                \n       if(Models.get(i).getName().equals(Models.get(j).getName())){    \n                                Models.remove(j);\n\n                                j--;\n                            }\n                        }\n                    } ", "question_id": 203984}, "0.20788288832409307", 3], [{"answer_votes": "18", "answer_comments": [" It's slow and you might get a ConcurrentModificationException. \u2013 maaartinus  Oct 18 '13 at 9:39 ", " @maaartinus Have you tried that code ?. It won't produce any exceptions.Also it is pretty fast. I tried the code before posting. \u2013 CarlJohn  Oct 18 '13 at 10:35  ", " You're right, it doesn't as you iterate the array instead of the list. However, it's slow like hell. Try it with a few millions elements. Compare it to ImmutableSet.copyOf(lst).toList() . \u2013 maaartinus  Oct 18 '13 at 10:49  ", " answers the question I was asked in the interview .. How to remove repeated values from an ArrayList without using Sets. Thanx \u2013 Aniket Paul  May 5 '16 at 9:10 ", " Internally, indexOf iterates the lst using a for loop. \u2013 Patrick M  Jul 11 '16 at 17:32 "], "answer_body": " It is possible to remove duplicates from arraylist without using HashSet or one more arraylist .  Try this code..  ArrayList<String> lst = new ArrayList<String>();\n    lst.add(\"ABC\");\n    lst.add(\"ABC\");\n    lst.add(\"ABCD\");\n    lst.add(\"ABCD\");\n    lst.add(\"ABCE\");\n\n    System.out.println(\"Duplicates List \"+lst);\n\n    Object[] st = lst.toArray();\n      for (Object s : st) {\n        if (lst.indexOf(s) != lst.lastIndexOf(s)) {\n            lst.remove(lst.lastIndexOf(s));\n         }\n      }\n\n    System.out.println(\"Distinct List \"+lst);  Output is  Duplicates List [ABC, ABC, ABCD, ABCD, ABCE]\nDistinct List [ABC, ABCD, ABCE] ", "question_id": 203984}, "0.32890860363841057", 4], [{"answer_votes": "14", "answer_comments": [" Works perfect.. Thanks for saving my head from loops :) :) \u2013 Sanoop  Dec 21 '16 at 11:17 "], "answer_body": " You can also do it this way, and preserve order:  // delete duplicates (if any) from 'myArrayList'\nmyArrayList = new ArrayList<String>(new LinkedHashSet<String>(myArrayList)); ", "question_id": 203984}, "0.32890860363841057", 4], [{"answer_votes": "2", "answer_comments": null, "answer_body": " Code:  List<String> duplicatList = new ArrayList<String>();\nduplicatList = Arrays.asList(\"AA\",\"BB\",\"CC\",\"DD\",\"DD\",\"EE\",\"AA\",\"FF\");\n//above AA and DD are duplicate\nSet<String> uniqueList = new HashSet<String>(duplicatList);\nduplicatList = new ArrayList<String>(uniqueList); //let GC will doing free memory\nSystem.out.println(\"Removed Duplicate : \"+duplicatList);  Note: Definitely, there will be memory overhead. ", "question_id": 203984}, "0.32890860363841057", 4], [{"answer_votes": "2", "answer_comments": null, "answer_body": " ArrayList<String> city=new ArrayList<String>();\ncity.add(\"rajkot\");\ncity.add(\"gondal\");\ncity.add(\"rajkot\");\ncity.add(\"gova\");\ncity.add(\"baroda\");\ncity.add(\"morbi\");\ncity.add(\"gova\");\n\nHashSet<String> hashSet = new HashSet<String>();\nhashSet.addAll(city);\ncity.clear();\ncity.addAll(hashSet);\nToast.makeText(getActivity(),\"\" + city.toString(),Toast.LENGTH_SHORT).show(); ", "question_id": 203984}, "0.32890860363841057", 4], [{"answer_votes": "1", "answer_comments": null, "answer_body": " List<String> result = new ArrayList<String>();\n        Set<String> set = new LinkedHashSet<String>();\n        String s = \"ravi is a good!boy. But ravi is very nasty fellow.\";\n        StringTokenizer st = new StringTokenizer(s, \" ,. ,!\");\n        while (st.hasMoreTokens()) {\n            result.add(st.nextToken());\n        }\n         System.out.println(result);\n         set.addAll(result);\n        result.clear();\n        result.addAll(set);\n        System.out.println(result);\n\noutput:\n[ravi, is, a, good, boy, But, ravi, is, very, nasty, fellow]\n[ravi, is, a, good, boy, But, very, nasty, fellow] ", "question_id": 203984}, "0.32890860363841057", 4], [{"answer_votes": "1", "answer_comments": [" This thread is years old... \u2013 WolfieeifloW  Nov 30 '17 at 18:43 "], "answer_body": " you can use nested loop in follow :  ArrayList<Class1> l1 = new ArrayList<Class1>();\nArrayList<Class1> l2 = new ArrayList<Class1>();\n\n        Iterator iterator1 = l1.iterator();\n        boolean repeated = false;\n\n        while (iterator1.hasNext())\n        {\n            Class1 c1 = (Class1) iterator1.next();\n            for (Class1 _c: l2) {\n                if(_c.getId() == c1.getId())\n                    repeated = true;\n            }\n            if(!repeated)\n                l2.add(c1);\n        } ", "question_id": 203984}, "0.32890860363841057", 4], [{"answer_votes": "0", "answer_comments": null, "answer_body": " ArrayList<String> list = new ArrayList<String>();\n    HashSet<String> unique = new LinkedHashSet<String>();\n    HashSet<String> dup = new LinkedHashSet<String>();\n    boolean b = false;\n    list.add(\"Hello\");\n    list.add(\"Hello\");\n    list.add(\"how\");\n    list.add(\"are\");\n    list.add(\"u\");\n    list.add(\"u\");\n\n    for(Iterator iterator= list.iterator();iterator.hasNext();)\n    {\n        String value = (String)iterator.next();\n        System.out.println(value);\n\n        if(b==unique.add(value))\n            dup.add(value);\n        else\n            unique.add(value);\n\n\n    }\n    System.out.println(unique);\n    System.out.println(dup); ", "question_id": 203984}, "0.32890860363841057", 4], [{"answer_votes": "0", "answer_comments": null, "answer_body": " Would something like this work better ?  public static void removeDuplicates(ArrayList<String> list) {\nArraylist<Object> ar     = new Arraylist<Object>();\nArraylist<Object> tempAR = new Arraylist<Object>();\nwhile (list.size()>0){\n    ar.add(list(0));\n    list.removeall(Collections.singleton(list(0)));\n}\nlist.addAll(ar);  }  That should maintain the order and also not be quadratic in run time. ", "question_id": 203984}, "0.32890860363841057", 4], [{"answer_votes": "-1", "answer_comments": null, "answer_body": " In Java, List permits ordered access of their elements. They can have duplicates because their lookup key is the position not some hash code, every element can be modified while they remain in the list where as Set represents a collection of unique elements and while elements are in set, they must not be modified.While there is no restriction preventing you from modifying elements in a set, if an element is modified, then it could become forever lost in the set.  public static void main(String[] args) {  \n           List<String> l = new ArrayList<String>();  \n           l.add(\"A\");  \n           l.add(\"B\");  \n           l.add(\"C\");  \n           l.add(\"A\");  \n           System.out.println(\"Before removing duplicates: \");  \n           for (String s : l) {  \n                System.out.println(s);  \n           }  \n           Set<String> set = new HashSet<String>(l);  \n           List<String> newlist = new ArrayList<String>(set);  \n           System.out.println(\"after removing duplicates: \");  \n           for (String s : newlist) {  \n                System.out.println(s);  \n           }  \n      }  for reference , refer this link How to remove duplicates from ArrayList  ", "question_id": 203984}, "0.32890860363841057", 4]], [[{"answer_votes": "258", "answer_comments": [" Does LinkedHashSet make any guarantees as to which of several duplicates are kept from the list?  For instance, if position 1, 3, and 5 are duplicates in the original list, can we assume that this process will remove 3 and 5?  Or maybe remove 1 and 3?  Thanks. \u2013 Matt Brian\u00e7on  May 1 '11 at 2:20 ", " @Matt: yes, it does guarantee that. The docs say: \"This linked list defines the iteration ordering, which is the order in which elements were inserted into the set (insertion-order). Note that insertion order is not affected if an element is re-inserted into the set.\" \u2013 abahgat  May 2 '11 at 9:00 ", " Very interesting. I have a different situation here. I am not trying to sort String but another object called AwardYearSource. This class has an int attribute called year. So I want to remove duplicates based on the year. i.e if there is year 2010 mentioned more than once, I want to remove that AwardYearSource object. How can I do that? \u2013 WowBow  Apr 16 '12 at 15:27 ", " @WowBow For example you can define Wrapper object which holds AwardYearSource. And define this Wrapper objects equals method based on AwardYearSources year field. Then you can use Set with these Wrapper objects. \u2013 Ondrej Bozek  Jun 20 '12 at 12:19 ", " @WowBow or implement Comparable/Comparator \u2013 shrini1000  Jan 11 '13 at 5:09 "], "answer_body": " Although converting the ArrayList to a HashSet effectively removes duplicates, if you need to preserve insertion order, I'd rather suggest you to use this variant  // list is some List of Strings\nSet<String> s = new LinkedHashSet<>(list);  Then, if you need to get back a List reference, you can use again the conversion constructor. ", "question_id": 203984}, "0.36018345097545534", 0], [{"answer_votes": "83", "answer_comments": [" very elegant. Thanks \u2013 paskos  Feb 12 '15 at 20:04 ", " How do i do this for case insensitive distinct ? \u2013 StackFlowed  Sep 13 '16 at 20:04  ", " @StackFlowed If you don't need to preserve the order of the list you can addAll to new TreeSet<String>(String.CASE_INSENSITIVE_ORDER) .  The first element added will remain in the set so if your list contains \"Dog\" and \"dog\" (in that order) the TreeSet will contain \"Dog\". If order must be preserved then before the line in the answer put list.replaceAll(String::toUpperCase); . \u2013 Paul  Nov 3 '17 at 23:28  ", " I am getting this error :incompatible types: List<Object> cannot be converted to List<String> \u2013 Samir  Apr 4 at 14:34 "], "answer_body": " In Java 8:  List<String> deduped = list.stream().distinct().collect(Collectors.toList());  Please note that the hashCode-equals contract for list members should be respected for the filtering to work properly. ", "question_id": 203984}, "0.36018345097545534", 0], [{"answer_votes": "48", "answer_comments": [" Similarly at the bottom of the thread, I have given an answer where I am using Set for Custom Object. In a case if anyone have custom object like \"Contact\" or \"Student\" can use that answer that works fine for me. \u2013 Muhammad Adil  Oct 25 '16 at 14:16 "], "answer_body": " If you don't want duplicates, use a Set instead of a List . To convert a List to a Set you can use the following code:  // list is some List of Strings\nSet<String> s = new HashSet<String>(list);  If really necessary you can use the same construction to convert a Set back into a List . ", "question_id": 203984}, "0.36018345097545534", 0], [{"answer_votes": "24", "answer_comments": [" This answer lacks two things: 1) It does not use generics, but raw types ( ArrayList<T> should be used instead of ArrayList ) 2) The explicit iterator creating can be avoided by using a for (T current : l1) { ... } . Even if you wanted to use an Iterator explicitly, iterador is misspelled. \u2013 RAnders00  Dec 7 '15 at 16:22 ", " And this implementation runs in quadratic time, compared to the linked hash set implementation running in linear time. (i.e. this takes 10 times longer on a list with 10 elements, 10,000 times longer on a list with 10,000 elements. JDK 6 implementation for ArrayList.contains , JDK8 impl is the same.) \u2013 Patrick M  Jul 11 '16 at 16:09 "], "answer_body": " Here's a way that doesn't affect your list ordering:  ArrayList l1 = new ArrayList();\nArrayList l2 = new ArrayList();\n\nIterator iterator = l1.iterator();\n\n        while (iterator.hasNext())\n        {\n            YourClass o = (YourClass) iterator.next();\n            if(!l2.contains(o)) l2.add(o);\n        }  l1 is the original list, and l2 is the list whithout repeated items\n(Make sure YourClass has the equals method acording to what you want to stand for equality) ", "question_id": 203984}, "0.36018345097545534", 0], [{"answer_votes": "24", "answer_comments": [" +1 for Java 8 streams. But if case-sensitivity is not required then only Java 8 solution can be easily modified. List<String> deDupStringList3 = stringList.parallelStream().map(String::toLowerCase).distinct().collect(Collectors.toList()); should work. \u2013 Diablo  Jun 10 '16 at 8:13 "], "answer_body": " Suppose we have a list of String like:  List<String> strList = new ArrayList<>(5);\n// insert up to five items to list.  Then we can remove duplicate elements in in multiple ways.  Prior to Java 8  List<String> deDupStringList = new ArrayList<>(new HashSet<>(strList));  Using Guava  List<String> deDupStringList2 = Lists.newArrayList(Sets.newHashSet(strList));  Using Java 8  List<String> deDupStringList3 = strList.stream().distinct().collect(Collectors.toList());  Note: If we want to maintain the insertion order then we need to use LinkedHashSet in place of HashSet . ", "question_id": 203984}, "0.36018345097545534", 0], [{"answer_votes": "19", "answer_comments": [" Note that there is an ImmutableSet.asList() method, returning an ImmutableList , if you need it back as a List . \u2013 Andy Turner  Oct 27 '17 at 19:25 "], "answer_body": " There is also ImmutableSet from Guava as an option ( here is the documentation):  ImmutableSet.copyOf(list); ", "question_id": 203984}, "0.36018345097545534", 0], [{"answer_votes": "9", "answer_comments": [" I liked this solution better. \u2013 Tushar Gogna  Dec 5 '17 at 7:19 "], "answer_body": " this can solve the problem:  private List<SomeClass> clearListFromDuplicateFirstName(List<SomeClass> list1) {\n\nMap<String, SomeClass> cleanMap = new LinkedHashMap<String, SomeClass>();\nfor (int i = 0; i < list1.size(); i++) {\n     cleanMap.put(list1.get(i).getFirstName(), list1.get(i));\n}\nList<SomeClass> list = new ArrayList<SomeClass>(cleanMap.values());\nreturn list;\n} ", "question_id": 203984}, "0.36018345097545534", 0], [{"answer_votes": "2", "answer_comments": null, "answer_body": " If you want to preserve your Order then it is best to use LinkedHashSet .\nBecause if you want to pass this List to an Insert Query by Iterating it, the order would be preserved.  Try this  LinkedHashSet link=new LinkedHashSet();\nList listOfValues=new ArrayList();\nlistOfValues.add(link);  This conversion will be very helpful when you want to return a List but not a Set. ", "question_id": 203984}, "0.36018345097545534", 0], [{"answer_votes": "0", "answer_comments": null, "answer_body": " This is used for your Custom Objects list  public List<Contact> removeDuplicates(List<Contact> list) {\n    // Set set1 = new LinkedHashSet(list);\n    Set set = new TreeSet(new Comparator() {\n\n        @Override\n        public int compare(Object o1, Object o2) {\n            if (((Contact) o1).getId().equalsIgnoreCase(((Contact) o2).getId()) /*&&\n                    ((Contact)o1).getName().equalsIgnoreCase(((Contact)o2).getName())*/) {\n                return 0;\n            }\n            return 1;\n        }\n    });\n    set.addAll(list);\n\n    final List newList = new ArrayList(set);\n    return newList;\n} ", "question_id": 203984}, "0.36018345097545534", 0], [{"answer_votes": "18", "answer_comments": [" It's slow and you might get a ConcurrentModificationException. \u2013 maaartinus  Oct 18 '13 at 9:39 ", " @maaartinus Have you tried that code ?. It won't produce any exceptions.Also it is pretty fast. I tried the code before posting. \u2013 CarlJohn  Oct 18 '13 at 10:35  ", " You're right, it doesn't as you iterate the array instead of the list. However, it's slow like hell. Try it with a few millions elements. Compare it to ImmutableSet.copyOf(lst).toList() . \u2013 maaartinus  Oct 18 '13 at 10:49  ", " answers the question I was asked in the interview .. How to remove repeated values from an ArrayList without using Sets. Thanx \u2013 Aniket Paul  May 5 '16 at 9:10 ", " Internally, indexOf iterates the lst using a for loop. \u2013 Patrick M  Jul 11 '16 at 17:32 "], "answer_body": " It is possible to remove duplicates from arraylist without using HashSet or one more arraylist .  Try this code..  ArrayList<String> lst = new ArrayList<String>();\n    lst.add(\"ABC\");\n    lst.add(\"ABC\");\n    lst.add(\"ABCD\");\n    lst.add(\"ABCD\");\n    lst.add(\"ABCE\");\n\n    System.out.println(\"Duplicates List \"+lst);\n\n    Object[] st = lst.toArray();\n      for (Object s : st) {\n        if (lst.indexOf(s) != lst.lastIndexOf(s)) {\n            lst.remove(lst.lastIndexOf(s));\n         }\n      }\n\n    System.out.println(\"Distinct List \"+lst);  Output is  Duplicates List [ABC, ABC, ABCD, ABCD, ABCE]\nDistinct List [ABC, ABCD, ABCE] ", "question_id": 203984}, "0.32890860363841057", 4], [{"answer_votes": "14", "answer_comments": [" Works perfect.. Thanks for saving my head from loops :) :) \u2013 Sanoop  Dec 21 '16 at 11:17 "], "answer_body": " You can also do it this way, and preserve order:  // delete duplicates (if any) from 'myArrayList'\nmyArrayList = new ArrayList<String>(new LinkedHashSet<String>(myArrayList)); ", "question_id": 203984}, "0.32890860363841057", 4], [{"answer_votes": "2", "answer_comments": null, "answer_body": " Code:  List<String> duplicatList = new ArrayList<String>();\nduplicatList = Arrays.asList(\"AA\",\"BB\",\"CC\",\"DD\",\"DD\",\"EE\",\"AA\",\"FF\");\n//above AA and DD are duplicate\nSet<String> uniqueList = new HashSet<String>(duplicatList);\nduplicatList = new ArrayList<String>(uniqueList); //let GC will doing free memory\nSystem.out.println(\"Removed Duplicate : \"+duplicatList);  Note: Definitely, there will be memory overhead. ", "question_id": 203984}, "0.32890860363841057", 4], [{"answer_votes": "2", "answer_comments": null, "answer_body": " ArrayList<String> city=new ArrayList<String>();\ncity.add(\"rajkot\");\ncity.add(\"gondal\");\ncity.add(\"rajkot\");\ncity.add(\"gova\");\ncity.add(\"baroda\");\ncity.add(\"morbi\");\ncity.add(\"gova\");\n\nHashSet<String> hashSet = new HashSet<String>();\nhashSet.addAll(city);\ncity.clear();\ncity.addAll(hashSet);\nToast.makeText(getActivity(),\"\" + city.toString(),Toast.LENGTH_SHORT).show(); ", "question_id": 203984}, "0.32890860363841057", 4], [{"answer_votes": "1", "answer_comments": null, "answer_body": " List<String> result = new ArrayList<String>();\n        Set<String> set = new LinkedHashSet<String>();\n        String s = \"ravi is a good!boy. But ravi is very nasty fellow.\";\n        StringTokenizer st = new StringTokenizer(s, \" ,. ,!\");\n        while (st.hasMoreTokens()) {\n            result.add(st.nextToken());\n        }\n         System.out.println(result);\n         set.addAll(result);\n        result.clear();\n        result.addAll(set);\n        System.out.println(result);\n\noutput:\n[ravi, is, a, good, boy, But, ravi, is, very, nasty, fellow]\n[ravi, is, a, good, boy, But, very, nasty, fellow] ", "question_id": 203984}, "0.32890860363841057", 4], [{"answer_votes": "1", "answer_comments": [" This thread is years old... \u2013 WolfieeifloW  Nov 30 '17 at 18:43 "], "answer_body": " you can use nested loop in follow :  ArrayList<Class1> l1 = new ArrayList<Class1>();\nArrayList<Class1> l2 = new ArrayList<Class1>();\n\n        Iterator iterator1 = l1.iterator();\n        boolean repeated = false;\n\n        while (iterator1.hasNext())\n        {\n            Class1 c1 = (Class1) iterator1.next();\n            for (Class1 _c: l2) {\n                if(_c.getId() == c1.getId())\n                    repeated = true;\n            }\n            if(!repeated)\n                l2.add(c1);\n        } ", "question_id": 203984}, "0.32890860363841057", 4], [{"answer_votes": "0", "answer_comments": null, "answer_body": " ArrayList<String> list = new ArrayList<String>();\n    HashSet<String> unique = new LinkedHashSet<String>();\n    HashSet<String> dup = new LinkedHashSet<String>();\n    boolean b = false;\n    list.add(\"Hello\");\n    list.add(\"Hello\");\n    list.add(\"how\");\n    list.add(\"are\");\n    list.add(\"u\");\n    list.add(\"u\");\n\n    for(Iterator iterator= list.iterator();iterator.hasNext();)\n    {\n        String value = (String)iterator.next();\n        System.out.println(value);\n\n        if(b==unique.add(value))\n            dup.add(value);\n        else\n            unique.add(value);\n\n\n    }\n    System.out.println(unique);\n    System.out.println(dup); ", "question_id": 203984}, "0.32890860363841057", 4], [{"answer_votes": "0", "answer_comments": null, "answer_body": " Would something like this work better ?  public static void removeDuplicates(ArrayList<String> list) {\nArraylist<Object> ar     = new Arraylist<Object>();\nArraylist<Object> tempAR = new Arraylist<Object>();\nwhile (list.size()>0){\n    ar.add(list(0));\n    list.removeall(Collections.singleton(list(0)));\n}\nlist.addAll(ar);  }  That should maintain the order and also not be quadratic in run time. ", "question_id": 203984}, "0.32890860363841057", 4], [{"answer_votes": "-1", "answer_comments": null, "answer_body": " In Java, List permits ordered access of their elements. They can have duplicates because their lookup key is the position not some hash code, every element can be modified while they remain in the list where as Set represents a collection of unique elements and while elements are in set, they must not be modified.While there is no restriction preventing you from modifying elements in a set, if an element is modified, then it could become forever lost in the set.  public static void main(String[] args) {  \n           List<String> l = new ArrayList<String>();  \n           l.add(\"A\");  \n           l.add(\"B\");  \n           l.add(\"C\");  \n           l.add(\"A\");  \n           System.out.println(\"Before removing duplicates: \");  \n           for (String s : l) {  \n                System.out.println(s);  \n           }  \n           Set<String> set = new HashSet<String>(l);  \n           List<String> newlist = new ArrayList<String>(set);  \n           System.out.println(\"after removing duplicates: \");  \n           for (String s : newlist) {  \n                System.out.println(s);  \n           }  \n      }  for reference , refer this link How to remove duplicates from ArrayList  ", "question_id": 203984}, "0.32890860363841057", 4], [{"answer_votes": "824", "answer_comments": [" See also LinkedHashSet, if you wish to retain the order. \u2013 volley  Dec 9 '09 at 20:38 ", " But this will just create the set without duplicates , I want to know which number was duplicate in O(n) time \u2013 Chetan  Mar 29 '12 at 19:43 ", " @Chetan finding all duplicates from ArrayList in O(n), its important to have correctly defined equals method on objects which you have in the list (no problem for numbers): public Set<Object> findDuplicates(List<Object> list)       {           Set<Object> items = new HashSet<Object>();           Set<Object> duplicates = new HashSet<Object>();           for (Object item : list) {               if (items.contains(item)) {                   duplicates.add(item);               } else {                   items.add(item);               }           }           return duplicates;       } \u2013 Ondrej Bozek  Jun 20 '12 at 12:06  ", " A good practice would be to define variables using the interface types List and Set (instead of implementation types ArrayList and HashSet as in your example). \u2013 Jonik  Aug 29 '13 at 7:27 ", " You can clean this up by using new HashSet(al) instead of initializing it to empty and calling addAll . \u2013 ashes999  Dec 26 '13 at 12:44 "], "answer_body": " If you don't want duplicates in a Collection , you should consider why you're using a Collection that allows duplicates. The easiest way to remove repeated elements is to add the contents to a Set (which will not allow duplicates) and then add the Set back to the ArrayList :  List<String> al = new ArrayList<>();\n// add elements to al, including duplicates\nSet<String> hs = new HashSet<>();\nhs.addAll(al);\nal.clear();\nal.addAll(hs);  Of course, this destroys the ordering of the elements in the ArrayList . ", "question_id": 203984}, "0.27532320842146873", 2], [{"answer_votes": "19", "answer_comments": null, "answer_body": " Java 8 streams provide a very simple way to remove duplicate elements from a list. Using the distinct method.\nIf we have a list of cities and we want to remove duplicates from that list it can be done in a single line -  List<String> cityList = new ArrayList<>();\n cityList.add(\"Delhi\");\n cityList.add(\"Mumbai\");\n cityList.add(\"Bangalore\");\n cityList.add(\"Chennai\");\n cityList.add(\"Kolkata\");\n cityList.add(\"Mumbai\");\n\n cityList = cityList.stream().distinct().collect(Collectors.toList());  How to remove duplicate elements from an arraylist ", "question_id": 203984}, "0.27532320842146873", 2], [{"answer_votes": "3", "answer_comments": null, "answer_body": " This three lines of code can remove the duplicated element from ArrayList or any collection.  List<Entity> entities = repository.findByUserId(userId);\n\nSet<Entity> s = new LinkedHashSet<Entity>(entities);\nentities.clear();\nentities.addAll(s); ", "question_id": 203984}, "0.27532320842146873", 2], [{"answer_votes": "1", "answer_comments": null, "answer_body": " As said before, you should use a class implementing Set interface instead of List to be sure of unicity of elements. If you have to keep the order of elements, the SortedSet interface can then be used ; the TreeSet class implements that interface. ", "question_id": 203984}, "0.27532320842146873", 2], [{"answer_votes": "0", "answer_comments": null, "answer_body": " public Set<Object> findDuplicates(List<Object> list) {\n        Set<Object> items = new HashSet<Object>();\n        Set<Object> duplicates = new HashSet<Object>();\n        for (Object item : list) {\n            if (items.contains(item)) {\n                duplicates.add(item);\n                } else { \n                    items.add(item);\n                    } \n            } \n        return duplicates;\n        } ", "question_id": 203984}, "0.27532320842146873", 2], [{"answer_votes": "0", "answer_comments": null, "answer_body": " The @jonathan-stafford solution is OK. But this don't preserve the list order.  If you want preserve the list order you have to use this:  public static <T> void removeDuplicate(List <T> list) {\nSet <T> set = new HashSet <T>();\nList <T> newList = new ArrayList <T>();\nfor (Iterator <T>iter = list.iterator();    iter.hasNext(); ) {\n   Object element = iter.next();\n   if (set.add((T) element))\n      newList.add((T) element);\n   }\n   list.clear();\n   list.addAll(newList);\n}  It's only to complete the answer. Very good! ", "question_id": 203984}, "0.27532320842146873", 2], [{"answer_votes": "8", "answer_comments": [" This implementation return no element in the list because of the last j-- \u2013 neo7  Sep 23 '15 at 9:29 ", " This implementation work's very fine.there is no issue behind this and for this task i am only use one arraylist.so this answer is completely good.before giving negative feedback you shold also add testcase also so that every one can understand the result.Thanks Manash \u2013 Manash Ranjan Dakua  Sep 24 '15 at 13:14 ", " This saved the day! \u2013 YehCheez  Mar 9 '16 at 16:09 "], "answer_body": " public static void main(String[] args){\n    ArrayList<Object> al = new ArrayList<Object>();\n    al.add(\"abc\");\n    al.add('a');\n    al.add('b');\n    al.add('a');\n    al.add(\"abc\");\n    al.add(10.3);\n    al.add('c');\n    al.add(10);\n    al.add(\"abc\");\n    al.add(10);\n    System.out.println(\"Before Duplicate Remove:\"+al);\n    for(int i=0;i<al.size();i++){\n        for(int j=i+1;j<al.size();j++){\n            if(al.get(i).equals(al.get(j))){\n                al.remove(j);\n                j--;\n            }\n        }\n    }\n    System.out.println(\"After Removing duplicate:\"+al);\n} ", "question_id": 203984}, "0.2675104020163417", 1], [{"answer_votes": "1", "answer_comments": null, "answer_body": " LinkedHashSet will do the trick.  String[] arr2 = {\"5\",\"1\",\"2\",\"3\",\"3\",\"4\",\"1\",\"2\"};\nSet<String> set = new LinkedHashSet<String>(Arrays.asList(arr2));\nfor(String s1 : set)\n    System.out.println(s1);\n\nSystem.out.println( \"------------------------\" );\nString[] arr3 = set.toArray(new String[0]);\nfor(int i = 0; i < arr3.length; i++)\n     System.out.println(arr3[i].toString());  //output: 5,1,2,3,4 ", "question_id": 203984}, "0.2675104020163417", 1], [{"answer_votes": "0", "answer_comments": null, "answer_body": " import java.util.*;\nclass RemoveDupFrmString\n{\n    public static void main(String[] args)\n    {\n\n        String s=\"appsc\";\n\n        Set<Character> unique = new LinkedHashSet<Character> ();\n\n        for(char c : s.toCharArray()) {\n\n            System.out.println(unique.add(c));\n        }\n        for(char dis:unique){\n            System.out.println(dis);\n        }\n\n\n    }\n} ", "question_id": 203984}, "0.2675104020163417", 1], [{"answer_votes": "10", "answer_comments": [" Why use ArrayList in parameter? Why not just List? Will that not work? \u2013 Shervin Asgari  Nov 12 '09 at 15:54 ", " A List will absolutely work as in-parameter for the first method listed. The method is however optimized for use with a random access list such as ArrayList, so if a LinkedList is passed instead you will get poor performance. For example, setting the n:th element in a LinkedList takes O(n) time, whereas setting the n:th element in a random access list (such as ArrayList) takes O(1) time. Again, though, this is probably overkill... If you need this kind of specialized code it will hopefully be in an isolated situation. \u2013 volley  Dec 9 '09 at 20:37 ", " This is precisely what I needed, thanks \u2013 Jasper Holton  Jun 1 '14 at 2:15 "], "answer_body": " Probably a bit overkill, but I enjoy this kind of isolated problem. :)  This code uses a temporary Set (for the uniqueness check) but removes elements directly inside the original list. Since element removal inside an ArrayList can induce a huge amount of array copying, the remove(int)-method is avoided.  public static <T> void removeDuplicates(ArrayList<T> list) {\n    int size = list.size();\n    int out = 0;\n    {\n        final Set<T> encountered = new HashSet<T>();\n        for (int in = 0; in < size; in++) {\n            final T t = list.get(in);\n            final boolean first = encountered.add(t);\n            if (first) {\n                list.set(out++, t);\n            }\n        }\n    }\n    while (out < size) {\n        list.remove(--size);\n    }\n}  While we're at it, here's a version for LinkedList (a lot nicer!):  public static <T> void removeDuplicates(LinkedList<T> list) {\n    final Set<T> encountered = new HashSet<T>();\n    for (Iterator<T> iter = list.iterator(); iter.hasNext(); ) {\n        final T t = iter.next();\n        final boolean first = encountered.add(t);\n        if (!first) {\n            iter.remove();\n        }\n    }\n}  Use the marker interface to present a unified solution for List:  public static <T> void removeDuplicates(List<T> list) {\n    if (list instanceof RandomAccess) {\n        // use first version here\n    } else {\n        // use other version here\n    }\n}  EDIT: I guess the generics-stuff doesn't really add any value here.. Oh well. :) ", "question_id": 203984}, "0.20788288832409307", 3], [{"answer_votes": "5", "answer_comments": null, "answer_body": " If you're willing to use a third-party library, you can use the method distinct() in Eclipse Collections (formerly GS Collections).  ListIterable<Integer> integers = FastList.newListWith(1, 3, 1, 2, 2, 1);\nAssert.assertEquals(\n    FastList.newListWith(1, 3, 2),\n    integers.distinct());  The advantage of using distinct() instead of converting to a Set and then back to a List is that distinct() preserves the order of the original List, retaining the first occurrence of each element. It's implemented by using both a Set and a List.  MutableSet<T> seenSoFar = UnifiedSet.newSet();\nint size = list.size();\nfor (int i = 0; i < size; i++)\n{\n    T item = list.get(i);\n    if (seenSoFar.add(item))\n    {\n        targetCollection.add(item);\n    }\n}\nreturn targetCollection;  If you cannot convert your original List into an Eclipse Collections type, you can use ListAdapter to get the same API.  MutableList<Integer> distinct = ListAdapter.adapt(integers).distinct();  Note: I am a committer for Eclipse Collections. ", "question_id": 203984}, "0.20788288832409307", 3], [{"answer_votes": "2", "answer_comments": null, "answer_body": " When you are filling the ArrayList, use a condition for each element. For example:  ArrayList< Integer > al = new ArrayList< Integer >(); \n\n    // fill 1 \n    for ( int i = 0; i <= 5; i++ ) \n        if ( !al.contains( i ) ) \n            al.add( i ); \n\n    // fill 2 \n    for (int i = 0; i <= 10; i++ ) \n        if ( !al.contains( i ) ) \n            al.add( i ); \n\n    for( Integer i: al )\n    {\n        System.out.print( i + \" \");     \n    }  We will get an array {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10} ", "question_id": 203984}, "0.20788288832409307", 3], [{"answer_votes": "0", "answer_comments": null, "answer_body": " for(int a=0;a<myArray.size();a++){\n        for(int b=a+1;b<myArray.size();b++){\n            if(myArray.get(a).equalsIgnoreCase(myArray.get(b))){\n                myArray.remove(b); \n                dups++;\n                b--;\n            }\n        }\n} ", "question_id": 203984}, "0.20788288832409307", 3], [{"answer_votes": "0", "answer_comments": [" Why would you post a quadratic solution to a question that already has 2-year-old linear and log-linear solutions, that are also simpler? \u2013 abarnert  Sep 11 '14 at 7:40 "], "answer_body": " If you want to remove duplicates from ArrayList means find the below logic,  public static Object[] removeDuplicate(Object[] inputArray)\n{\n    long startTime = System.nanoTime();\n    int totalSize = inputArray.length;\n    Object[] resultArray = new Object[totalSize];\n    int newSize = 0;\n    for(int i=0; i<totalSize; i++)\n    {\n        Object value = inputArray[i];\n        if(value == null)\n        {\n            continue;\n        }\n\n        for(int j=i+1; j<totalSize; j++)\n        {\n            if(value.equals(inputArray[j]))\n            {\n                inputArray[j] = null;\n            }\n        }\n        resultArray[newSize++] = value;\n    }\n\n    long endTime = System.nanoTime()-startTime;\n    System.out.println(\"Total Time-B:\"+endTime);\n    return resultArray;\n} ", "question_id": 203984}, "0.20788288832409307", 3], [{"answer_votes": "0", "answer_comments": null, "answer_body": " Here is my answer without using any other data structure like set or hashmap etc.  public static <T> ArrayList<T> uniquefy(ArrayList<T> myList) {\n\n    ArrayList <T> uniqueArrayList = new ArrayList<T>();\n    for (int i = 0; i < myList.size(); i++){\n        if (!uniqueArrayList.contains(myList.get(i))){\n            uniqueArrayList.add(myList.get(i));\n        }\n    }\n\n    return uniqueArrayList;\n} ", "question_id": 203984}, "0.20788288832409307", 3], [{"answer_votes": "0", "answer_comments": null, "answer_body": " If you are using model type List< T>/ArrayList< T> . Hope,it's help you.   Here is my code without using any other data structure like set or hashmap  for(int i = 0; i < Models.size(); i++) {\n     for(int j = i + 1; j < Models.size(); j++) {                                \n       if(Models.get(i).getName().equals(Models.get(j).getName())){    \n                                Models.remove(j);\n\n                                j--;\n                            }\n                        }\n                    } ", "question_id": 203984}, "0.20788288832409307", 3]], [[{"answer_votes": "258", "answer_comments": [" Does LinkedHashSet make any guarantees as to which of several duplicates are kept from the list?  For instance, if position 1, 3, and 5 are duplicates in the original list, can we assume that this process will remove 3 and 5?  Or maybe remove 1 and 3?  Thanks. \u2013 Matt Brian\u00e7on  May 1 '11 at 2:20 ", " @Matt: yes, it does guarantee that. The docs say: \"This linked list defines the iteration ordering, which is the order in which elements were inserted into the set (insertion-order). Note that insertion order is not affected if an element is re-inserted into the set.\" \u2013 abahgat  May 2 '11 at 9:00 ", " Very interesting. I have a different situation here. I am not trying to sort String but another object called AwardYearSource. This class has an int attribute called year. So I want to remove duplicates based on the year. i.e if there is year 2010 mentioned more than once, I want to remove that AwardYearSource object. How can I do that? \u2013 WowBow  Apr 16 '12 at 15:27 ", " @WowBow For example you can define Wrapper object which holds AwardYearSource. And define this Wrapper objects equals method based on AwardYearSources year field. Then you can use Set with these Wrapper objects. \u2013 Ondrej Bozek  Jun 20 '12 at 12:19 ", " @WowBow or implement Comparable/Comparator \u2013 shrini1000  Jan 11 '13 at 5:09 "], "answer_body": " Although converting the ArrayList to a HashSet effectively removes duplicates, if you need to preserve insertion order, I'd rather suggest you to use this variant  // list is some List of Strings\nSet<String> s = new LinkedHashSet<>(list);  Then, if you need to get back a List reference, you can use again the conversion constructor. ", "question_id": 203984}, "0.36018345097545534", 0], [{"answer_votes": "18", "answer_comments": [" It's slow and you might get a ConcurrentModificationException. \u2013 maaartinus  Oct 18 '13 at 9:39 ", " @maaartinus Have you tried that code ?. It won't produce any exceptions.Also it is pretty fast. I tried the code before posting. \u2013 CarlJohn  Oct 18 '13 at 10:35  ", " You're right, it doesn't as you iterate the array instead of the list. However, it's slow like hell. Try it with a few millions elements. Compare it to ImmutableSet.copyOf(lst).toList() . \u2013 maaartinus  Oct 18 '13 at 10:49  ", " answers the question I was asked in the interview .. How to remove repeated values from an ArrayList without using Sets. Thanx \u2013 Aniket Paul  May 5 '16 at 9:10 ", " Internally, indexOf iterates the lst using a for loop. \u2013 Patrick M  Jul 11 '16 at 17:32 "], "answer_body": " It is possible to remove duplicates from arraylist without using HashSet or one more arraylist .  Try this code..  ArrayList<String> lst = new ArrayList<String>();\n    lst.add(\"ABC\");\n    lst.add(\"ABC\");\n    lst.add(\"ABCD\");\n    lst.add(\"ABCD\");\n    lst.add(\"ABCE\");\n\n    System.out.println(\"Duplicates List \"+lst);\n\n    Object[] st = lst.toArray();\n      for (Object s : st) {\n        if (lst.indexOf(s) != lst.lastIndexOf(s)) {\n            lst.remove(lst.lastIndexOf(s));\n         }\n      }\n\n    System.out.println(\"Distinct List \"+lst);  Output is  Duplicates List [ABC, ABC, ABCD, ABCD, ABCE]\nDistinct List [ABC, ABCD, ABCE] ", "question_id": 203984}, "0.32890860363841057", 4], [{"answer_votes": "824", "answer_comments": [" See also LinkedHashSet, if you wish to retain the order. \u2013 volley  Dec 9 '09 at 20:38 ", " But this will just create the set without duplicates , I want to know which number was duplicate in O(n) time \u2013 Chetan  Mar 29 '12 at 19:43 ", " @Chetan finding all duplicates from ArrayList in O(n), its important to have correctly defined equals method on objects which you have in the list (no problem for numbers): public Set<Object> findDuplicates(List<Object> list)       {           Set<Object> items = new HashSet<Object>();           Set<Object> duplicates = new HashSet<Object>();           for (Object item : list) {               if (items.contains(item)) {                   duplicates.add(item);               } else {                   items.add(item);               }           }           return duplicates;       } \u2013 Ondrej Bozek  Jun 20 '12 at 12:06  ", " A good practice would be to define variables using the interface types List and Set (instead of implementation types ArrayList and HashSet as in your example). \u2013 Jonik  Aug 29 '13 at 7:27 ", " You can clean this up by using new HashSet(al) instead of initializing it to empty and calling addAll . \u2013 ashes999  Dec 26 '13 at 12:44 "], "answer_body": " If you don't want duplicates in a Collection , you should consider why you're using a Collection that allows duplicates. The easiest way to remove repeated elements is to add the contents to a Set (which will not allow duplicates) and then add the Set back to the ArrayList :  List<String> al = new ArrayList<>();\n// add elements to al, including duplicates\nSet<String> hs = new HashSet<>();\nhs.addAll(al);\nal.clear();\nal.addAll(hs);  Of course, this destroys the ordering of the elements in the ArrayList . ", "question_id": 203984}, "0.27532320842146873", 2], [{"answer_votes": "8", "answer_comments": [" This implementation return no element in the list because of the last j-- \u2013 neo7  Sep 23 '15 at 9:29 ", " This implementation work's very fine.there is no issue behind this and for this task i am only use one arraylist.so this answer is completely good.before giving negative feedback you shold also add testcase also so that every one can understand the result.Thanks Manash \u2013 Manash Ranjan Dakua  Sep 24 '15 at 13:14 ", " This saved the day! \u2013 YehCheez  Mar 9 '16 at 16:09 "], "answer_body": " public static void main(String[] args){\n    ArrayList<Object> al = new ArrayList<Object>();\n    al.add(\"abc\");\n    al.add('a');\n    al.add('b');\n    al.add('a');\n    al.add(\"abc\");\n    al.add(10.3);\n    al.add('c');\n    al.add(10);\n    al.add(\"abc\");\n    al.add(10);\n    System.out.println(\"Before Duplicate Remove:\"+al);\n    for(int i=0;i<al.size();i++){\n        for(int j=i+1;j<al.size();j++){\n            if(al.get(i).equals(al.get(j))){\n                al.remove(j);\n                j--;\n            }\n        }\n    }\n    System.out.println(\"After Removing duplicate:\"+al);\n} ", "question_id": 203984}, "0.2675104020163417", 1], [{"answer_votes": "10", "answer_comments": [" Why use ArrayList in parameter? Why not just List? Will that not work? \u2013 Shervin Asgari  Nov 12 '09 at 15:54 ", " A List will absolutely work as in-parameter for the first method listed. The method is however optimized for use with a random access list such as ArrayList, so if a LinkedList is passed instead you will get poor performance. For example, setting the n:th element in a LinkedList takes O(n) time, whereas setting the n:th element in a random access list (such as ArrayList) takes O(1) time. Again, though, this is probably overkill... If you need this kind of specialized code it will hopefully be in an isolated situation. \u2013 volley  Dec 9 '09 at 20:37 ", " This is precisely what I needed, thanks \u2013 Jasper Holton  Jun 1 '14 at 2:15 "], "answer_body": " Probably a bit overkill, but I enjoy this kind of isolated problem. :)  This code uses a temporary Set (for the uniqueness check) but removes elements directly inside the original list. Since element removal inside an ArrayList can induce a huge amount of array copying, the remove(int)-method is avoided.  public static <T> void removeDuplicates(ArrayList<T> list) {\n    int size = list.size();\n    int out = 0;\n    {\n        final Set<T> encountered = new HashSet<T>();\n        for (int in = 0; in < size; in++) {\n            final T t = list.get(in);\n            final boolean first = encountered.add(t);\n            if (first) {\n                list.set(out++, t);\n            }\n        }\n    }\n    while (out < size) {\n        list.remove(--size);\n    }\n}  While we're at it, here's a version for LinkedList (a lot nicer!):  public static <T> void removeDuplicates(LinkedList<T> list) {\n    final Set<T> encountered = new HashSet<T>();\n    for (Iterator<T> iter = list.iterator(); iter.hasNext(); ) {\n        final T t = iter.next();\n        final boolean first = encountered.add(t);\n        if (!first) {\n            iter.remove();\n        }\n    }\n}  Use the marker interface to present a unified solution for List:  public static <T> void removeDuplicates(List<T> list) {\n    if (list instanceof RandomAccess) {\n        // use first version here\n    } else {\n        // use other version here\n    }\n}  EDIT: I guess the generics-stuff doesn't really add any value here.. Oh well. :) ", "question_id": 203984}, "0.20788288832409307", 3]]], "gensim_similarity_tf_idf_code_result": [[{"answer_votes": "48", "answer_comments": [" Similarly at the bottom of the thread, I have given an answer where I am using Set for Custom Object. In a case if anyone have custom object like \"Contact\" or \"Student\" can use that answer that works fine for me. \u2013 Muhammad Adil  Oct 25 '16 at 14:16 "], "answer_body": " If you don't want duplicates, use a Set instead of a List . To convert a List to a Set you can use the following code:  // list is some List of Strings\nSet<String> s = new HashSet<String>(list);  If really necessary you can use the same construction to convert a Set back into a List . ", "question_id": 203984}, "0.18222517"], [{"answer_votes": "258", "answer_comments": [" Does LinkedHashSet make any guarantees as to which of several duplicates are kept from the list?  For instance, if position 1, 3, and 5 are duplicates in the original list, can we assume that this process will remove 3 and 5?  Or maybe remove 1 and 3?  Thanks. \u2013 Matt Brian\u00e7on  May 1 '11 at 2:20 ", " @Matt: yes, it does guarantee that. The docs say: \"This linked list defines the iteration ordering, which is the order in which elements were inserted into the set (insertion-order). Note that insertion order is not affected if an element is re-inserted into the set.\" \u2013 abahgat  May 2 '11 at 9:00 ", " Very interesting. I have a different situation here. I am not trying to sort String but another object called AwardYearSource. This class has an int attribute called year. So I want to remove duplicates based on the year. i.e if there is year 2010 mentioned more than once, I want to remove that AwardYearSource object. How can I do that? \u2013 WowBow  Apr 16 '12 at 15:27 ", " @WowBow For example you can define Wrapper object which holds AwardYearSource. And define this Wrapper objects equals method based on AwardYearSources year field. Then you can use Set with these Wrapper objects. \u2013 Ondrej Bozek  Jun 20 '12 at 12:19 ", " @WowBow or implement Comparable/Comparator \u2013 shrini1000  Jan 11 '13 at 5:09 "], "answer_body": " Although converting the ArrayList to a HashSet effectively removes duplicates, if you need to preserve insertion order, I'd rather suggest you to use this variant  // list is some List of Strings\nSet<String> s = new LinkedHashSet<>(list);  Then, if you need to get back a List reference, you can use again the conversion constructor. ", "question_id": 203984}, "0.16995028"], [{"answer_votes": "824", "answer_comments": [" See also LinkedHashSet, if you wish to retain the order. \u2013 volley  Dec 9 '09 at 20:38 ", " But this will just create the set without duplicates , I want to know which number was duplicate in O(n) time \u2013 Chetan  Mar 29 '12 at 19:43 ", " @Chetan finding all duplicates from ArrayList in O(n), its important to have correctly defined equals method on objects which you have in the list (no problem for numbers): public Set<Object> findDuplicates(List<Object> list)       {           Set<Object> items = new HashSet<Object>();           Set<Object> duplicates = new HashSet<Object>();           for (Object item : list) {               if (items.contains(item)) {                   duplicates.add(item);               } else {                   items.add(item);               }           }           return duplicates;       } \u2013 Ondrej Bozek  Jun 20 '12 at 12:06  ", " A good practice would be to define variables using the interface types List and Set (instead of implementation types ArrayList and HashSet as in your example). \u2013 Jonik  Aug 29 '13 at 7:27 ", " You can clean this up by using new HashSet(al) instead of initializing it to empty and calling addAll . \u2013 ashes999  Dec 26 '13 at 12:44 "], "answer_body": " If you don't want duplicates in a Collection , you should consider why you're using a Collection that allows duplicates. The easiest way to remove repeated elements is to add the contents to a Set (which will not allow duplicates) and then add the Set back to the ArrayList :  List<String> al = new ArrayList<>();\n// add elements to al, including duplicates\nSet<String> hs = new HashSet<>();\nhs.addAll(al);\nal.clear();\nal.addAll(hs);  Of course, this destroys the ordering of the elements in the ArrayList . ", "question_id": 203984}, "0.0"], [{"answer_votes": "83", "answer_comments": [" very elegant. Thanks \u2013 paskos  Feb 12 '15 at 20:04 ", " How do i do this for case insensitive distinct ? \u2013 StackFlowed  Sep 13 '16 at 20:04  ", " @StackFlowed If you don't need to preserve the order of the list you can addAll to new TreeSet<String>(String.CASE_INSENSITIVE_ORDER) .  The first element added will remain in the set so if your list contains \"Dog\" and \"dog\" (in that order) the TreeSet will contain \"Dog\". If order must be preserved then before the line in the answer put list.replaceAll(String::toUpperCase); . \u2013 Paul  Nov 3 '17 at 23:28  ", " I am getting this error :incompatible types: List<Object> cannot be converted to List<String> \u2013 Samir  Apr 4 at 14:34 "], "answer_body": " In Java 8:  List<String> deduped = list.stream().distinct().collect(Collectors.toList());  Please note that the hashCode-equals contract for list members should be respected for the filtering to work properly. ", "question_id": 203984}, "0.0"], [{"answer_votes": "24", "answer_comments": [" This answer lacks two things: 1) It does not use generics, but raw types ( ArrayList<T> should be used instead of ArrayList ) 2) The explicit iterator creating can be avoided by using a for (T current : l1) { ... } . Even if you wanted to use an Iterator explicitly, iterador is misspelled. \u2013 RAnders00  Dec 7 '15 at 16:22 ", " And this implementation runs in quadratic time, compared to the linked hash set implementation running in linear time. (i.e. this takes 10 times longer on a list with 10 elements, 10,000 times longer on a list with 10,000 elements. JDK 6 implementation for ArrayList.contains , JDK8 impl is the same.) \u2013 Patrick M  Jul 11 '16 at 16:09 "], "answer_body": " Here's a way that doesn't affect your list ordering:  ArrayList l1 = new ArrayList();\nArrayList l2 = new ArrayList();\n\nIterator iterator = l1.iterator();\n\n        while (iterator.hasNext())\n        {\n            YourClass o = (YourClass) iterator.next();\n            if(!l2.contains(o)) l2.add(o);\n        }  l1 is the original list, and l2 is the list whithout repeated items\n(Make sure YourClass has the equals method acording to what you want to stand for equality) ", "question_id": 203984}, "0.0"], [{"answer_votes": "24", "answer_comments": [" +1 for Java 8 streams. But if case-sensitivity is not required then only Java 8 solution can be easily modified. List<String> deDupStringList3 = stringList.parallelStream().map(String::toLowerCase).distinct().collect(Collectors.toList()); should work. \u2013 Diablo  Jun 10 '16 at 8:13 "], "answer_body": " Suppose we have a list of String like:  List<String> strList = new ArrayList<>(5);\n// insert up to five items to list.  Then we can remove duplicate elements in in multiple ways.  Prior to Java 8  List<String> deDupStringList = new ArrayList<>(new HashSet<>(strList));  Using Guava  List<String> deDupStringList2 = Lists.newArrayList(Sets.newHashSet(strList));  Using Java 8  List<String> deDupStringList3 = strList.stream().distinct().collect(Collectors.toList());  Note: If we want to maintain the insertion order then we need to use LinkedHashSet in place of HashSet . ", "question_id": 203984}, "0.0"], [{"answer_votes": "19", "answer_comments": null, "answer_body": " Java 8 streams provide a very simple way to remove duplicate elements from a list. Using the distinct method.\nIf we have a list of cities and we want to remove duplicates from that list it can be done in a single line -  List<String> cityList = new ArrayList<>();\n cityList.add(\"Delhi\");\n cityList.add(\"Mumbai\");\n cityList.add(\"Bangalore\");\n cityList.add(\"Chennai\");\n cityList.add(\"Kolkata\");\n cityList.add(\"Mumbai\");\n\n cityList = cityList.stream().distinct().collect(Collectors.toList());  How to remove duplicate elements from an arraylist ", "question_id": 203984}, "0.0"], [{"answer_votes": "19", "answer_comments": [" Note that there is an ImmutableSet.asList() method, returning an ImmutableList , if you need it back as a List . \u2013 Andy Turner  Oct 27 '17 at 19:25 "], "answer_body": " There is also ImmutableSet from Guava as an option ( here is the documentation):  ImmutableSet.copyOf(list); ", "question_id": 203984}, "0.0"], [{"answer_votes": "18", "answer_comments": [" It's slow and you might get a ConcurrentModificationException. \u2013 maaartinus  Oct 18 '13 at 9:39 ", " @maaartinus Have you tried that code ?. It won't produce any exceptions.Also it is pretty fast. I tried the code before posting. \u2013 CarlJohn  Oct 18 '13 at 10:35  ", " You're right, it doesn't as you iterate the array instead of the list. However, it's slow like hell. Try it with a few millions elements. Compare it to ImmutableSet.copyOf(lst).toList() . \u2013 maaartinus  Oct 18 '13 at 10:49  ", " answers the question I was asked in the interview .. How to remove repeated values from an ArrayList without using Sets. Thanx \u2013 Aniket Paul  May 5 '16 at 9:10 ", " Internally, indexOf iterates the lst using a for loop. \u2013 Patrick M  Jul 11 '16 at 17:32 "], "answer_body": " It is possible to remove duplicates from arraylist without using HashSet or one more arraylist .  Try this code..  ArrayList<String> lst = new ArrayList<String>();\n    lst.add(\"ABC\");\n    lst.add(\"ABC\");\n    lst.add(\"ABCD\");\n    lst.add(\"ABCD\");\n    lst.add(\"ABCE\");\n\n    System.out.println(\"Duplicates List \"+lst);\n\n    Object[] st = lst.toArray();\n      for (Object s : st) {\n        if (lst.indexOf(s) != lst.lastIndexOf(s)) {\n            lst.remove(lst.lastIndexOf(s));\n         }\n      }\n\n    System.out.println(\"Distinct List \"+lst);  Output is  Duplicates List [ABC, ABC, ABCD, ABCD, ABCE]\nDistinct List [ABC, ABCD, ABCE] ", "question_id": 203984}, "0.0"], [{"answer_votes": "14", "answer_comments": [" Works perfect.. Thanks for saving my head from loops :) :) \u2013 Sanoop  Dec 21 '16 at 11:17 "], "answer_body": " You can also do it this way, and preserve order:  // delete duplicates (if any) from 'myArrayList'\nmyArrayList = new ArrayList<String>(new LinkedHashSet<String>(myArrayList)); ", "question_id": 203984}, "0.0"], [{"answer_votes": "10", "answer_comments": [" Why use ArrayList in parameter? Why not just List? Will that not work? \u2013 Shervin Asgari  Nov 12 '09 at 15:54 ", " A List will absolutely work as in-parameter for the first method listed. The method is however optimized for use with a random access list such as ArrayList, so if a LinkedList is passed instead you will get poor performance. For example, setting the n:th element in a LinkedList takes O(n) time, whereas setting the n:th element in a random access list (such as ArrayList) takes O(1) time. Again, though, this is probably overkill... If you need this kind of specialized code it will hopefully be in an isolated situation. \u2013 volley  Dec 9 '09 at 20:37 ", " This is precisely what I needed, thanks \u2013 Jasper Holton  Jun 1 '14 at 2:15 "], "answer_body": " Probably a bit overkill, but I enjoy this kind of isolated problem. :)  This code uses a temporary Set (for the uniqueness check) but removes elements directly inside the original list. Since element removal inside an ArrayList can induce a huge amount of array copying, the remove(int)-method is avoided.  public static <T> void removeDuplicates(ArrayList<T> list) {\n    int size = list.size();\n    int out = 0;\n    {\n        final Set<T> encountered = new HashSet<T>();\n        for (int in = 0; in < size; in++) {\n            final T t = list.get(in);\n            final boolean first = encountered.add(t);\n            if (first) {\n                list.set(out++, t);\n            }\n        }\n    }\n    while (out < size) {\n        list.remove(--size);\n    }\n}  While we're at it, here's a version for LinkedList (a lot nicer!):  public static <T> void removeDuplicates(LinkedList<T> list) {\n    final Set<T> encountered = new HashSet<T>();\n    for (Iterator<T> iter = list.iterator(); iter.hasNext(); ) {\n        final T t = iter.next();\n        final boolean first = encountered.add(t);\n        if (!first) {\n            iter.remove();\n        }\n    }\n}  Use the marker interface to present a unified solution for List:  public static <T> void removeDuplicates(List<T> list) {\n    if (list instanceof RandomAccess) {\n        // use first version here\n    } else {\n        // use other version here\n    }\n}  EDIT: I guess the generics-stuff doesn't really add any value here.. Oh well. :) ", "question_id": 203984}, "0.0"], [{"answer_votes": "9", "answer_comments": [" I liked this solution better. \u2013 Tushar Gogna  Dec 5 '17 at 7:19 "], "answer_body": " this can solve the problem:  private List<SomeClass> clearListFromDuplicateFirstName(List<SomeClass> list1) {\n\nMap<String, SomeClass> cleanMap = new LinkedHashMap<String, SomeClass>();\nfor (int i = 0; i < list1.size(); i++) {\n     cleanMap.put(list1.get(i).getFirstName(), list1.get(i));\n}\nList<SomeClass> list = new ArrayList<SomeClass>(cleanMap.values());\nreturn list;\n} ", "question_id": 203984}, "0.0"], [{"answer_votes": "8", "answer_comments": [" This implementation return no element in the list because of the last j-- \u2013 neo7  Sep 23 '15 at 9:29 ", " This implementation work's very fine.there is no issue behind this and for this task i am only use one arraylist.so this answer is completely good.before giving negative feedback you shold also add testcase also so that every one can understand the result.Thanks Manash \u2013 Manash Ranjan Dakua  Sep 24 '15 at 13:14 ", " This saved the day! \u2013 YehCheez  Mar 9 '16 at 16:09 "], "answer_body": " public static void main(String[] args){\n    ArrayList<Object> al = new ArrayList<Object>();\n    al.add(\"abc\");\n    al.add('a');\n    al.add('b');\n    al.add('a');\n    al.add(\"abc\");\n    al.add(10.3);\n    al.add('c');\n    al.add(10);\n    al.add(\"abc\");\n    al.add(10);\n    System.out.println(\"Before Duplicate Remove:\"+al);\n    for(int i=0;i<al.size();i++){\n        for(int j=i+1;j<al.size();j++){\n            if(al.get(i).equals(al.get(j))){\n                al.remove(j);\n                j--;\n            }\n        }\n    }\n    System.out.println(\"After Removing duplicate:\"+al);\n} ", "question_id": 203984}, "0.0"], [{"answer_votes": "5", "answer_comments": null, "answer_body": " If you're willing to use a third-party library, you can use the method distinct() in Eclipse Collections (formerly GS Collections).  ListIterable<Integer> integers = FastList.newListWith(1, 3, 1, 2, 2, 1);\nAssert.assertEquals(\n    FastList.newListWith(1, 3, 2),\n    integers.distinct());  The advantage of using distinct() instead of converting to a Set and then back to a List is that distinct() preserves the order of the original List, retaining the first occurrence of each element. It's implemented by using both a Set and a List.  MutableSet<T> seenSoFar = UnifiedSet.newSet();\nint size = list.size();\nfor (int i = 0; i < size; i++)\n{\n    T item = list.get(i);\n    if (seenSoFar.add(item))\n    {\n        targetCollection.add(item);\n    }\n}\nreturn targetCollection;  If you cannot convert your original List into an Eclipse Collections type, you can use ListAdapter to get the same API.  MutableList<Integer> distinct = ListAdapter.adapt(integers).distinct();  Note: I am a committer for Eclipse Collections. ", "question_id": 203984}, "0.0"], [{"answer_votes": "3", "answer_comments": null, "answer_body": " This three lines of code can remove the duplicated element from ArrayList or any collection.  List<Entity> entities = repository.findByUserId(userId);\n\nSet<Entity> s = new LinkedHashSet<Entity>(entities);\nentities.clear();\nentities.addAll(s); ", "question_id": 203984}, "0.0"], [{"answer_votes": "2", "answer_comments": null, "answer_body": " When you are filling the ArrayList, use a condition for each element. For example:  ArrayList< Integer > al = new ArrayList< Integer >(); \n\n    // fill 1 \n    for ( int i = 0; i <= 5; i++ ) \n        if ( !al.contains( i ) ) \n            al.add( i ); \n\n    // fill 2 \n    for (int i = 0; i <= 10; i++ ) \n        if ( !al.contains( i ) ) \n            al.add( i ); \n\n    for( Integer i: al )\n    {\n        System.out.print( i + \" \");     \n    }  We will get an array {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10} ", "question_id": 203984}, "0.0"], [{"answer_votes": "2", "answer_comments": null, "answer_body": " If you want to preserve your Order then it is best to use LinkedHashSet .\nBecause if you want to pass this List to an Insert Query by Iterating it, the order would be preserved.  Try this  LinkedHashSet link=new LinkedHashSet();\nList listOfValues=new ArrayList();\nlistOfValues.add(link);  This conversion will be very helpful when you want to return a List but not a Set. ", "question_id": 203984}, "0.0"], [{"answer_votes": "2", "answer_comments": null, "answer_body": " Code:  List<String> duplicatList = new ArrayList<String>();\nduplicatList = Arrays.asList(\"AA\",\"BB\",\"CC\",\"DD\",\"DD\",\"EE\",\"AA\",\"FF\");\n//above AA and DD are duplicate\nSet<String> uniqueList = new HashSet<String>(duplicatList);\nduplicatList = new ArrayList<String>(uniqueList); //let GC will doing free memory\nSystem.out.println(\"Removed Duplicate : \"+duplicatList);  Note: Definitely, there will be memory overhead. ", "question_id": 203984}, "0.0"], [{"answer_votes": "2", "answer_comments": null, "answer_body": " ArrayList<String> city=new ArrayList<String>();\ncity.add(\"rajkot\");\ncity.add(\"gondal\");\ncity.add(\"rajkot\");\ncity.add(\"gova\");\ncity.add(\"baroda\");\ncity.add(\"morbi\");\ncity.add(\"gova\");\n\nHashSet<String> hashSet = new HashSet<String>();\nhashSet.addAll(city);\ncity.clear();\ncity.addAll(hashSet);\nToast.makeText(getActivity(),\"\" + city.toString(),Toast.LENGTH_SHORT).show(); ", "question_id": 203984}, "0.0"], [{"answer_votes": "1", "answer_comments": null, "answer_body": " As said before, you should use a class implementing Set interface instead of List to be sure of unicity of elements. If you have to keep the order of elements, the SortedSet interface can then be used ; the TreeSet class implements that interface. ", "question_id": 203984}, "0.0"], [{"answer_votes": "1", "answer_comments": null, "answer_body": " LinkedHashSet will do the trick.  String[] arr2 = {\"5\",\"1\",\"2\",\"3\",\"3\",\"4\",\"1\",\"2\"};\nSet<String> set = new LinkedHashSet<String>(Arrays.asList(arr2));\nfor(String s1 : set)\n    System.out.println(s1);\n\nSystem.out.println( \"------------------------\" );\nString[] arr3 = set.toArray(new String[0]);\nfor(int i = 0; i < arr3.length; i++)\n     System.out.println(arr3[i].toString());  //output: 5,1,2,3,4 ", "question_id": 203984}, "0.0"], [{"answer_votes": "1", "answer_comments": null, "answer_body": " List<String> result = new ArrayList<String>();\n        Set<String> set = new LinkedHashSet<String>();\n        String s = \"ravi is a good!boy. But ravi is very nasty fellow.\";\n        StringTokenizer st = new StringTokenizer(s, \" ,. ,!\");\n        while (st.hasMoreTokens()) {\n            result.add(st.nextToken());\n        }\n         System.out.println(result);\n         set.addAll(result);\n        result.clear();\n        result.addAll(set);\n        System.out.println(result);\n\noutput:\n[ravi, is, a, good, boy, But, ravi, is, very, nasty, fellow]\n[ravi, is, a, good, boy, But, very, nasty, fellow] ", "question_id": 203984}, "0.0"], [{"answer_votes": "1", "answer_comments": [" This thread is years old... \u2013 WolfieeifloW  Nov 30 '17 at 18:43 "], "answer_body": " you can use nested loop in follow :  ArrayList<Class1> l1 = new ArrayList<Class1>();\nArrayList<Class1> l2 = new ArrayList<Class1>();\n\n        Iterator iterator1 = l1.iterator();\n        boolean repeated = false;\n\n        while (iterator1.hasNext())\n        {\n            Class1 c1 = (Class1) iterator1.next();\n            for (Class1 _c: l2) {\n                if(_c.getId() == c1.getId())\n                    repeated = true;\n            }\n            if(!repeated)\n                l2.add(c1);\n        } ", "question_id": 203984}, "0.0"], [{"answer_votes": "0", "answer_comments": null, "answer_body": " for(int a=0;a<myArray.size();a++){\n        for(int b=a+1;b<myArray.size();b++){\n            if(myArray.get(a).equalsIgnoreCase(myArray.get(b))){\n                myArray.remove(b); \n                dups++;\n                b--;\n            }\n        }\n} ", "question_id": 203984}, "0.0"], [{"answer_votes": "0", "answer_comments": null, "answer_body": " import java.util.*;\nclass RemoveDupFrmString\n{\n    public static void main(String[] args)\n    {\n\n        String s=\"appsc\";\n\n        Set<Character> unique = new LinkedHashSet<Character> ();\n\n        for(char c : s.toCharArray()) {\n\n            System.out.println(unique.add(c));\n        }\n        for(char dis:unique){\n            System.out.println(dis);\n        }\n\n\n    }\n} ", "question_id": 203984}, "0.0"], [{"answer_votes": "0", "answer_comments": null, "answer_body": " public Set<Object> findDuplicates(List<Object> list) {\n        Set<Object> items = new HashSet<Object>();\n        Set<Object> duplicates = new HashSet<Object>();\n        for (Object item : list) {\n            if (items.contains(item)) {\n                duplicates.add(item);\n                } else { \n                    items.add(item);\n                    } \n            } \n        return duplicates;\n        } ", "question_id": 203984}, "0.0"], [{"answer_votes": "0", "answer_comments": null, "answer_body": " ArrayList<String> list = new ArrayList<String>();\n    HashSet<String> unique = new LinkedHashSet<String>();\n    HashSet<String> dup = new LinkedHashSet<String>();\n    boolean b = false;\n    list.add(\"Hello\");\n    list.add(\"Hello\");\n    list.add(\"how\");\n    list.add(\"are\");\n    list.add(\"u\");\n    list.add(\"u\");\n\n    for(Iterator iterator= list.iterator();iterator.hasNext();)\n    {\n        String value = (String)iterator.next();\n        System.out.println(value);\n\n        if(b==unique.add(value))\n            dup.add(value);\n        else\n            unique.add(value);\n\n\n    }\n    System.out.println(unique);\n    System.out.println(dup); ", "question_id": 203984}, "0.0"], [{"answer_votes": "0", "answer_comments": [" Why would you post a quadratic solution to a question that already has 2-year-old linear and log-linear solutions, that are also simpler? \u2013 abarnert  Sep 11 '14 at 7:40 "], "answer_body": " If you want to remove duplicates from ArrayList means find the below logic,  public static Object[] removeDuplicate(Object[] inputArray)\n{\n    long startTime = System.nanoTime();\n    int totalSize = inputArray.length;\n    Object[] resultArray = new Object[totalSize];\n    int newSize = 0;\n    for(int i=0; i<totalSize; i++)\n    {\n        Object value = inputArray[i];\n        if(value == null)\n        {\n            continue;\n        }\n\n        for(int j=i+1; j<totalSize; j++)\n        {\n            if(value.equals(inputArray[j]))\n            {\n                inputArray[j] = null;\n            }\n        }\n        resultArray[newSize++] = value;\n    }\n\n    long endTime = System.nanoTime()-startTime;\n    System.out.println(\"Total Time-B:\"+endTime);\n    return resultArray;\n} ", "question_id": 203984}, "0.0"], [{"answer_votes": "0", "answer_comments": null, "answer_body": " The @jonathan-stafford solution is OK. But this don't preserve the list order.  If you want preserve the list order you have to use this:  public static <T> void removeDuplicate(List <T> list) {\nSet <T> set = new HashSet <T>();\nList <T> newList = new ArrayList <T>();\nfor (Iterator <T>iter = list.iterator();    iter.hasNext(); ) {\n   Object element = iter.next();\n   if (set.add((T) element))\n      newList.add((T) element);\n   }\n   list.clear();\n   list.addAll(newList);\n}  It's only to complete the answer. Very good! ", "question_id": 203984}, "0.0"], [{"answer_votes": "0", "answer_comments": null, "answer_body": " Here is my answer without using any other data structure like set or hashmap etc.  public static <T> ArrayList<T> uniquefy(ArrayList<T> myList) {\n\n    ArrayList <T> uniqueArrayList = new ArrayList<T>();\n    for (int i = 0; i < myList.size(); i++){\n        if (!uniqueArrayList.contains(myList.get(i))){\n            uniqueArrayList.add(myList.get(i));\n        }\n    }\n\n    return uniqueArrayList;\n} ", "question_id": 203984}, "0.0"], [{"answer_votes": "0", "answer_comments": null, "answer_body": " Would something like this work better ?  public static void removeDuplicates(ArrayList<String> list) {\nArraylist<Object> ar     = new Arraylist<Object>();\nArraylist<Object> tempAR = new Arraylist<Object>();\nwhile (list.size()>0){\n    ar.add(list(0));\n    list.removeall(Collections.singleton(list(0)));\n}\nlist.addAll(ar);  }  That should maintain the order and also not be quadratic in run time. ", "question_id": 203984}, "0.0"], [{"answer_votes": "0", "answer_comments": null, "answer_body": " This is used for your Custom Objects list  public List<Contact> removeDuplicates(List<Contact> list) {\n    // Set set1 = new LinkedHashSet(list);\n    Set set = new TreeSet(new Comparator() {\n\n        @Override\n        public int compare(Object o1, Object o2) {\n            if (((Contact) o1).getId().equalsIgnoreCase(((Contact) o2).getId()) /*&&\n                    ((Contact)o1).getName().equalsIgnoreCase(((Contact)o2).getName())*/) {\n                return 0;\n            }\n            return 1;\n        }\n    });\n    set.addAll(list);\n\n    final List newList = new ArrayList(set);\n    return newList;\n} ", "question_id": 203984}, "0.0"], [{"answer_votes": "0", "answer_comments": null, "answer_body": " If you are using model type List< T>/ArrayList< T> . Hope,it's help you.   Here is my code without using any other data structure like set or hashmap  for(int i = 0; i < Models.size(); i++) {\n     for(int j = i + 1; j < Models.size(); j++) {                                \n       if(Models.get(i).getName().equals(Models.get(j).getName())){    \n                                Models.remove(j);\n\n                                j--;\n                            }\n                        }\n                    } ", "question_id": 203984}, "0.0"], [{"answer_votes": "-1", "answer_comments": null, "answer_body": " In Java, List permits ordered access of their elements. They can have duplicates because their lookup key is the position not some hash code, every element can be modified while they remain in the list where as Set represents a collection of unique elements and while elements are in set, they must not be modified.While there is no restriction preventing you from modifying elements in a set, if an element is modified, then it could become forever lost in the set.  public static void main(String[] args) {  \n           List<String> l = new ArrayList<String>();  \n           l.add(\"A\");  \n           l.add(\"B\");  \n           l.add(\"C\");  \n           l.add(\"A\");  \n           System.out.println(\"Before removing duplicates: \");  \n           for (String s : l) {  \n                System.out.println(s);  \n           }  \n           Set<String> set = new HashSet<String>(l);  \n           List<String> newlist = new ArrayList<String>(set);  \n           System.out.println(\"after removing duplicates: \");  \n           for (String s : newlist) {  \n                System.out.println(s);  \n           }  \n      }  for reference , refer this link How to remove duplicates from ArrayList  ", "question_id": 203984}, "0.0"]], "gensim_similarity_tf_idf_body_result": [[{"answer_votes": "258", "answer_comments": [" Does LinkedHashSet make any guarantees as to which of several duplicates are kept from the list?  For instance, if position 1, 3, and 5 are duplicates in the original list, can we assume that this process will remove 3 and 5?  Or maybe remove 1 and 3?  Thanks. \u2013 Matt Brian\u00e7on  May 1 '11 at 2:20 ", " @Matt: yes, it does guarantee that. The docs say: \"This linked list defines the iteration ordering, which is the order in which elements were inserted into the set (insertion-order). Note that insertion order is not affected if an element is re-inserted into the set.\" \u2013 abahgat  May 2 '11 at 9:00 ", " Very interesting. I have a different situation here. I am not trying to sort String but another object called AwardYearSource. This class has an int attribute called year. So I want to remove duplicates based on the year. i.e if there is year 2010 mentioned more than once, I want to remove that AwardYearSource object. How can I do that? \u2013 WowBow  Apr 16 '12 at 15:27 ", " @WowBow For example you can define Wrapper object which holds AwardYearSource. And define this Wrapper objects equals method based on AwardYearSources year field. Then you can use Set with these Wrapper objects. \u2013 Ondrej Bozek  Jun 20 '12 at 12:19 ", " @WowBow or implement Comparable/Comparator \u2013 shrini1000  Jan 11 '13 at 5:09 "], "answer_body": " Although converting the ArrayList to a HashSet effectively removes duplicates, if you need to preserve insertion order, I'd rather suggest you to use this variant  // list is some List of Strings\nSet<String> s = new LinkedHashSet<>(list);  Then, if you need to get back a List reference, you can use again the conversion constructor. ", "question_id": 203984}, "0.14987989"], [{"answer_votes": "19", "answer_comments": null, "answer_body": " Java 8 streams provide a very simple way to remove duplicate elements from a list. Using the distinct method.\nIf we have a list of cities and we want to remove duplicates from that list it can be done in a single line -  List<String> cityList = new ArrayList<>();\n cityList.add(\"Delhi\");\n cityList.add(\"Mumbai\");\n cityList.add(\"Bangalore\");\n cityList.add(\"Chennai\");\n cityList.add(\"Kolkata\");\n cityList.add(\"Mumbai\");\n\n cityList = cityList.stream().distinct().collect(Collectors.toList());  How to remove duplicate elements from an arraylist ", "question_id": 203984}, "0.12123405"], [{"answer_votes": "14", "answer_comments": [" Works perfect.. Thanks for saving my head from loops :) :) \u2013 Sanoop  Dec 21 '16 at 11:17 "], "answer_body": " You can also do it this way, and preserve order:  // delete duplicates (if any) from 'myArrayList'\nmyArrayList = new ArrayList<String>(new LinkedHashSet<String>(myArrayList)); ", "question_id": 203984}, "0.120256186"], [{"answer_votes": "2", "answer_comments": null, "answer_body": " If you want to preserve your Order then it is best to use LinkedHashSet .\nBecause if you want to pass this List to an Insert Query by Iterating it, the order would be preserved.  Try this  LinkedHashSet link=new LinkedHashSet();\nList listOfValues=new ArrayList();\nlistOfValues.add(link);  This conversion will be very helpful when you want to return a List but not a Set. ", "question_id": 203984}, "0.114129886"], [{"answer_votes": "5", "answer_comments": null, "answer_body": " If you're willing to use a third-party library, you can use the method distinct() in Eclipse Collections (formerly GS Collections).  ListIterable<Integer> integers = FastList.newListWith(1, 3, 1, 2, 2, 1);\nAssert.assertEquals(\n    FastList.newListWith(1, 3, 2),\n    integers.distinct());  The advantage of using distinct() instead of converting to a Set and then back to a List is that distinct() preserves the order of the original List, retaining the first occurrence of each element. It's implemented by using both a Set and a List.  MutableSet<T> seenSoFar = UnifiedSet.newSet();\nint size = list.size();\nfor (int i = 0; i < size; i++)\n{\n    T item = list.get(i);\n    if (seenSoFar.add(item))\n    {\n        targetCollection.add(item);\n    }\n}\nreturn targetCollection;  If you cannot convert your original List into an Eclipse Collections type, you can use ListAdapter to get the same API.  MutableList<Integer> distinct = ListAdapter.adapt(integers).distinct();  Note: I am a committer for Eclipse Collections. ", "question_id": 203984}, "0.09929279"], [{"answer_votes": "824", "answer_comments": [" See also LinkedHashSet, if you wish to retain the order. \u2013 volley  Dec 9 '09 at 20:38 ", " But this will just create the set without duplicates , I want to know which number was duplicate in O(n) time \u2013 Chetan  Mar 29 '12 at 19:43 ", " @Chetan finding all duplicates from ArrayList in O(n), its important to have correctly defined equals method on objects which you have in the list (no problem for numbers): public Set<Object> findDuplicates(List<Object> list)       {           Set<Object> items = new HashSet<Object>();           Set<Object> duplicates = new HashSet<Object>();           for (Object item : list) {               if (items.contains(item)) {                   duplicates.add(item);               } else {                   items.add(item);               }           }           return duplicates;       } \u2013 Ondrej Bozek  Jun 20 '12 at 12:06  ", " A good practice would be to define variables using the interface types List and Set (instead of implementation types ArrayList and HashSet as in your example). \u2013 Jonik  Aug 29 '13 at 7:27 ", " You can clean this up by using new HashSet(al) instead of initializing it to empty and calling addAll . \u2013 ashes999  Dec 26 '13 at 12:44 "], "answer_body": " If you don't want duplicates in a Collection , you should consider why you're using a Collection that allows duplicates. The easiest way to remove repeated elements is to add the contents to a Set (which will not allow duplicates) and then add the Set back to the ArrayList :  List<String> al = new ArrayList<>();\n// add elements to al, including duplicates\nSet<String> hs = new HashSet<>();\nhs.addAll(al);\nal.clear();\nal.addAll(hs);  Of course, this destroys the ordering of the elements in the ArrayList . ", "question_id": 203984}, "0.09304213"], [{"answer_votes": "10", "answer_comments": [" Why use ArrayList in parameter? Why not just List? Will that not work? \u2013 Shervin Asgari  Nov 12 '09 at 15:54 ", " A List will absolutely work as in-parameter for the first method listed. The method is however optimized for use with a random access list such as ArrayList, so if a LinkedList is passed instead you will get poor performance. For example, setting the n:th element in a LinkedList takes O(n) time, whereas setting the n:th element in a random access list (such as ArrayList) takes O(1) time. Again, though, this is probably overkill... If you need this kind of specialized code it will hopefully be in an isolated situation. \u2013 volley  Dec 9 '09 at 20:37 ", " This is precisely what I needed, thanks \u2013 Jasper Holton  Jun 1 '14 at 2:15 "], "answer_body": " Probably a bit overkill, but I enjoy this kind of isolated problem. :)  This code uses a temporary Set (for the uniqueness check) but removes elements directly inside the original list. Since element removal inside an ArrayList can induce a huge amount of array copying, the remove(int)-method is avoided.  public static <T> void removeDuplicates(ArrayList<T> list) {\n    int size = list.size();\n    int out = 0;\n    {\n        final Set<T> encountered = new HashSet<T>();\n        for (int in = 0; in < size; in++) {\n            final T t = list.get(in);\n            final boolean first = encountered.add(t);\n            if (first) {\n                list.set(out++, t);\n            }\n        }\n    }\n    while (out < size) {\n        list.remove(--size);\n    }\n}  While we're at it, here's a version for LinkedList (a lot nicer!):  public static <T> void removeDuplicates(LinkedList<T> list) {\n    final Set<T> encountered = new HashSet<T>();\n    for (Iterator<T> iter = list.iterator(); iter.hasNext(); ) {\n        final T t = iter.next();\n        final boolean first = encountered.add(t);\n        if (!first) {\n            iter.remove();\n        }\n    }\n}  Use the marker interface to present a unified solution for List:  public static <T> void removeDuplicates(List<T> list) {\n    if (list instanceof RandomAccess) {\n        // use first version here\n    } else {\n        // use other version here\n    }\n}  EDIT: I guess the generics-stuff doesn't really add any value here.. Oh well. :) ", "question_id": 203984}, "0.089194484"], [{"answer_votes": "-1", "answer_comments": null, "answer_body": " In Java, List permits ordered access of their elements. They can have duplicates because their lookup key is the position not some hash code, every element can be modified while they remain in the list where as Set represents a collection of unique elements and while elements are in set, they must not be modified.While there is no restriction preventing you from modifying elements in a set, if an element is modified, then it could become forever lost in the set.  public static void main(String[] args) {  \n           List<String> l = new ArrayList<String>();  \n           l.add(\"A\");  \n           l.add(\"B\");  \n           l.add(\"C\");  \n           l.add(\"A\");  \n           System.out.println(\"Before removing duplicates: \");  \n           for (String s : l) {  \n                System.out.println(s);  \n           }  \n           Set<String> set = new HashSet<String>(l);  \n           List<String> newlist = new ArrayList<String>(set);  \n           System.out.println(\"after removing duplicates: \");  \n           for (String s : newlist) {  \n                System.out.println(s);  \n           }  \n      }  for reference , refer this link How to remove duplicates from ArrayList  ", "question_id": 203984}, "0.087485746"], [{"answer_votes": "48", "answer_comments": [" Similarly at the bottom of the thread, I have given an answer where I am using Set for Custom Object. In a case if anyone have custom object like \"Contact\" or \"Student\" can use that answer that works fine for me. \u2013 Muhammad Adil  Oct 25 '16 at 14:16 "], "answer_body": " If you don't want duplicates, use a Set instead of a List . To convert a List to a Set you can use the following code:  // list is some List of Strings\nSet<String> s = new HashSet<String>(list);  If really necessary you can use the same construction to convert a Set back into a List . ", "question_id": 203984}, "0.0806925"], [{"answer_votes": "1", "answer_comments": null, "answer_body": " As said before, you should use a class implementing Set interface instead of List to be sure of unicity of elements. If you have to keep the order of elements, the SortedSet interface can then be used ; the TreeSet class implements that interface. ", "question_id": 203984}, "0.071491905"], [{"answer_votes": "0", "answer_comments": null, "answer_body": " Would something like this work better ?  public static void removeDuplicates(ArrayList<String> list) {\nArraylist<Object> ar     = new Arraylist<Object>();\nArraylist<Object> tempAR = new Arraylist<Object>();\nwhile (list.size()>0){\n    ar.add(list(0));\n    list.removeall(Collections.singleton(list(0)));\n}\nlist.addAll(ar);  }  That should maintain the order and also not be quadratic in run time. ", "question_id": 203984}, "0.06788696"], [{"answer_votes": "24", "answer_comments": [" +1 for Java 8 streams. But if case-sensitivity is not required then only Java 8 solution can be easily modified. List<String> deDupStringList3 = stringList.parallelStream().map(String::toLowerCase).distinct().collect(Collectors.toList()); should work. \u2013 Diablo  Jun 10 '16 at 8:13 "], "answer_body": " Suppose we have a list of String like:  List<String> strList = new ArrayList<>(5);\n// insert up to five items to list.  Then we can remove duplicate elements in in multiple ways.  Prior to Java 8  List<String> deDupStringList = new ArrayList<>(new HashSet<>(strList));  Using Guava  List<String> deDupStringList2 = Lists.newArrayList(Sets.newHashSet(strList));  Using Java 8  List<String> deDupStringList3 = strList.stream().distinct().collect(Collectors.toList());  Note: If we want to maintain the insertion order then we need to use LinkedHashSet in place of HashSet . ", "question_id": 203984}, "0.061450563"], [{"answer_votes": "1", "answer_comments": [" This thread is years old... \u2013 WolfieeifloW  Nov 30 '17 at 18:43 "], "answer_body": " you can use nested loop in follow :  ArrayList<Class1> l1 = new ArrayList<Class1>();\nArrayList<Class1> l2 = new ArrayList<Class1>();\n\n        Iterator iterator1 = l1.iterator();\n        boolean repeated = false;\n\n        while (iterator1.hasNext())\n        {\n            Class1 c1 = (Class1) iterator1.next();\n            for (Class1 _c: l2) {\n                if(_c.getId() == c1.getId())\n                    repeated = true;\n            }\n            if(!repeated)\n                l2.add(c1);\n        } ", "question_id": 203984}, "0.059471812"], [{"answer_votes": "0", "answer_comments": null, "answer_body": " The @jonathan-stafford solution is OK. But this don't preserve the list order.  If you want preserve the list order you have to use this:  public static <T> void removeDuplicate(List <T> list) {\nSet <T> set = new HashSet <T>();\nList <T> newList = new ArrayList <T>();\nfor (Iterator <T>iter = list.iterator();    iter.hasNext(); ) {\n   Object element = iter.next();\n   if (set.add((T) element))\n      newList.add((T) element);\n   }\n   list.clear();\n   list.addAll(newList);\n}  It's only to complete the answer. Very good! ", "question_id": 203984}, "0.054569907"], [{"answer_votes": "19", "answer_comments": [" Note that there is an ImmutableSet.asList() method, returning an ImmutableList , if you need it back as a List . \u2013 Andy Turner  Oct 27 '17 at 19:25 "], "answer_body": " There is also ImmutableSet from Guava as an option ( here is the documentation):  ImmutableSet.copyOf(list); ", "question_id": 203984}, "0.048229165"], [{"answer_votes": "24", "answer_comments": [" This answer lacks two things: 1) It does not use generics, but raw types ( ArrayList<T> should be used instead of ArrayList ) 2) The explicit iterator creating can be avoided by using a for (T current : l1) { ... } . Even if you wanted to use an Iterator explicitly, iterador is misspelled. \u2013 RAnders00  Dec 7 '15 at 16:22 ", " And this implementation runs in quadratic time, compared to the linked hash set implementation running in linear time. (i.e. this takes 10 times longer on a list with 10 elements, 10,000 times longer on a list with 10,000 elements. JDK 6 implementation for ArrayList.contains , JDK8 impl is the same.) \u2013 Patrick M  Jul 11 '16 at 16:09 "], "answer_body": " Here's a way that doesn't affect your list ordering:  ArrayList l1 = new ArrayList();\nArrayList l2 = new ArrayList();\n\nIterator iterator = l1.iterator();\n\n        while (iterator.hasNext())\n        {\n            YourClass o = (YourClass) iterator.next();\n            if(!l2.contains(o)) l2.add(o);\n        }  l1 is the original list, and l2 is the list whithout repeated items\n(Make sure YourClass has the equals method acording to what you want to stand for equality) ", "question_id": 203984}, "0.047852892"], [{"answer_votes": "3", "answer_comments": null, "answer_body": " This three lines of code can remove the duplicated element from ArrayList or any collection.  List<Entity> entities = repository.findByUserId(userId);\n\nSet<Entity> s = new LinkedHashSet<Entity>(entities);\nentities.clear();\nentities.addAll(s); ", "question_id": 203984}, "0.041307904"], [{"answer_votes": "18", "answer_comments": [" It's slow and you might get a ConcurrentModificationException. \u2013 maaartinus  Oct 18 '13 at 9:39 ", " @maaartinus Have you tried that code ?. It won't produce any exceptions.Also it is pretty fast. I tried the code before posting. \u2013 CarlJohn  Oct 18 '13 at 10:35  ", " You're right, it doesn't as you iterate the array instead of the list. However, it's slow like hell. Try it with a few millions elements. Compare it to ImmutableSet.copyOf(lst).toList() . \u2013 maaartinus  Oct 18 '13 at 10:49  ", " answers the question I was asked in the interview .. How to remove repeated values from an ArrayList without using Sets. Thanx \u2013 Aniket Paul  May 5 '16 at 9:10 ", " Internally, indexOf iterates the lst using a for loop. \u2013 Patrick M  Jul 11 '16 at 17:32 "], "answer_body": " It is possible to remove duplicates from arraylist without using HashSet or one more arraylist .  Try this code..  ArrayList<String> lst = new ArrayList<String>();\n    lst.add(\"ABC\");\n    lst.add(\"ABC\");\n    lst.add(\"ABCD\");\n    lst.add(\"ABCD\");\n    lst.add(\"ABCE\");\n\n    System.out.println(\"Duplicates List \"+lst);\n\n    Object[] st = lst.toArray();\n      for (Object s : st) {\n        if (lst.indexOf(s) != lst.lastIndexOf(s)) {\n            lst.remove(lst.lastIndexOf(s));\n         }\n      }\n\n    System.out.println(\"Distinct List \"+lst);  Output is  Duplicates List [ABC, ABC, ABCD, ABCD, ABCE]\nDistinct List [ABC, ABCD, ABCE] ", "question_id": 203984}, "0.02012703"], [{"answer_votes": "2", "answer_comments": null, "answer_body": " When you are filling the ArrayList, use a condition for each element. For example:  ArrayList< Integer > al = new ArrayList< Integer >(); \n\n    // fill 1 \n    for ( int i = 0; i <= 5; i++ ) \n        if ( !al.contains( i ) ) \n            al.add( i ); \n\n    // fill 2 \n    for (int i = 0; i <= 10; i++ ) \n        if ( !al.contains( i ) ) \n            al.add( i ); \n\n    for( Integer i: al )\n    {\n        System.out.print( i + \" \");     \n    }  We will get an array {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10} ", "question_id": 203984}, "0.019699806"], [{"answer_votes": "0", "answer_comments": [" Why would you post a quadratic solution to a question that already has 2-year-old linear and log-linear solutions, that are also simpler? \u2013 abarnert  Sep 11 '14 at 7:40 "], "answer_body": " If you want to remove duplicates from ArrayList means find the below logic,  public static Object[] removeDuplicate(Object[] inputArray)\n{\n    long startTime = System.nanoTime();\n    int totalSize = inputArray.length;\n    Object[] resultArray = new Object[totalSize];\n    int newSize = 0;\n    for(int i=0; i<totalSize; i++)\n    {\n        Object value = inputArray[i];\n        if(value == null)\n        {\n            continue;\n        }\n\n        for(int j=i+1; j<totalSize; j++)\n        {\n            if(value.equals(inputArray[j]))\n            {\n                inputArray[j] = null;\n            }\n        }\n        resultArray[newSize++] = value;\n    }\n\n    long endTime = System.nanoTime()-startTime;\n    System.out.println(\"Total Time-B:\"+endTime);\n    return resultArray;\n} ", "question_id": 203984}, "0.019504072"], [{"answer_votes": "1", "answer_comments": null, "answer_body": " List<String> result = new ArrayList<String>();\n        Set<String> set = new LinkedHashSet<String>();\n        String s = \"ravi is a good!boy. But ravi is very nasty fellow.\";\n        StringTokenizer st = new StringTokenizer(s, \" ,. ,!\");\n        while (st.hasMoreTokens()) {\n            result.add(st.nextToken());\n        }\n         System.out.println(result);\n         set.addAll(result);\n        result.clear();\n        result.addAll(set);\n        System.out.println(result);\n\noutput:\n[ravi, is, a, good, boy, But, ravi, is, very, nasty, fellow]\n[ravi, is, a, good, boy, But, very, nasty, fellow] ", "question_id": 203984}, "0.016632287"], [{"answer_votes": "0", "answer_comments": null, "answer_body": " If you are using model type List< T>/ArrayList< T> . Hope,it's help you.   Here is my code without using any other data structure like set or hashmap  for(int i = 0; i < Models.size(); i++) {\n     for(int j = i + 1; j < Models.size(); j++) {                                \n       if(Models.get(i).getName().equals(Models.get(j).getName())){    \n                                Models.remove(j);\n\n                                j--;\n                            }\n                        }\n                    } ", "question_id": 203984}, "0.0153108705"], [{"answer_votes": "1", "answer_comments": null, "answer_body": " LinkedHashSet will do the trick.  String[] arr2 = {\"5\",\"1\",\"2\",\"3\",\"3\",\"4\",\"1\",\"2\"};\nSet<String> set = new LinkedHashSet<String>(Arrays.asList(arr2));\nfor(String s1 : set)\n    System.out.println(s1);\n\nSystem.out.println( \"------------------------\" );\nString[] arr3 = set.toArray(new String[0]);\nfor(int i = 0; i < arr3.length; i++)\n     System.out.println(arr3[i].toString());  //output: 5,1,2,3,4 ", "question_id": 203984}, "0.0151003655"], [{"answer_votes": "2", "answer_comments": null, "answer_body": " Code:  List<String> duplicatList = new ArrayList<String>();\nduplicatList = Arrays.asList(\"AA\",\"BB\",\"CC\",\"DD\",\"DD\",\"EE\",\"AA\",\"FF\");\n//above AA and DD are duplicate\nSet<String> uniqueList = new HashSet<String>(duplicatList);\nduplicatList = new ArrayList<String>(uniqueList); //let GC will doing free memory\nSystem.out.println(\"Removed Duplicate : \"+duplicatList);  Note: Definitely, there will be memory overhead. ", "question_id": 203984}, "0.013039582"], [{"answer_votes": "9", "answer_comments": [" I liked this solution better. \u2013 Tushar Gogna  Dec 5 '17 at 7:19 "], "answer_body": " this can solve the problem:  private List<SomeClass> clearListFromDuplicateFirstName(List<SomeClass> list1) {\n\nMap<String, SomeClass> cleanMap = new LinkedHashMap<String, SomeClass>();\nfor (int i = 0; i < list1.size(); i++) {\n     cleanMap.put(list1.get(i).getFirstName(), list1.get(i));\n}\nList<SomeClass> list = new ArrayList<SomeClass>(cleanMap.values());\nreturn list;\n} ", "question_id": 203984}, "0.01256177"], [{"answer_votes": "83", "answer_comments": [" very elegant. Thanks \u2013 paskos  Feb 12 '15 at 20:04 ", " How do i do this for case insensitive distinct ? \u2013 StackFlowed  Sep 13 '16 at 20:04  ", " @StackFlowed If you don't need to preserve the order of the list you can addAll to new TreeSet<String>(String.CASE_INSENSITIVE_ORDER) .  The first element added will remain in the set so if your list contains \"Dog\" and \"dog\" (in that order) the TreeSet will contain \"Dog\". If order must be preserved then before the line in the answer put list.replaceAll(String::toUpperCase); . \u2013 Paul  Nov 3 '17 at 23:28  ", " I am getting this error :incompatible types: List<Object> cannot be converted to List<String> \u2013 Samir  Apr 4 at 14:34 "], "answer_body": " In Java 8:  List<String> deduped = list.stream().distinct().collect(Collectors.toList());  Please note that the hashCode-equals contract for list members should be respected for the filtering to work properly. ", "question_id": 203984}, "0.0061988775"], [{"answer_votes": "2", "answer_comments": null, "answer_body": " ArrayList<String> city=new ArrayList<String>();\ncity.add(\"rajkot\");\ncity.add(\"gondal\");\ncity.add(\"rajkot\");\ncity.add(\"gova\");\ncity.add(\"baroda\");\ncity.add(\"morbi\");\ncity.add(\"gova\");\n\nHashSet<String> hashSet = new HashSet<String>();\nhashSet.addAll(city);\ncity.clear();\ncity.addAll(hashSet);\nToast.makeText(getActivity(),\"\" + city.toString(),Toast.LENGTH_SHORT).show(); ", "question_id": 203984}, "0.0016297649"], [{"answer_votes": "0", "answer_comments": null, "answer_body": " import java.util.*;\nclass RemoveDupFrmString\n{\n    public static void main(String[] args)\n    {\n\n        String s=\"appsc\";\n\n        Set<Character> unique = new LinkedHashSet<Character> ();\n\n        for(char c : s.toCharArray()) {\n\n            System.out.println(unique.add(c));\n        }\n        for(char dis:unique){\n            System.out.println(dis);\n        }\n\n\n    }\n} ", "question_id": 203984}, "0.00094849523"], [{"answer_votes": "0", "answer_comments": null, "answer_body": " Here is my answer without using any other data structure like set or hashmap etc.  public static <T> ArrayList<T> uniquefy(ArrayList<T> myList) {\n\n    ArrayList <T> uniqueArrayList = new ArrayList<T>();\n    for (int i = 0; i < myList.size(); i++){\n        if (!uniqueArrayList.contains(myList.get(i))){\n            uniqueArrayList.add(myList.get(i));\n        }\n    }\n\n    return uniqueArrayList;\n} ", "question_id": 203984}, "0.0009206951"], [{"answer_votes": "0", "answer_comments": null, "answer_body": " This is used for your Custom Objects list  public List<Contact> removeDuplicates(List<Contact> list) {\n    // Set set1 = new LinkedHashSet(list);\n    Set set = new TreeSet(new Comparator() {\n\n        @Override\n        public int compare(Object o1, Object o2) {\n            if (((Contact) o1).getId().equalsIgnoreCase(((Contact) o2).getId()) /*&&\n                    ((Contact)o1).getName().equalsIgnoreCase(((Contact)o2).getName())*/) {\n                return 0;\n            }\n            return 1;\n        }\n    });\n    set.addAll(list);\n\n    final List newList = new ArrayList(set);\n    return newList;\n} ", "question_id": 203984}, "0.0008209051"], [{"answer_votes": "8", "answer_comments": [" This implementation return no element in the list because of the last j-- \u2013 neo7  Sep 23 '15 at 9:29 ", " This implementation work's very fine.there is no issue behind this and for this task i am only use one arraylist.so this answer is completely good.before giving negative feedback you shold also add testcase also so that every one can understand the result.Thanks Manash \u2013 Manash Ranjan Dakua  Sep 24 '15 at 13:14 ", " This saved the day! \u2013 YehCheez  Mar 9 '16 at 16:09 "], "answer_body": " public static void main(String[] args){\n    ArrayList<Object> al = new ArrayList<Object>();\n    al.add(\"abc\");\n    al.add('a');\n    al.add('b');\n    al.add('a');\n    al.add(\"abc\");\n    al.add(10.3);\n    al.add('c');\n    al.add(10);\n    al.add(\"abc\");\n    al.add(10);\n    System.out.println(\"Before Duplicate Remove:\"+al);\n    for(int i=0;i<al.size();i++){\n        for(int j=i+1;j<al.size();j++){\n            if(al.get(i).equals(al.get(j))){\n                al.remove(j);\n                j--;\n            }\n        }\n    }\n    System.out.println(\"After Removing duplicate:\"+al);\n} ", "question_id": 203984}, "0.0"], [{"answer_votes": "0", "answer_comments": null, "answer_body": " for(int a=0;a<myArray.size();a++){\n        for(int b=a+1;b<myArray.size();b++){\n            if(myArray.get(a).equalsIgnoreCase(myArray.get(b))){\n                myArray.remove(b); \n                dups++;\n                b--;\n            }\n        }\n} ", "question_id": 203984}, "0.0"], [{"answer_votes": "0", "answer_comments": null, "answer_body": " public Set<Object> findDuplicates(List<Object> list) {\n        Set<Object> items = new HashSet<Object>();\n        Set<Object> duplicates = new HashSet<Object>();\n        for (Object item : list) {\n            if (items.contains(item)) {\n                duplicates.add(item);\n                } else { \n                    items.add(item);\n                    } \n            } \n        return duplicates;\n        } ", "question_id": 203984}, "0.0"], [{"answer_votes": "0", "answer_comments": null, "answer_body": " ArrayList<String> list = new ArrayList<String>();\n    HashSet<String> unique = new LinkedHashSet<String>();\n    HashSet<String> dup = new LinkedHashSet<String>();\n    boolean b = false;\n    list.add(\"Hello\");\n    list.add(\"Hello\");\n    list.add(\"how\");\n    list.add(\"are\");\n    list.add(\"u\");\n    list.add(\"u\");\n\n    for(Iterator iterator= list.iterator();iterator.hasNext();)\n    {\n        String value = (String)iterator.next();\n        System.out.println(value);\n\n        if(b==unique.add(value))\n            dup.add(value);\n        else\n            unique.add(value);\n\n\n    }\n    System.out.println(unique);\n    System.out.println(dup); ", "question_id": 203984}, "0.0"]], "nltk_title_analyze_code_result": [[{"answer_votes": "258", "answer_comments": [" Does LinkedHashSet make any guarantees as to which of several duplicates are kept from the list?  For instance, if position 1, 3, and 5 are duplicates in the original list, can we assume that this process will remove 3 and 5?  Or maybe remove 1 and 3?  Thanks. \u2013 Matt Brian\u00e7on  May 1 '11 at 2:20 ", " @Matt: yes, it does guarantee that. The docs say: \"This linked list defines the iteration ordering, which is the order in which elements were inserted into the set (insertion-order). Note that insertion order is not affected if an element is re-inserted into the set.\" \u2013 abahgat  May 2 '11 at 9:00 ", " Very interesting. I have a different situation here. I am not trying to sort String but another object called AwardYearSource. This class has an int attribute called year. So I want to remove duplicates based on the year. i.e if there is year 2010 mentioned more than once, I want to remove that AwardYearSource object. How can I do that? \u2013 WowBow  Apr 16 '12 at 15:27 ", " @WowBow For example you can define Wrapper object which holds AwardYearSource. And define this Wrapper objects equals method based on AwardYearSources year field. Then you can use Set with these Wrapper objects. \u2013 Ondrej Bozek  Jun 20 '12 at 12:19 ", " @WowBow or implement Comparable/Comparator \u2013 shrini1000  Jan 11 '13 at 5:09 "], "answer_body": " Although converting the ArrayList to a HashSet effectively removes duplicates, if you need to preserve insertion order, I'd rather suggest you to use this variant  // list is some List of Strings\nSet<String> s = new LinkedHashSet<>(list);  Then, if you need to get back a List reference, you can use again the conversion constructor. ", "question_id": 203984}, 1], [{"answer_votes": "48", "answer_comments": [" Similarly at the bottom of the thread, I have given an answer where I am using Set for Custom Object. In a case if anyone have custom object like \"Contact\" or \"Student\" can use that answer that works fine for me. \u2013 Muhammad Adil  Oct 25 '16 at 14:16 "], "answer_body": " If you don't want duplicates, use a Set instead of a List . To convert a List to a Set you can use the following code:  // list is some List of Strings\nSet<String> s = new HashSet<String>(list);  If really necessary you can use the same construction to convert a Set back into a List . ", "question_id": 203984}, 1], [{"answer_votes": "824", "answer_comments": [" See also LinkedHashSet, if you wish to retain the order. \u2013 volley  Dec 9 '09 at 20:38 ", " But this will just create the set without duplicates , I want to know which number was duplicate in O(n) time \u2013 Chetan  Mar 29 '12 at 19:43 ", " @Chetan finding all duplicates from ArrayList in O(n), its important to have correctly defined equals method on objects which you have in the list (no problem for numbers): public Set<Object> findDuplicates(List<Object> list)       {           Set<Object> items = new HashSet<Object>();           Set<Object> duplicates = new HashSet<Object>();           for (Object item : list) {               if (items.contains(item)) {                   duplicates.add(item);               } else {                   items.add(item);               }           }           return duplicates;       } \u2013 Ondrej Bozek  Jun 20 '12 at 12:06  ", " A good practice would be to define variables using the interface types List and Set (instead of implementation types ArrayList and HashSet as in your example). \u2013 Jonik  Aug 29 '13 at 7:27 ", " You can clean this up by using new HashSet(al) instead of initializing it to empty and calling addAll . \u2013 ashes999  Dec 26 '13 at 12:44 "], "answer_body": " If you don't want duplicates in a Collection , you should consider why you're using a Collection that allows duplicates. The easiest way to remove repeated elements is to add the contents to a Set (which will not allow duplicates) and then add the Set back to the ArrayList :  List<String> al = new ArrayList<>();\n// add elements to al, including duplicates\nSet<String> hs = new HashSet<>();\nhs.addAll(al);\nal.clear();\nal.addAll(hs);  Of course, this destroys the ordering of the elements in the ArrayList . ", "question_id": 203984}, 0], [{"answer_votes": "83", "answer_comments": [" very elegant. Thanks \u2013 paskos  Feb 12 '15 at 20:04 ", " How do i do this for case insensitive distinct ? \u2013 StackFlowed  Sep 13 '16 at 20:04  ", " @StackFlowed If you don't need to preserve the order of the list you can addAll to new TreeSet<String>(String.CASE_INSENSITIVE_ORDER) .  The first element added will remain in the set so if your list contains \"Dog\" and \"dog\" (in that order) the TreeSet will contain \"Dog\". If order must be preserved then before the line in the answer put list.replaceAll(String::toUpperCase); . \u2013 Paul  Nov 3 '17 at 23:28  ", " I am getting this error :incompatible types: List<Object> cannot be converted to List<String> \u2013 Samir  Apr 4 at 14:34 "], "answer_body": " In Java 8:  List<String> deduped = list.stream().distinct().collect(Collectors.toList());  Please note that the hashCode-equals contract for list members should be respected for the filtering to work properly. ", "question_id": 203984}, 0], [{"answer_votes": "24", "answer_comments": [" This answer lacks two things: 1) It does not use generics, but raw types ( ArrayList<T> should be used instead of ArrayList ) 2) The explicit iterator creating can be avoided by using a for (T current : l1) { ... } . Even if you wanted to use an Iterator explicitly, iterador is misspelled. \u2013 RAnders00  Dec 7 '15 at 16:22 ", " And this implementation runs in quadratic time, compared to the linked hash set implementation running in linear time. (i.e. this takes 10 times longer on a list with 10 elements, 10,000 times longer on a list with 10,000 elements. JDK 6 implementation for ArrayList.contains , JDK8 impl is the same.) \u2013 Patrick M  Jul 11 '16 at 16:09 "], "answer_body": " Here's a way that doesn't affect your list ordering:  ArrayList l1 = new ArrayList();\nArrayList l2 = new ArrayList();\n\nIterator iterator = l1.iterator();\n\n        while (iterator.hasNext())\n        {\n            YourClass o = (YourClass) iterator.next();\n            if(!l2.contains(o)) l2.add(o);\n        }  l1 is the original list, and l2 is the list whithout repeated items\n(Make sure YourClass has the equals method acording to what you want to stand for equality) ", "question_id": 203984}, 0], [{"answer_votes": "24", "answer_comments": [" +1 for Java 8 streams. But if case-sensitivity is not required then only Java 8 solution can be easily modified. List<String> deDupStringList3 = stringList.parallelStream().map(String::toLowerCase).distinct().collect(Collectors.toList()); should work. \u2013 Diablo  Jun 10 '16 at 8:13 "], "answer_body": " Suppose we have a list of String like:  List<String> strList = new ArrayList<>(5);\n// insert up to five items to list.  Then we can remove duplicate elements in in multiple ways.  Prior to Java 8  List<String> deDupStringList = new ArrayList<>(new HashSet<>(strList));  Using Guava  List<String> deDupStringList2 = Lists.newArrayList(Sets.newHashSet(strList));  Using Java 8  List<String> deDupStringList3 = strList.stream().distinct().collect(Collectors.toList());  Note: If we want to maintain the insertion order then we need to use LinkedHashSet in place of HashSet . ", "question_id": 203984}, 0], [{"answer_votes": "19", "answer_comments": null, "answer_body": " Java 8 streams provide a very simple way to remove duplicate elements from a list. Using the distinct method.\nIf we have a list of cities and we want to remove duplicates from that list it can be done in a single line -  List<String> cityList = new ArrayList<>();\n cityList.add(\"Delhi\");\n cityList.add(\"Mumbai\");\n cityList.add(\"Bangalore\");\n cityList.add(\"Chennai\");\n cityList.add(\"Kolkata\");\n cityList.add(\"Mumbai\");\n\n cityList = cityList.stream().distinct().collect(Collectors.toList());  How to remove duplicate elements from an arraylist ", "question_id": 203984}, 0], [{"answer_votes": "19", "answer_comments": [" Note that there is an ImmutableSet.asList() method, returning an ImmutableList , if you need it back as a List . \u2013 Andy Turner  Oct 27 '17 at 19:25 "], "answer_body": " There is also ImmutableSet from Guava as an option ( here is the documentation):  ImmutableSet.copyOf(list); ", "question_id": 203984}, 0], [{"answer_votes": "18", "answer_comments": [" It's slow and you might get a ConcurrentModificationException. \u2013 maaartinus  Oct 18 '13 at 9:39 ", " @maaartinus Have you tried that code ?. It won't produce any exceptions.Also it is pretty fast. I tried the code before posting. \u2013 CarlJohn  Oct 18 '13 at 10:35  ", " You're right, it doesn't as you iterate the array instead of the list. However, it's slow like hell. Try it with a few millions elements. Compare it to ImmutableSet.copyOf(lst).toList() . \u2013 maaartinus  Oct 18 '13 at 10:49  ", " answers the question I was asked in the interview .. How to remove repeated values from an ArrayList without using Sets. Thanx \u2013 Aniket Paul  May 5 '16 at 9:10 ", " Internally, indexOf iterates the lst using a for loop. \u2013 Patrick M  Jul 11 '16 at 17:32 "], "answer_body": " It is possible to remove duplicates from arraylist without using HashSet or one more arraylist .  Try this code..  ArrayList<String> lst = new ArrayList<String>();\n    lst.add(\"ABC\");\n    lst.add(\"ABC\");\n    lst.add(\"ABCD\");\n    lst.add(\"ABCD\");\n    lst.add(\"ABCE\");\n\n    System.out.println(\"Duplicates List \"+lst);\n\n    Object[] st = lst.toArray();\n      for (Object s : st) {\n        if (lst.indexOf(s) != lst.lastIndexOf(s)) {\n            lst.remove(lst.lastIndexOf(s));\n         }\n      }\n\n    System.out.println(\"Distinct List \"+lst);  Output is  Duplicates List [ABC, ABC, ABCD, ABCD, ABCE]\nDistinct List [ABC, ABCD, ABCE] ", "question_id": 203984}, 0], [{"answer_votes": "14", "answer_comments": [" Works perfect.. Thanks for saving my head from loops :) :) \u2013 Sanoop  Dec 21 '16 at 11:17 "], "answer_body": " You can also do it this way, and preserve order:  // delete duplicates (if any) from 'myArrayList'\nmyArrayList = new ArrayList<String>(new LinkedHashSet<String>(myArrayList)); ", "question_id": 203984}, 0], [{"answer_votes": "10", "answer_comments": [" Why use ArrayList in parameter? Why not just List? Will that not work? \u2013 Shervin Asgari  Nov 12 '09 at 15:54 ", " A List will absolutely work as in-parameter for the first method listed. The method is however optimized for use with a random access list such as ArrayList, so if a LinkedList is passed instead you will get poor performance. For example, setting the n:th element in a LinkedList takes O(n) time, whereas setting the n:th element in a random access list (such as ArrayList) takes O(1) time. Again, though, this is probably overkill... If you need this kind of specialized code it will hopefully be in an isolated situation. \u2013 volley  Dec 9 '09 at 20:37 ", " This is precisely what I needed, thanks \u2013 Jasper Holton  Jun 1 '14 at 2:15 "], "answer_body": " Probably a bit overkill, but I enjoy this kind of isolated problem. :)  This code uses a temporary Set (for the uniqueness check) but removes elements directly inside the original list. Since element removal inside an ArrayList can induce a huge amount of array copying, the remove(int)-method is avoided.  public static <T> void removeDuplicates(ArrayList<T> list) {\n    int size = list.size();\n    int out = 0;\n    {\n        final Set<T> encountered = new HashSet<T>();\n        for (int in = 0; in < size; in++) {\n            final T t = list.get(in);\n            final boolean first = encountered.add(t);\n            if (first) {\n                list.set(out++, t);\n            }\n        }\n    }\n    while (out < size) {\n        list.remove(--size);\n    }\n}  While we're at it, here's a version for LinkedList (a lot nicer!):  public static <T> void removeDuplicates(LinkedList<T> list) {\n    final Set<T> encountered = new HashSet<T>();\n    for (Iterator<T> iter = list.iterator(); iter.hasNext(); ) {\n        final T t = iter.next();\n        final boolean first = encountered.add(t);\n        if (!first) {\n            iter.remove();\n        }\n    }\n}  Use the marker interface to present a unified solution for List:  public static <T> void removeDuplicates(List<T> list) {\n    if (list instanceof RandomAccess) {\n        // use first version here\n    } else {\n        // use other version here\n    }\n}  EDIT: I guess the generics-stuff doesn't really add any value here.. Oh well. :) ", "question_id": 203984}, 0], [{"answer_votes": "9", "answer_comments": [" I liked this solution better. \u2013 Tushar Gogna  Dec 5 '17 at 7:19 "], "answer_body": " this can solve the problem:  private List<SomeClass> clearListFromDuplicateFirstName(List<SomeClass> list1) {\n\nMap<String, SomeClass> cleanMap = new LinkedHashMap<String, SomeClass>();\nfor (int i = 0; i < list1.size(); i++) {\n     cleanMap.put(list1.get(i).getFirstName(), list1.get(i));\n}\nList<SomeClass> list = new ArrayList<SomeClass>(cleanMap.values());\nreturn list;\n} ", "question_id": 203984}, 0], [{"answer_votes": "8", "answer_comments": [" This implementation return no element in the list because of the last j-- \u2013 neo7  Sep 23 '15 at 9:29 ", " This implementation work's very fine.there is no issue behind this and for this task i am only use one arraylist.so this answer is completely good.before giving negative feedback you shold also add testcase also so that every one can understand the result.Thanks Manash \u2013 Manash Ranjan Dakua  Sep 24 '15 at 13:14 ", " This saved the day! \u2013 YehCheez  Mar 9 '16 at 16:09 "], "answer_body": " public static void main(String[] args){\n    ArrayList<Object> al = new ArrayList<Object>();\n    al.add(\"abc\");\n    al.add('a');\n    al.add('b');\n    al.add('a');\n    al.add(\"abc\");\n    al.add(10.3);\n    al.add('c');\n    al.add(10);\n    al.add(\"abc\");\n    al.add(10);\n    System.out.println(\"Before Duplicate Remove:\"+al);\n    for(int i=0;i<al.size();i++){\n        for(int j=i+1;j<al.size();j++){\n            if(al.get(i).equals(al.get(j))){\n                al.remove(j);\n                j--;\n            }\n        }\n    }\n    System.out.println(\"After Removing duplicate:\"+al);\n} ", "question_id": 203984}, 0], [{"answer_votes": "5", "answer_comments": null, "answer_body": " If you're willing to use a third-party library, you can use the method distinct() in Eclipse Collections (formerly GS Collections).  ListIterable<Integer> integers = FastList.newListWith(1, 3, 1, 2, 2, 1);\nAssert.assertEquals(\n    FastList.newListWith(1, 3, 2),\n    integers.distinct());  The advantage of using distinct() instead of converting to a Set and then back to a List is that distinct() preserves the order of the original List, retaining the first occurrence of each element. It's implemented by using both a Set and a List.  MutableSet<T> seenSoFar = UnifiedSet.newSet();\nint size = list.size();\nfor (int i = 0; i < size; i++)\n{\n    T item = list.get(i);\n    if (seenSoFar.add(item))\n    {\n        targetCollection.add(item);\n    }\n}\nreturn targetCollection;  If you cannot convert your original List into an Eclipse Collections type, you can use ListAdapter to get the same API.  MutableList<Integer> distinct = ListAdapter.adapt(integers).distinct();  Note: I am a committer for Eclipse Collections. ", "question_id": 203984}, 0], [{"answer_votes": "3", "answer_comments": null, "answer_body": " This three lines of code can remove the duplicated element from ArrayList or any collection.  List<Entity> entities = repository.findByUserId(userId);\n\nSet<Entity> s = new LinkedHashSet<Entity>(entities);\nentities.clear();\nentities.addAll(s); ", "question_id": 203984}, 0], [{"answer_votes": "2", "answer_comments": null, "answer_body": " When you are filling the ArrayList, use a condition for each element. For example:  ArrayList< Integer > al = new ArrayList< Integer >(); \n\n    // fill 1 \n    for ( int i = 0; i <= 5; i++ ) \n        if ( !al.contains( i ) ) \n            al.add( i ); \n\n    // fill 2 \n    for (int i = 0; i <= 10; i++ ) \n        if ( !al.contains( i ) ) \n            al.add( i ); \n\n    for( Integer i: al )\n    {\n        System.out.print( i + \" \");     \n    }  We will get an array {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10} ", "question_id": 203984}, 0], [{"answer_votes": "2", "answer_comments": null, "answer_body": " If you want to preserve your Order then it is best to use LinkedHashSet .\nBecause if you want to pass this List to an Insert Query by Iterating it, the order would be preserved.  Try this  LinkedHashSet link=new LinkedHashSet();\nList listOfValues=new ArrayList();\nlistOfValues.add(link);  This conversion will be very helpful when you want to return a List but not a Set. ", "question_id": 203984}, 0], [{"answer_votes": "2", "answer_comments": null, "answer_body": " Code:  List<String> duplicatList = new ArrayList<String>();\nduplicatList = Arrays.asList(\"AA\",\"BB\",\"CC\",\"DD\",\"DD\",\"EE\",\"AA\",\"FF\");\n//above AA and DD are duplicate\nSet<String> uniqueList = new HashSet<String>(duplicatList);\nduplicatList = new ArrayList<String>(uniqueList); //let GC will doing free memory\nSystem.out.println(\"Removed Duplicate : \"+duplicatList);  Note: Definitely, there will be memory overhead. ", "question_id": 203984}, 0], [{"answer_votes": "2", "answer_comments": null, "answer_body": " ArrayList<String> city=new ArrayList<String>();\ncity.add(\"rajkot\");\ncity.add(\"gondal\");\ncity.add(\"rajkot\");\ncity.add(\"gova\");\ncity.add(\"baroda\");\ncity.add(\"morbi\");\ncity.add(\"gova\");\n\nHashSet<String> hashSet = new HashSet<String>();\nhashSet.addAll(city);\ncity.clear();\ncity.addAll(hashSet);\nToast.makeText(getActivity(),\"\" + city.toString(),Toast.LENGTH_SHORT).show(); ", "question_id": 203984}, 0], [{"answer_votes": "1", "answer_comments": null, "answer_body": " As said before, you should use a class implementing Set interface instead of List to be sure of unicity of elements. If you have to keep the order of elements, the SortedSet interface can then be used ; the TreeSet class implements that interface. ", "question_id": 203984}, 0], [{"answer_votes": "1", "answer_comments": null, "answer_body": " LinkedHashSet will do the trick.  String[] arr2 = {\"5\",\"1\",\"2\",\"3\",\"3\",\"4\",\"1\",\"2\"};\nSet<String> set = new LinkedHashSet<String>(Arrays.asList(arr2));\nfor(String s1 : set)\n    System.out.println(s1);\n\nSystem.out.println( \"------------------------\" );\nString[] arr3 = set.toArray(new String[0]);\nfor(int i = 0; i < arr3.length; i++)\n     System.out.println(arr3[i].toString());  //output: 5,1,2,3,4 ", "question_id": 203984}, 0], [{"answer_votes": "1", "answer_comments": null, "answer_body": " List<String> result = new ArrayList<String>();\n        Set<String> set = new LinkedHashSet<String>();\n        String s = \"ravi is a good!boy. But ravi is very nasty fellow.\";\n        StringTokenizer st = new StringTokenizer(s, \" ,. ,!\");\n        while (st.hasMoreTokens()) {\n            result.add(st.nextToken());\n        }\n         System.out.println(result);\n         set.addAll(result);\n        result.clear();\n        result.addAll(set);\n        System.out.println(result);\n\noutput:\n[ravi, is, a, good, boy, But, ravi, is, very, nasty, fellow]\n[ravi, is, a, good, boy, But, very, nasty, fellow] ", "question_id": 203984}, 0], [{"answer_votes": "1", "answer_comments": [" This thread is years old... \u2013 WolfieeifloW  Nov 30 '17 at 18:43 "], "answer_body": " you can use nested loop in follow :  ArrayList<Class1> l1 = new ArrayList<Class1>();\nArrayList<Class1> l2 = new ArrayList<Class1>();\n\n        Iterator iterator1 = l1.iterator();\n        boolean repeated = false;\n\n        while (iterator1.hasNext())\n        {\n            Class1 c1 = (Class1) iterator1.next();\n            for (Class1 _c: l2) {\n                if(_c.getId() == c1.getId())\n                    repeated = true;\n            }\n            if(!repeated)\n                l2.add(c1);\n        } ", "question_id": 203984}, 0], [{"answer_votes": "0", "answer_comments": null, "answer_body": " for(int a=0;a<myArray.size();a++){\n        for(int b=a+1;b<myArray.size();b++){\n            if(myArray.get(a).equalsIgnoreCase(myArray.get(b))){\n                myArray.remove(b); \n                dups++;\n                b--;\n            }\n        }\n} ", "question_id": 203984}, 0], [{"answer_votes": "0", "answer_comments": null, "answer_body": " import java.util.*;\nclass RemoveDupFrmString\n{\n    public static void main(String[] args)\n    {\n\n        String s=\"appsc\";\n\n        Set<Character> unique = new LinkedHashSet<Character> ();\n\n        for(char c : s.toCharArray()) {\n\n            System.out.println(unique.add(c));\n        }\n        for(char dis:unique){\n            System.out.println(dis);\n        }\n\n\n    }\n} ", "question_id": 203984}, 0], [{"answer_votes": "0", "answer_comments": null, "answer_body": " public Set<Object> findDuplicates(List<Object> list) {\n        Set<Object> items = new HashSet<Object>();\n        Set<Object> duplicates = new HashSet<Object>();\n        for (Object item : list) {\n            if (items.contains(item)) {\n                duplicates.add(item);\n                } else { \n                    items.add(item);\n                    } \n            } \n        return duplicates;\n        } ", "question_id": 203984}, 0], [{"answer_votes": "0", "answer_comments": null, "answer_body": " ArrayList<String> list = new ArrayList<String>();\n    HashSet<String> unique = new LinkedHashSet<String>();\n    HashSet<String> dup = new LinkedHashSet<String>();\n    boolean b = false;\n    list.add(\"Hello\");\n    list.add(\"Hello\");\n    list.add(\"how\");\n    list.add(\"are\");\n    list.add(\"u\");\n    list.add(\"u\");\n\n    for(Iterator iterator= list.iterator();iterator.hasNext();)\n    {\n        String value = (String)iterator.next();\n        System.out.println(value);\n\n        if(b==unique.add(value))\n            dup.add(value);\n        else\n            unique.add(value);\n\n\n    }\n    System.out.println(unique);\n    System.out.println(dup); ", "question_id": 203984}, 0], [{"answer_votes": "0", "answer_comments": [" Why would you post a quadratic solution to a question that already has 2-year-old linear and log-linear solutions, that are also simpler? \u2013 abarnert  Sep 11 '14 at 7:40 "], "answer_body": " If you want to remove duplicates from ArrayList means find the below logic,  public static Object[] removeDuplicate(Object[] inputArray)\n{\n    long startTime = System.nanoTime();\n    int totalSize = inputArray.length;\n    Object[] resultArray = new Object[totalSize];\n    int newSize = 0;\n    for(int i=0; i<totalSize; i++)\n    {\n        Object value = inputArray[i];\n        if(value == null)\n        {\n            continue;\n        }\n\n        for(int j=i+1; j<totalSize; j++)\n        {\n            if(value.equals(inputArray[j]))\n            {\n                inputArray[j] = null;\n            }\n        }\n        resultArray[newSize++] = value;\n    }\n\n    long endTime = System.nanoTime()-startTime;\n    System.out.println(\"Total Time-B:\"+endTime);\n    return resultArray;\n} ", "question_id": 203984}, 0], [{"answer_votes": "0", "answer_comments": null, "answer_body": " The @jonathan-stafford solution is OK. But this don't preserve the list order.  If you want preserve the list order you have to use this:  public static <T> void removeDuplicate(List <T> list) {\nSet <T> set = new HashSet <T>();\nList <T> newList = new ArrayList <T>();\nfor (Iterator <T>iter = list.iterator();    iter.hasNext(); ) {\n   Object element = iter.next();\n   if (set.add((T) element))\n      newList.add((T) element);\n   }\n   list.clear();\n   list.addAll(newList);\n}  It's only to complete the answer. Very good! ", "question_id": 203984}, 0], [{"answer_votes": "0", "answer_comments": null, "answer_body": " Here is my answer without using any other data structure like set or hashmap etc.  public static <T> ArrayList<T> uniquefy(ArrayList<T> myList) {\n\n    ArrayList <T> uniqueArrayList = new ArrayList<T>();\n    for (int i = 0; i < myList.size(); i++){\n        if (!uniqueArrayList.contains(myList.get(i))){\n            uniqueArrayList.add(myList.get(i));\n        }\n    }\n\n    return uniqueArrayList;\n} ", "question_id": 203984}, 0], [{"answer_votes": "0", "answer_comments": null, "answer_body": " Would something like this work better ?  public static void removeDuplicates(ArrayList<String> list) {\nArraylist<Object> ar     = new Arraylist<Object>();\nArraylist<Object> tempAR = new Arraylist<Object>();\nwhile (list.size()>0){\n    ar.add(list(0));\n    list.removeall(Collections.singleton(list(0)));\n}\nlist.addAll(ar);  }  That should maintain the order and also not be quadratic in run time. ", "question_id": 203984}, 0], [{"answer_votes": "0", "answer_comments": null, "answer_body": " This is used for your Custom Objects list  public List<Contact> removeDuplicates(List<Contact> list) {\n    // Set set1 = new LinkedHashSet(list);\n    Set set = new TreeSet(new Comparator() {\n\n        @Override\n        public int compare(Object o1, Object o2) {\n            if (((Contact) o1).getId().equalsIgnoreCase(((Contact) o2).getId()) /*&&\n                    ((Contact)o1).getName().equalsIgnoreCase(((Contact)o2).getName())*/) {\n                return 0;\n            }\n            return 1;\n        }\n    });\n    set.addAll(list);\n\n    final List newList = new ArrayList(set);\n    return newList;\n} ", "question_id": 203984}, 0], [{"answer_votes": "0", "answer_comments": null, "answer_body": " If you are using model type List< T>/ArrayList< T> . Hope,it's help you.   Here is my code without using any other data structure like set or hashmap  for(int i = 0; i < Models.size(); i++) {\n     for(int j = i + 1; j < Models.size(); j++) {                                \n       if(Models.get(i).getName().equals(Models.get(j).getName())){    \n                                Models.remove(j);\n\n                                j--;\n                            }\n                        }\n                    } ", "question_id": 203984}, 0], [{"answer_votes": "-1", "answer_comments": null, "answer_body": " In Java, List permits ordered access of their elements. They can have duplicates because their lookup key is the position not some hash code, every element can be modified while they remain in the list where as Set represents a collection of unique elements and while elements are in set, they must not be modified.While there is no restriction preventing you from modifying elements in a set, if an element is modified, then it could become forever lost in the set.  public static void main(String[] args) {  \n           List<String> l = new ArrayList<String>();  \n           l.add(\"A\");  \n           l.add(\"B\");  \n           l.add(\"C\");  \n           l.add(\"A\");  \n           System.out.println(\"Before removing duplicates: \");  \n           for (String s : l) {  \n                System.out.println(s);  \n           }  \n           Set<String> set = new HashSet<String>(l);  \n           List<String> newlist = new ArrayList<String>(set);  \n           System.out.println(\"after removing duplicates: \");  \n           for (String s : newlist) {  \n                System.out.println(s);  \n           }  \n      }  for reference , refer this link How to remove duplicates from ArrayList  ", "question_id": 203984}, 0]], "merge_gensim_nltk_title": [[{"answer_votes": "258", "answer_comments": [" Does LinkedHashSet make any guarantees as to which of several duplicates are kept from the list?  For instance, if position 1, 3, and 5 are duplicates in the original list, can we assume that this process will remove 3 and 5?  Or maybe remove 1 and 3?  Thanks. \u2013 Matt Brian\u00e7on  May 1 '11 at 2:20 ", " @Matt: yes, it does guarantee that. The docs say: \"This linked list defines the iteration ordering, which is the order in which elements were inserted into the set (insertion-order). Note that insertion order is not affected if an element is re-inserted into the set.\" \u2013 abahgat  May 2 '11 at 9:00 ", " Very interesting. I have a different situation here. I am not trying to sort String but another object called AwardYearSource. This class has an int attribute called year. So I want to remove duplicates based on the year. i.e if there is year 2010 mentioned more than once, I want to remove that AwardYearSource object. How can I do that? \u2013 WowBow  Apr 16 '12 at 15:27 ", " @WowBow For example you can define Wrapper object which holds AwardYearSource. And define this Wrapper objects equals method based on AwardYearSources year field. Then you can use Set with these Wrapper objects. \u2013 Ondrej Bozek  Jun 20 '12 at 12:19 ", " @WowBow or implement Comparable/Comparator \u2013 shrini1000  Jan 11 '13 at 5:09 "], "answer_body": " Although converting the ArrayList to a HashSet effectively removes duplicates, if you need to preserve insertion order, I'd rather suggest you to use this variant  // list is some List of Strings\nSet<String> s = new LinkedHashSet<>(list);  Then, if you need to get back a List reference, you can use again the conversion constructor. ", "question_id": 203984}, "0.149879890.149879890.149879890.149879890.149879890.149879890.149879890.149879890.149879890.149879890.149879890.149879890.149879890.149879890.14987989"], [{"answer_votes": "19", "answer_comments": null, "answer_body": " Java 8 streams provide a very simple way to remove duplicate elements from a list. Using the distinct method.\nIf we have a list of cities and we want to remove duplicates from that list it can be done in a single line -  List<String> cityList = new ArrayList<>();\n cityList.add(\"Delhi\");\n cityList.add(\"Mumbai\");\n cityList.add(\"Bangalore\");\n cityList.add(\"Chennai\");\n cityList.add(\"Kolkata\");\n cityList.add(\"Mumbai\");\n\n cityList = cityList.stream().distinct().collect(Collectors.toList());  How to remove duplicate elements from an arraylist ", "question_id": 203984}, "0.121234050.121234050.121234050.121234050.121234050.121234050.121234050.121234050.121234050.121234050.121234050.121234050.121234050.121234050.121234050.121234050.121234050.121234050.12123405"], [{"answer_votes": "14", "answer_comments": [" Works perfect.. Thanks for saving my head from loops :) :) \u2013 Sanoop  Dec 21 '16 at 11:17 "], "answer_body": " You can also do it this way, and preserve order:  // delete duplicates (if any) from 'myArrayList'\nmyArrayList = new ArrayList<String>(new LinkedHashSet<String>(myArrayList)); ", "question_id": 203984}, "0.1202561860.1202561860.1202561860.1202561860.1202561860.1202561860.120256186"], [{"answer_votes": "2", "answer_comments": null, "answer_body": " If you want to preserve your Order then it is best to use LinkedHashSet .\nBecause if you want to pass this List to an Insert Query by Iterating it, the order would be preserved.  Try this  LinkedHashSet link=new LinkedHashSet();\nList listOfValues=new ArrayList();\nlistOfValues.add(link);  This conversion will be very helpful when you want to return a List but not a Set. ", "question_id": 203984}, "0.1141298860.1141298860.1141298860.1141298860.1141298860.1141298860.1141298860.1141298860.1141298860.1141298860.1141298860.1141298860.1141298860.1141298860.1141298860.1141298860.114129886"], [{"answer_votes": "5", "answer_comments": null, "answer_body": " If you're willing to use a third-party library, you can use the method distinct() in Eclipse Collections (formerly GS Collections).  ListIterable<Integer> integers = FastList.newListWith(1, 3, 1, 2, 2, 1);\nAssert.assertEquals(\n    FastList.newListWith(1, 3, 2),\n    integers.distinct());  The advantage of using distinct() instead of converting to a Set and then back to a List is that distinct() preserves the order of the original List, retaining the first occurrence of each element. It's implemented by using both a Set and a List.  MutableSet<T> seenSoFar = UnifiedSet.newSet();\nint size = list.size();\nfor (int i = 0; i < size; i++)\n{\n    T item = list.get(i);\n    if (seenSoFar.add(item))\n    {\n        targetCollection.add(item);\n    }\n}\nreturn targetCollection;  If you cannot convert your original List into an Eclipse Collections type, you can use ListAdapter to get the same API.  MutableList<Integer> distinct = ListAdapter.adapt(integers).distinct();  Note: I am a committer for Eclipse Collections. ", "question_id": 203984}, "0.099292790.099292790.099292790.099292790.099292790.099292790.099292790.099292790.099292790.099292790.099292790.099292790.099292790.099292790.099292790.099292790.099292790.099292790.099292790.099292790.099292790.099292790.099292790.099292790.099292790.099292790.099292790.099292790.099292790.099292790.099292790.099292790.09929279"], [{"answer_votes": "824", "answer_comments": [" See also LinkedHashSet, if you wish to retain the order. \u2013 volley  Dec 9 '09 at 20:38 ", " But this will just create the set without duplicates , I want to know which number was duplicate in O(n) time \u2013 Chetan  Mar 29 '12 at 19:43 ", " @Chetan finding all duplicates from ArrayList in O(n), its important to have correctly defined equals method on objects which you have in the list (no problem for numbers): public Set<Object> findDuplicates(List<Object> list)       {           Set<Object> items = new HashSet<Object>();           Set<Object> duplicates = new HashSet<Object>();           for (Object item : list) {               if (items.contains(item)) {                   duplicates.add(item);               } else {                   items.add(item);               }           }           return duplicates;       } \u2013 Ondrej Bozek  Jun 20 '12 at 12:06  ", " A good practice would be to define variables using the interface types List and Set (instead of implementation types ArrayList and HashSet as in your example). \u2013 Jonik  Aug 29 '13 at 7:27 ", " You can clean this up by using new HashSet(al) instead of initializing it to empty and calling addAll . \u2013 ashes999  Dec 26 '13 at 12:44 "], "answer_body": " If you don't want duplicates in a Collection , you should consider why you're using a Collection that allows duplicates. The easiest way to remove repeated elements is to add the contents to a Set (which will not allow duplicates) and then add the Set back to the ArrayList :  List<String> al = new ArrayList<>();\n// add elements to al, including duplicates\nSet<String> hs = new HashSet<>();\nhs.addAll(al);\nal.clear();\nal.addAll(hs);  Of course, this destroys the ordering of the elements in the ArrayList . ", "question_id": 203984}, "0.093042130.093042130.093042130.093042130.093042130.093042130.093042130.093042130.093042130.093042130.093042130.093042130.093042130.093042130.093042130.093042130.09304213"], [{"answer_votes": "10", "answer_comments": [" Why use ArrayList in parameter? Why not just List? Will that not work? \u2013 Shervin Asgari  Nov 12 '09 at 15:54 ", " A List will absolutely work as in-parameter for the first method listed. The method is however optimized for use with a random access list such as ArrayList, so if a LinkedList is passed instead you will get poor performance. For example, setting the n:th element in a LinkedList takes O(n) time, whereas setting the n:th element in a random access list (such as ArrayList) takes O(1) time. Again, though, this is probably overkill... If you need this kind of specialized code it will hopefully be in an isolated situation. \u2013 volley  Dec 9 '09 at 20:37 ", " This is precisely what I needed, thanks \u2013 Jasper Holton  Jun 1 '14 at 2:15 "], "answer_body": " Probably a bit overkill, but I enjoy this kind of isolated problem. :)  This code uses a temporary Set (for the uniqueness check) but removes elements directly inside the original list. Since element removal inside an ArrayList can induce a huge amount of array copying, the remove(int)-method is avoided.  public static <T> void removeDuplicates(ArrayList<T> list) {\n    int size = list.size();\n    int out = 0;\n    {\n        final Set<T> encountered = new HashSet<T>();\n        for (int in = 0; in < size; in++) {\n            final T t = list.get(in);\n            final boolean first = encountered.add(t);\n            if (first) {\n                list.set(out++, t);\n            }\n        }\n    }\n    while (out < size) {\n        list.remove(--size);\n    }\n}  While we're at it, here's a version for LinkedList (a lot nicer!):  public static <T> void removeDuplicates(LinkedList<T> list) {\n    final Set<T> encountered = new HashSet<T>();\n    for (Iterator<T> iter = list.iterator(); iter.hasNext(); ) {\n        final T t = iter.next();\n        final boolean first = encountered.add(t);\n        if (!first) {\n            iter.remove();\n        }\n    }\n}  Use the marker interface to present a unified solution for List:  public static <T> void removeDuplicates(List<T> list) {\n    if (list instanceof RandomAccess) {\n        // use first version here\n    } else {\n        // use other version here\n    }\n}  EDIT: I guess the generics-stuff doesn't really add any value here.. Oh well. :) ", "question_id": 203984}, "0.0891944840.0891944840.0891944840.0891944840.0891944840.0891944840.0891944840.0891944840.0891944840.0891944840.0891944840.0891944840.0891944840.0891944840.0891944840.0891944840.0891944840.0891944840.0891944840.0891944840.0891944840.089194484"], [{"answer_votes": "-1", "answer_comments": null, "answer_body": " In Java, List permits ordered access of their elements. They can have duplicates because their lookup key is the position not some hash code, every element can be modified while they remain in the list where as Set represents a collection of unique elements and while elements are in set, they must not be modified.While there is no restriction preventing you from modifying elements in a set, if an element is modified, then it could become forever lost in the set.  public static void main(String[] args) {  \n           List<String> l = new ArrayList<String>();  \n           l.add(\"A\");  \n           l.add(\"B\");  \n           l.add(\"C\");  \n           l.add(\"A\");  \n           System.out.println(\"Before removing duplicates: \");  \n           for (String s : l) {  \n                System.out.println(s);  \n           }  \n           Set<String> set = new HashSet<String>(l);  \n           List<String> newlist = new ArrayList<String>(set);  \n           System.out.println(\"after removing duplicates: \");  \n           for (String s : newlist) {  \n                System.out.println(s);  \n           }  \n      }  for reference , refer this link How to remove duplicates from ArrayList  ", "question_id": 203984}, "0.0874857460.0874857460.0874857460.0874857460.0874857460.0874857460.0874857460.0874857460.0874857460.0874857460.0874857460.0874857460.0874857460.0874857460.0874857460.0874857460.0874857460.0874857460.0874857460.0874857460.0874857460.087485746"], [{"answer_votes": "48", "answer_comments": [" Similarly at the bottom of the thread, I have given an answer where I am using Set for Custom Object. In a case if anyone have custom object like \"Contact\" or \"Student\" can use that answer that works fine for me. \u2013 Muhammad Adil  Oct 25 '16 at 14:16 "], "answer_body": " If you don't want duplicates, use a Set instead of a List . To convert a List to a Set you can use the following code:  // list is some List of Strings\nSet<String> s = new HashSet<String>(list);  If really necessary you can use the same construction to convert a Set back into a List . ", "question_id": 203984}, "0.08069250.08069250.08069250.08069250.08069250.08069250.08069250.08069250.08069250.08069250.0806925"], [{"answer_votes": "1", "answer_comments": null, "answer_body": " As said before, you should use a class implementing Set interface instead of List to be sure of unicity of elements. If you have to keep the order of elements, the SortedSet interface can then be used ; the TreeSet class implements that interface. ", "question_id": 203984}, "0.0714919050.0714919050.0714919050.0714919050.0714919050.0714919050.0714919050.0714919050.0714919050.0714919050.0714919050.071491905"], [{"answer_votes": "0", "answer_comments": null, "answer_body": " Would something like this work better ?  public static void removeDuplicates(ArrayList<String> list) {\nArraylist<Object> ar     = new Arraylist<Object>();\nArraylist<Object> tempAR = new Arraylist<Object>();\nwhile (list.size()>0){\n    ar.add(list(0));\n    list.removeall(Collections.singleton(list(0)));\n}\nlist.addAll(ar);  }  That should maintain the order and also not be quadratic in run time. ", "question_id": 203984}, "0.067886960.067886960.067886960.06788696"], [{"answer_votes": "24", "answer_comments": [" +1 for Java 8 streams. But if case-sensitivity is not required then only Java 8 solution can be easily modified. List<String> deDupStringList3 = stringList.parallelStream().map(String::toLowerCase).distinct().collect(Collectors.toList()); should work. \u2013 Diablo  Jun 10 '16 at 8:13 "], "answer_body": " Suppose we have a list of String like:  List<String> strList = new ArrayList<>(5);\n// insert up to five items to list.  Then we can remove duplicate elements in in multiple ways.  Prior to Java 8  List<String> deDupStringList = new ArrayList<>(new HashSet<>(strList));  Using Guava  List<String> deDupStringList2 = Lists.newArrayList(Sets.newHashSet(strList));  Using Java 8  List<String> deDupStringList3 = strList.stream().distinct().collect(Collectors.toList());  Note: If we want to maintain the insertion order then we need to use LinkedHashSet in place of HashSet . ", "question_id": 203984}, "0.0614505630.0614505630.0614505630.0614505630.0614505630.0614505630.0614505630.0614505630.0614505630.0614505630.0614505630.0614505630.0614505630.061450563"], [{"answer_votes": "1", "answer_comments": [" This thread is years old... \u2013 WolfieeifloW  Nov 30 '17 at 18:43 "], "answer_body": " you can use nested loop in follow :  ArrayList<Class1> l1 = new ArrayList<Class1>();\nArrayList<Class1> l2 = new ArrayList<Class1>();\n\n        Iterator iterator1 = l1.iterator();\n        boolean repeated = false;\n\n        while (iterator1.hasNext())\n        {\n            Class1 c1 = (Class1) iterator1.next();\n            for (Class1 _c: l2) {\n                if(_c.getId() == c1.getId())\n                    repeated = true;\n            }\n            if(!repeated)\n                l2.add(c1);\n        } ", "question_id": 203984}, "0.0594718120.0594718120.0594718120.059471812"], [{"answer_votes": "0", "answer_comments": null, "answer_body": " The @jonathan-stafford solution is OK. But this don't preserve the list order.  If you want preserve the list order you have to use this:  public static <T> void removeDuplicate(List <T> list) {\nSet <T> set = new HashSet <T>();\nList <T> newList = new ArrayList <T>();\nfor (Iterator <T>iter = list.iterator();    iter.hasNext(); ) {\n   Object element = iter.next();\n   if (set.add((T) element))\n      newList.add((T) element);\n   }\n   list.clear();\n   list.addAll(newList);\n}  It's only to complete the answer. Very good! ", "question_id": 203984}, "0.0545699070.0545699070.0545699070.0545699070.0545699070.0545699070.0545699070.0545699070.0545699070.054569907"], [{"answer_votes": "19", "answer_comments": [" Note that there is an ImmutableSet.asList() method, returning an ImmutableList , if you need it back as a List . \u2013 Andy Turner  Oct 27 '17 at 19:25 "], "answer_body": " There is also ImmutableSet from Guava as an option ( here is the documentation):  ImmutableSet.copyOf(list); ", "question_id": 203984}, "0.0482291650.048229165"], [{"answer_votes": "24", "answer_comments": [" This answer lacks two things: 1) It does not use generics, but raw types ( ArrayList<T> should be used instead of ArrayList ) 2) The explicit iterator creating can be avoided by using a for (T current : l1) { ... } . Even if you wanted to use an Iterator explicitly, iterador is misspelled. \u2013 RAnders00  Dec 7 '15 at 16:22 ", " And this implementation runs in quadratic time, compared to the linked hash set implementation running in linear time. (i.e. this takes 10 times longer on a list with 10 elements, 10,000 times longer on a list with 10,000 elements. JDK 6 implementation for ArrayList.contains , JDK8 impl is the same.) \u2013 Patrick M  Jul 11 '16 at 16:09 "], "answer_body": " Here's a way that doesn't affect your list ordering:  ArrayList l1 = new ArrayList();\nArrayList l2 = new ArrayList();\n\nIterator iterator = l1.iterator();\n\n        while (iterator.hasNext())\n        {\n            YourClass o = (YourClass) iterator.next();\n            if(!l2.contains(o)) l2.add(o);\n        }  l1 is the original list, and l2 is the list whithout repeated items\n(Make sure YourClass has the equals method acording to what you want to stand for equality) ", "question_id": 203984}, "0.0478528920.0478528920.0478528920.0478528920.0478528920.047852892"], [{"answer_votes": "3", "answer_comments": null, "answer_body": " This three lines of code can remove the duplicated element from ArrayList or any collection.  List<Entity> entities = repository.findByUserId(userId);\n\nSet<Entity> s = new LinkedHashSet<Entity>(entities);\nentities.clear();\nentities.addAll(s); ", "question_id": 203984}, "0.0413079040.0413079040.0413079040.0413079040.041307904"], [{"answer_votes": "18", "answer_comments": [" It's slow and you might get a ConcurrentModificationException. \u2013 maaartinus  Oct 18 '13 at 9:39 ", " @maaartinus Have you tried that code ?. It won't produce any exceptions.Also it is pretty fast. I tried the code before posting. \u2013 CarlJohn  Oct 18 '13 at 10:35  ", " You're right, it doesn't as you iterate the array instead of the list. However, it's slow like hell. Try it with a few millions elements. Compare it to ImmutableSet.copyOf(lst).toList() . \u2013 maaartinus  Oct 18 '13 at 10:49  ", " answers the question I was asked in the interview .. How to remove repeated values from an ArrayList without using Sets. Thanx \u2013 Aniket Paul  May 5 '16 at 9:10 ", " Internally, indexOf iterates the lst using a for loop. \u2013 Patrick M  Jul 11 '16 at 17:32 "], "answer_body": " It is possible to remove duplicates from arraylist without using HashSet or one more arraylist .  Try this code..  ArrayList<String> lst = new ArrayList<String>();\n    lst.add(\"ABC\");\n    lst.add(\"ABC\");\n    lst.add(\"ABCD\");\n    lst.add(\"ABCD\");\n    lst.add(\"ABCE\");\n\n    System.out.println(\"Duplicates List \"+lst);\n\n    Object[] st = lst.toArray();\n      for (Object s : st) {\n        if (lst.indexOf(s) != lst.lastIndexOf(s)) {\n            lst.remove(lst.lastIndexOf(s));\n         }\n      }\n\n    System.out.println(\"Distinct List \"+lst);  Output is  Duplicates List [ABC, ABC, ABCD, ABCD, ABCE]\nDistinct List [ABC, ABCD, ABCE] ", "question_id": 203984}, "0.020127030.020127030.020127030.020127030.020127030.020127030.020127030.020127030.020127030.020127030.02012703"], [{"answer_votes": "2", "answer_comments": null, "answer_body": " When you are filling the ArrayList, use a condition for each element. For example:  ArrayList< Integer > al = new ArrayList< Integer >(); \n\n    // fill 1 \n    for ( int i = 0; i <= 5; i++ ) \n        if ( !al.contains( i ) ) \n            al.add( i ); \n\n    // fill 2 \n    for (int i = 0; i <= 10; i++ ) \n        if ( !al.contains( i ) ) \n            al.add( i ); \n\n    for( Integer i: al )\n    {\n        System.out.print( i + \" \");     \n    }  We will get an array {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10} ", "question_id": 203984}, "0.0196998060.0196998060.0196998060.0196998060.0196998060.0196998060.0196998060.0196998060.0196998060.0196998060.0196998060.0196998060.019699806"], [{"answer_votes": "0", "answer_comments": [" Why would you post a quadratic solution to a question that already has 2-year-old linear and log-linear solutions, that are also simpler? \u2013 abarnert  Sep 11 '14 at 7:40 "], "answer_body": " If you want to remove duplicates from ArrayList means find the below logic,  public static Object[] removeDuplicate(Object[] inputArray)\n{\n    long startTime = System.nanoTime();\n    int totalSize = inputArray.length;\n    Object[] resultArray = new Object[totalSize];\n    int newSize = 0;\n    for(int i=0; i<totalSize; i++)\n    {\n        Object value = inputArray[i];\n        if(value == null)\n        {\n            continue;\n        }\n\n        for(int j=i+1; j<totalSize; j++)\n        {\n            if(value.equals(inputArray[j]))\n            {\n                inputArray[j] = null;\n            }\n        }\n        resultArray[newSize++] = value;\n    }\n\n    long endTime = System.nanoTime()-startTime;\n    System.out.println(\"Total Time-B:\"+endTime);\n    return resultArray;\n} ", "question_id": 203984}, "0.0195040720.0195040720.0195040720.0195040720.019504072"], [{"answer_votes": "1", "answer_comments": null, "answer_body": " List<String> result = new ArrayList<String>();\n        Set<String> set = new LinkedHashSet<String>();\n        String s = \"ravi is a good!boy. But ravi is very nasty fellow.\";\n        StringTokenizer st = new StringTokenizer(s, \" ,. ,!\");\n        while (st.hasMoreTokens()) {\n            result.add(st.nextToken());\n        }\n         System.out.println(result);\n         set.addAll(result);\n        result.clear();\n        result.addAll(set);\n        System.out.println(result);\n\noutput:\n[ravi, is, a, good, boy, But, ravi, is, very, nasty, fellow]\n[ravi, is, a, good, boy, But, very, nasty, fellow] ", "question_id": 203984}, "0.0166322870.0166322870.0166322870.0166322870.0166322870.0166322870.0166322870.0166322870.0166322870.0166322870.0166322870.0166322870.0166322870.0166322870.0166322870.0166322870.0166322870.0166322870.0166322870.0166322870.0166322870.0166322870.0166322870.016632287"], [{"answer_votes": "0", "answer_comments": null, "answer_body": " If you are using model type List< T>/ArrayList< T> . Hope,it's help you.   Here is my code without using any other data structure like set or hashmap  for(int i = 0; i < Models.size(); i++) {\n     for(int j = i + 1; j < Models.size(); j++) {                                \n       if(Models.get(i).getName().equals(Models.get(j).getName())){    \n                                Models.remove(j);\n\n                                j--;\n                            }\n                        }\n                    } ", "question_id": 203984}, "0.01531087050.01531087050.01531087050.0153108705"], [{"answer_votes": "1", "answer_comments": null, "answer_body": " LinkedHashSet will do the trick.  String[] arr2 = {\"5\",\"1\",\"2\",\"3\",\"3\",\"4\",\"1\",\"2\"};\nSet<String> set = new LinkedHashSet<String>(Arrays.asList(arr2));\nfor(String s1 : set)\n    System.out.println(s1);\n\nSystem.out.println( \"------------------------\" );\nString[] arr3 = set.toArray(new String[0]);\nfor(int i = 0; i < arr3.length; i++)\n     System.out.println(arr3[i].toString());  //output: 5,1,2,3,4 ", "question_id": 203984}, "0.01510036550.01510036550.01510036550.01510036550.01510036550.01510036550.01510036550.01510036550.0151003655"], [{"answer_votes": "2", "answer_comments": null, "answer_body": " Code:  List<String> duplicatList = new ArrayList<String>();\nduplicatList = Arrays.asList(\"AA\",\"BB\",\"CC\",\"DD\",\"DD\",\"EE\",\"AA\",\"FF\");\n//above AA and DD are duplicate\nSet<String> uniqueList = new HashSet<String>(duplicatList);\nduplicatList = new ArrayList<String>(uniqueList); //let GC will doing free memory\nSystem.out.println(\"Removed Duplicate : \"+duplicatList);  Note: Definitely, there will be memory overhead. ", "question_id": 203984}, "0.0130395820.0130395820.0130395820.0130395820.0130395820.0130395820.0130395820.0130395820.0130395820.013039582"], [{"answer_votes": "9", "answer_comments": [" I liked this solution better. \u2013 Tushar Gogna  Dec 5 '17 at 7:19 "], "answer_body": " this can solve the problem:  private List<SomeClass> clearListFromDuplicateFirstName(List<SomeClass> list1) {\n\nMap<String, SomeClass> cleanMap = new LinkedHashMap<String, SomeClass>();\nfor (int i = 0; i < list1.size(); i++) {\n     cleanMap.put(list1.get(i).getFirstName(), list1.get(i));\n}\nList<SomeClass> list = new ArrayList<SomeClass>(cleanMap.values());\nreturn list;\n} ", "question_id": 203984}, "0.012561770.012561770.012561770.012561770.01256177"], [{"answer_votes": "83", "answer_comments": [" very elegant. Thanks \u2013 paskos  Feb 12 '15 at 20:04 ", " How do i do this for case insensitive distinct ? \u2013 StackFlowed  Sep 13 '16 at 20:04  ", " @StackFlowed If you don't need to preserve the order of the list you can addAll to new TreeSet<String>(String.CASE_INSENSITIVE_ORDER) .  The first element added will remain in the set so if your list contains \"Dog\" and \"dog\" (in that order) the TreeSet will contain \"Dog\". If order must be preserved then before the line in the answer put list.replaceAll(String::toUpperCase); . \u2013 Paul  Nov 3 '17 at 23:28  ", " I am getting this error :incompatible types: List<Object> cannot be converted to List<String> \u2013 Samir  Apr 4 at 14:34 "], "answer_body": " In Java 8:  List<String> deduped = list.stream().distinct().collect(Collectors.toList());  Please note that the hashCode-equals contract for list members should be respected for the filtering to work properly. ", "question_id": 203984}, "0.00619887750.0061988775"], [{"answer_votes": "2", "answer_comments": null, "answer_body": " ArrayList<String> city=new ArrayList<String>();\ncity.add(\"rajkot\");\ncity.add(\"gondal\");\ncity.add(\"rajkot\");\ncity.add(\"gova\");\ncity.add(\"baroda\");\ncity.add(\"morbi\");\ncity.add(\"gova\");\n\nHashSet<String> hashSet = new HashSet<String>();\nhashSet.addAll(city);\ncity.clear();\ncity.addAll(hashSet);\nToast.makeText(getActivity(),\"\" + city.toString(),Toast.LENGTH_SHORT).show(); ", "question_id": 203984}, "0.00162976490.0016297649"], [{"answer_votes": "0", "answer_comments": null, "answer_body": " import java.util.*;\nclass RemoveDupFrmString\n{\n    public static void main(String[] args)\n    {\n\n        String s=\"appsc\";\n\n        Set<Character> unique = new LinkedHashSet<Character> ();\n\n        for(char c : s.toCharArray()) {\n\n            System.out.println(unique.add(c));\n        }\n        for(char dis:unique){\n            System.out.println(dis);\n        }\n\n\n    }\n} ", "question_id": 203984}, "0.00094849523"], [{"answer_votes": "0", "answer_comments": null, "answer_body": " Here is my answer without using any other data structure like set or hashmap etc.  public static <T> ArrayList<T> uniquefy(ArrayList<T> myList) {\n\n    ArrayList <T> uniqueArrayList = new ArrayList<T>();\n    for (int i = 0; i < myList.size(); i++){\n        if (!uniqueArrayList.contains(myList.get(i))){\n            uniqueArrayList.add(myList.get(i));\n        }\n    }\n\n    return uniqueArrayList;\n} ", "question_id": 203984}, "0.0009206951"], [{"answer_votes": "0", "answer_comments": null, "answer_body": " This is used for your Custom Objects list  public List<Contact> removeDuplicates(List<Contact> list) {\n    // Set set1 = new LinkedHashSet(list);\n    Set set = new TreeSet(new Comparator() {\n\n        @Override\n        public int compare(Object o1, Object o2) {\n            if (((Contact) o1).getId().equalsIgnoreCase(((Contact) o2).getId()) /*&&\n                    ((Contact)o1).getName().equalsIgnoreCase(((Contact)o2).getName())*/) {\n                return 0;\n            }\n            return 1;\n        }\n    });\n    set.addAll(list);\n\n    final List newList = new ArrayList(set);\n    return newList;\n} ", "question_id": 203984}, "0.0008209051"], [{"answer_votes": "8", "answer_comments": [" This implementation return no element in the list because of the last j-- \u2013 neo7  Sep 23 '15 at 9:29 ", " This implementation work's very fine.there is no issue behind this and for this task i am only use one arraylist.so this answer is completely good.before giving negative feedback you shold also add testcase also so that every one can understand the result.Thanks Manash \u2013 Manash Ranjan Dakua  Sep 24 '15 at 13:14 ", " This saved the day! \u2013 YehCheez  Mar 9 '16 at 16:09 "], "answer_body": " public static void main(String[] args){\n    ArrayList<Object> al = new ArrayList<Object>();\n    al.add(\"abc\");\n    al.add('a');\n    al.add('b');\n    al.add('a');\n    al.add(\"abc\");\n    al.add(10.3);\n    al.add('c');\n    al.add(10);\n    al.add(\"abc\");\n    al.add(10);\n    System.out.println(\"Before Duplicate Remove:\"+al);\n    for(int i=0;i<al.size();i++){\n        for(int j=i+1;j<al.size();j++){\n            if(al.get(i).equals(al.get(j))){\n                al.remove(j);\n                j--;\n            }\n        }\n    }\n    System.out.println(\"After Removing duplicate:\"+al);\n} ", "question_id": 203984}, ""], [{"answer_votes": "0", "answer_comments": null, "answer_body": " for(int a=0;a<myArray.size();a++){\n        for(int b=a+1;b<myArray.size();b++){\n            if(myArray.get(a).equalsIgnoreCase(myArray.get(b))){\n                myArray.remove(b); \n                dups++;\n                b--;\n            }\n        }\n} ", "question_id": 203984}, ""], [{"answer_votes": "0", "answer_comments": null, "answer_body": " public Set<Object> findDuplicates(List<Object> list) {\n        Set<Object> items = new HashSet<Object>();\n        Set<Object> duplicates = new HashSet<Object>();\n        for (Object item : list) {\n            if (items.contains(item)) {\n                duplicates.add(item);\n                } else { \n                    items.add(item);\n                    } \n            } \n        return duplicates;\n        } ", "question_id": 203984}, ""], [{"answer_votes": "0", "answer_comments": null, "answer_body": " ArrayList<String> list = new ArrayList<String>();\n    HashSet<String> unique = new LinkedHashSet<String>();\n    HashSet<String> dup = new LinkedHashSet<String>();\n    boolean b = false;\n    list.add(\"Hello\");\n    list.add(\"Hello\");\n    list.add(\"how\");\n    list.add(\"are\");\n    list.add(\"u\");\n    list.add(\"u\");\n\n    for(Iterator iterator= list.iterator();iterator.hasNext();)\n    {\n        String value = (String)iterator.next();\n        System.out.println(value);\n\n        if(b==unique.add(value))\n            dup.add(value);\n        else\n            unique.add(value);\n\n\n    }\n    System.out.println(unique);\n    System.out.println(dup); ", "question_id": 203984}, ""]], "merge_gensim_nltk_code": [[{"answer_votes": "48", "answer_comments": [" Similarly at the bottom of the thread, I have given an answer where I am using Set for Custom Object. In a case if anyone have custom object like \"Contact\" or \"Student\" can use that answer that works fine for me. \u2013 Muhammad Adil  Oct 25 '16 at 14:16 "], "answer_body": " If you don't want duplicates, use a Set instead of a List . To convert a List to a Set you can use the following code:  // list is some List of Strings\nSet<String> s = new HashSet<String>(list);  If really necessary you can use the same construction to convert a Set back into a List . ", "question_id": 203984}, "0.18222517"], [{"answer_votes": "258", "answer_comments": [" Does LinkedHashSet make any guarantees as to which of several duplicates are kept from the list?  For instance, if position 1, 3, and 5 are duplicates in the original list, can we assume that this process will remove 3 and 5?  Or maybe remove 1 and 3?  Thanks. \u2013 Matt Brian\u00e7on  May 1 '11 at 2:20 ", " @Matt: yes, it does guarantee that. The docs say: \"This linked list defines the iteration ordering, which is the order in which elements were inserted into the set (insertion-order). Note that insertion order is not affected if an element is re-inserted into the set.\" \u2013 abahgat  May 2 '11 at 9:00 ", " Very interesting. I have a different situation here. I am not trying to sort String but another object called AwardYearSource. This class has an int attribute called year. So I want to remove duplicates based on the year. i.e if there is year 2010 mentioned more than once, I want to remove that AwardYearSource object. How can I do that? \u2013 WowBow  Apr 16 '12 at 15:27 ", " @WowBow For example you can define Wrapper object which holds AwardYearSource. And define this Wrapper objects equals method based on AwardYearSources year field. Then you can use Set with these Wrapper objects. \u2013 Ondrej Bozek  Jun 20 '12 at 12:19 ", " @WowBow or implement Comparable/Comparator \u2013 shrini1000  Jan 11 '13 at 5:09 "], "answer_body": " Although converting the ArrayList to a HashSet effectively removes duplicates, if you need to preserve insertion order, I'd rather suggest you to use this variant  // list is some List of Strings\nSet<String> s = new LinkedHashSet<>(list);  Then, if you need to get back a List reference, you can use again the conversion constructor. ", "question_id": 203984}, "0.16995028"], [{"answer_votes": "824", "answer_comments": [" See also LinkedHashSet, if you wish to retain the order. \u2013 volley  Dec 9 '09 at 20:38 ", " But this will just create the set without duplicates , I want to know which number was duplicate in O(n) time \u2013 Chetan  Mar 29 '12 at 19:43 ", " @Chetan finding all duplicates from ArrayList in O(n), its important to have correctly defined equals method on objects which you have in the list (no problem for numbers): public Set<Object> findDuplicates(List<Object> list)       {           Set<Object> items = new HashSet<Object>();           Set<Object> duplicates = new HashSet<Object>();           for (Object item : list) {               if (items.contains(item)) {                   duplicates.add(item);               } else {                   items.add(item);               }           }           return duplicates;       } \u2013 Ondrej Bozek  Jun 20 '12 at 12:06  ", " A good practice would be to define variables using the interface types List and Set (instead of implementation types ArrayList and HashSet as in your example). \u2013 Jonik  Aug 29 '13 at 7:27 ", " You can clean this up by using new HashSet(al) instead of initializing it to empty and calling addAll . \u2013 ashes999  Dec 26 '13 at 12:44 "], "answer_body": " If you don't want duplicates in a Collection , you should consider why you're using a Collection that allows duplicates. The easiest way to remove repeated elements is to add the contents to a Set (which will not allow duplicates) and then add the Set back to the ArrayList :  List<String> al = new ArrayList<>();\n// add elements to al, including duplicates\nSet<String> hs = new HashSet<>();\nhs.addAll(al);\nal.clear();\nal.addAll(hs);  Of course, this destroys the ordering of the elements in the ArrayList . ", "question_id": 203984}, ""], [{"answer_votes": "83", "answer_comments": [" very elegant. Thanks \u2013 paskos  Feb 12 '15 at 20:04 ", " How do i do this for case insensitive distinct ? \u2013 StackFlowed  Sep 13 '16 at 20:04  ", " @StackFlowed If you don't need to preserve the order of the list you can addAll to new TreeSet<String>(String.CASE_INSENSITIVE_ORDER) .  The first element added will remain in the set so if your list contains \"Dog\" and \"dog\" (in that order) the TreeSet will contain \"Dog\". If order must be preserved then before the line in the answer put list.replaceAll(String::toUpperCase); . \u2013 Paul  Nov 3 '17 at 23:28  ", " I am getting this error :incompatible types: List<Object> cannot be converted to List<String> \u2013 Samir  Apr 4 at 14:34 "], "answer_body": " In Java 8:  List<String> deduped = list.stream().distinct().collect(Collectors.toList());  Please note that the hashCode-equals contract for list members should be respected for the filtering to work properly. ", "question_id": 203984}, ""], [{"answer_votes": "24", "answer_comments": [" This answer lacks two things: 1) It does not use generics, but raw types ( ArrayList<T> should be used instead of ArrayList ) 2) The explicit iterator creating can be avoided by using a for (T current : l1) { ... } . Even if you wanted to use an Iterator explicitly, iterador is misspelled. \u2013 RAnders00  Dec 7 '15 at 16:22 ", " And this implementation runs in quadratic time, compared to the linked hash set implementation running in linear time. (i.e. this takes 10 times longer on a list with 10 elements, 10,000 times longer on a list with 10,000 elements. JDK 6 implementation for ArrayList.contains , JDK8 impl is the same.) \u2013 Patrick M  Jul 11 '16 at 16:09 "], "answer_body": " Here's a way that doesn't affect your list ordering:  ArrayList l1 = new ArrayList();\nArrayList l2 = new ArrayList();\n\nIterator iterator = l1.iterator();\n\n        while (iterator.hasNext())\n        {\n            YourClass o = (YourClass) iterator.next();\n            if(!l2.contains(o)) l2.add(o);\n        }  l1 is the original list, and l2 is the list whithout repeated items\n(Make sure YourClass has the equals method acording to what you want to stand for equality) ", "question_id": 203984}, ""], [{"answer_votes": "24", "answer_comments": [" +1 for Java 8 streams. But if case-sensitivity is not required then only Java 8 solution can be easily modified. List<String> deDupStringList3 = stringList.parallelStream().map(String::toLowerCase).distinct().collect(Collectors.toList()); should work. \u2013 Diablo  Jun 10 '16 at 8:13 "], "answer_body": " Suppose we have a list of String like:  List<String> strList = new ArrayList<>(5);\n// insert up to five items to list.  Then we can remove duplicate elements in in multiple ways.  Prior to Java 8  List<String> deDupStringList = new ArrayList<>(new HashSet<>(strList));  Using Guava  List<String> deDupStringList2 = Lists.newArrayList(Sets.newHashSet(strList));  Using Java 8  List<String> deDupStringList3 = strList.stream().distinct().collect(Collectors.toList());  Note: If we want to maintain the insertion order then we need to use LinkedHashSet in place of HashSet . ", "question_id": 203984}, ""], [{"answer_votes": "19", "answer_comments": null, "answer_body": " Java 8 streams provide a very simple way to remove duplicate elements from a list. Using the distinct method.\nIf we have a list of cities and we want to remove duplicates from that list it can be done in a single line -  List<String> cityList = new ArrayList<>();\n cityList.add(\"Delhi\");\n cityList.add(\"Mumbai\");\n cityList.add(\"Bangalore\");\n cityList.add(\"Chennai\");\n cityList.add(\"Kolkata\");\n cityList.add(\"Mumbai\");\n\n cityList = cityList.stream().distinct().collect(Collectors.toList());  How to remove duplicate elements from an arraylist ", "question_id": 203984}, ""], [{"answer_votes": "19", "answer_comments": [" Note that there is an ImmutableSet.asList() method, returning an ImmutableList , if you need it back as a List . \u2013 Andy Turner  Oct 27 '17 at 19:25 "], "answer_body": " There is also ImmutableSet from Guava as an option ( here is the documentation):  ImmutableSet.copyOf(list); ", "question_id": 203984}, ""], [{"answer_votes": "18", "answer_comments": [" It's slow and you might get a ConcurrentModificationException. \u2013 maaartinus  Oct 18 '13 at 9:39 ", " @maaartinus Have you tried that code ?. It won't produce any exceptions.Also it is pretty fast. I tried the code before posting. \u2013 CarlJohn  Oct 18 '13 at 10:35  ", " You're right, it doesn't as you iterate the array instead of the list. However, it's slow like hell. Try it with a few millions elements. Compare it to ImmutableSet.copyOf(lst).toList() . \u2013 maaartinus  Oct 18 '13 at 10:49  ", " answers the question I was asked in the interview .. How to remove repeated values from an ArrayList without using Sets. Thanx \u2013 Aniket Paul  May 5 '16 at 9:10 ", " Internally, indexOf iterates the lst using a for loop. \u2013 Patrick M  Jul 11 '16 at 17:32 "], "answer_body": " It is possible to remove duplicates from arraylist without using HashSet or one more arraylist .  Try this code..  ArrayList<String> lst = new ArrayList<String>();\n    lst.add(\"ABC\");\n    lst.add(\"ABC\");\n    lst.add(\"ABCD\");\n    lst.add(\"ABCD\");\n    lst.add(\"ABCE\");\n\n    System.out.println(\"Duplicates List \"+lst);\n\n    Object[] st = lst.toArray();\n      for (Object s : st) {\n        if (lst.indexOf(s) != lst.lastIndexOf(s)) {\n            lst.remove(lst.lastIndexOf(s));\n         }\n      }\n\n    System.out.println(\"Distinct List \"+lst);  Output is  Duplicates List [ABC, ABC, ABCD, ABCD, ABCE]\nDistinct List [ABC, ABCD, ABCE] ", "question_id": 203984}, ""], [{"answer_votes": "14", "answer_comments": [" Works perfect.. Thanks for saving my head from loops :) :) \u2013 Sanoop  Dec 21 '16 at 11:17 "], "answer_body": " You can also do it this way, and preserve order:  // delete duplicates (if any) from 'myArrayList'\nmyArrayList = new ArrayList<String>(new LinkedHashSet<String>(myArrayList)); ", "question_id": 203984}, ""], [{"answer_votes": "10", "answer_comments": [" Why use ArrayList in parameter? Why not just List? Will that not work? \u2013 Shervin Asgari  Nov 12 '09 at 15:54 ", " A List will absolutely work as in-parameter for the first method listed. The method is however optimized for use with a random access list such as ArrayList, so if a LinkedList is passed instead you will get poor performance. For example, setting the n:th element in a LinkedList takes O(n) time, whereas setting the n:th element in a random access list (such as ArrayList) takes O(1) time. Again, though, this is probably overkill... If you need this kind of specialized code it will hopefully be in an isolated situation. \u2013 volley  Dec 9 '09 at 20:37 ", " This is precisely what I needed, thanks \u2013 Jasper Holton  Jun 1 '14 at 2:15 "], "answer_body": " Probably a bit overkill, but I enjoy this kind of isolated problem. :)  This code uses a temporary Set (for the uniqueness check) but removes elements directly inside the original list. Since element removal inside an ArrayList can induce a huge amount of array copying, the remove(int)-method is avoided.  public static <T> void removeDuplicates(ArrayList<T> list) {\n    int size = list.size();\n    int out = 0;\n    {\n        final Set<T> encountered = new HashSet<T>();\n        for (int in = 0; in < size; in++) {\n            final T t = list.get(in);\n            final boolean first = encountered.add(t);\n            if (first) {\n                list.set(out++, t);\n            }\n        }\n    }\n    while (out < size) {\n        list.remove(--size);\n    }\n}  While we're at it, here's a version for LinkedList (a lot nicer!):  public static <T> void removeDuplicates(LinkedList<T> list) {\n    final Set<T> encountered = new HashSet<T>();\n    for (Iterator<T> iter = list.iterator(); iter.hasNext(); ) {\n        final T t = iter.next();\n        final boolean first = encountered.add(t);\n        if (!first) {\n            iter.remove();\n        }\n    }\n}  Use the marker interface to present a unified solution for List:  public static <T> void removeDuplicates(List<T> list) {\n    if (list instanceof RandomAccess) {\n        // use first version here\n    } else {\n        // use other version here\n    }\n}  EDIT: I guess the generics-stuff doesn't really add any value here.. Oh well. :) ", "question_id": 203984}, ""], [{"answer_votes": "9", "answer_comments": [" I liked this solution better. \u2013 Tushar Gogna  Dec 5 '17 at 7:19 "], "answer_body": " this can solve the problem:  private List<SomeClass> clearListFromDuplicateFirstName(List<SomeClass> list1) {\n\nMap<String, SomeClass> cleanMap = new LinkedHashMap<String, SomeClass>();\nfor (int i = 0; i < list1.size(); i++) {\n     cleanMap.put(list1.get(i).getFirstName(), list1.get(i));\n}\nList<SomeClass> list = new ArrayList<SomeClass>(cleanMap.values());\nreturn list;\n} ", "question_id": 203984}, ""], [{"answer_votes": "8", "answer_comments": [" This implementation return no element in the list because of the last j-- \u2013 neo7  Sep 23 '15 at 9:29 ", " This implementation work's very fine.there is no issue behind this and for this task i am only use one arraylist.so this answer is completely good.before giving negative feedback you shold also add testcase also so that every one can understand the result.Thanks Manash \u2013 Manash Ranjan Dakua  Sep 24 '15 at 13:14 ", " This saved the day! \u2013 YehCheez  Mar 9 '16 at 16:09 "], "answer_body": " public static void main(String[] args){\n    ArrayList<Object> al = new ArrayList<Object>();\n    al.add(\"abc\");\n    al.add('a');\n    al.add('b');\n    al.add('a');\n    al.add(\"abc\");\n    al.add(10.3);\n    al.add('c');\n    al.add(10);\n    al.add(\"abc\");\n    al.add(10);\n    System.out.println(\"Before Duplicate Remove:\"+al);\n    for(int i=0;i<al.size();i++){\n        for(int j=i+1;j<al.size();j++){\n            if(al.get(i).equals(al.get(j))){\n                al.remove(j);\n                j--;\n            }\n        }\n    }\n    System.out.println(\"After Removing duplicate:\"+al);\n} ", "question_id": 203984}, ""], [{"answer_votes": "5", "answer_comments": null, "answer_body": " If you're willing to use a third-party library, you can use the method distinct() in Eclipse Collections (formerly GS Collections).  ListIterable<Integer> integers = FastList.newListWith(1, 3, 1, 2, 2, 1);\nAssert.assertEquals(\n    FastList.newListWith(1, 3, 2),\n    integers.distinct());  The advantage of using distinct() instead of converting to a Set and then back to a List is that distinct() preserves the order of the original List, retaining the first occurrence of each element. It's implemented by using both a Set and a List.  MutableSet<T> seenSoFar = UnifiedSet.newSet();\nint size = list.size();\nfor (int i = 0; i < size; i++)\n{\n    T item = list.get(i);\n    if (seenSoFar.add(item))\n    {\n        targetCollection.add(item);\n    }\n}\nreturn targetCollection;  If you cannot convert your original List into an Eclipse Collections type, you can use ListAdapter to get the same API.  MutableList<Integer> distinct = ListAdapter.adapt(integers).distinct();  Note: I am a committer for Eclipse Collections. ", "question_id": 203984}, ""], [{"answer_votes": "3", "answer_comments": null, "answer_body": " This three lines of code can remove the duplicated element from ArrayList or any collection.  List<Entity> entities = repository.findByUserId(userId);\n\nSet<Entity> s = new LinkedHashSet<Entity>(entities);\nentities.clear();\nentities.addAll(s); ", "question_id": 203984}, ""], [{"answer_votes": "2", "answer_comments": null, "answer_body": " When you are filling the ArrayList, use a condition for each element. For example:  ArrayList< Integer > al = new ArrayList< Integer >(); \n\n    // fill 1 \n    for ( int i = 0; i <= 5; i++ ) \n        if ( !al.contains( i ) ) \n            al.add( i ); \n\n    // fill 2 \n    for (int i = 0; i <= 10; i++ ) \n        if ( !al.contains( i ) ) \n            al.add( i ); \n\n    for( Integer i: al )\n    {\n        System.out.print( i + \" \");     \n    }  We will get an array {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10} ", "question_id": 203984}, ""], [{"answer_votes": "2", "answer_comments": null, "answer_body": " If you want to preserve your Order then it is best to use LinkedHashSet .\nBecause if you want to pass this List to an Insert Query by Iterating it, the order would be preserved.  Try this  LinkedHashSet link=new LinkedHashSet();\nList listOfValues=new ArrayList();\nlistOfValues.add(link);  This conversion will be very helpful when you want to return a List but not a Set. ", "question_id": 203984}, ""], [{"answer_votes": "2", "answer_comments": null, "answer_body": " Code:  List<String> duplicatList = new ArrayList<String>();\nduplicatList = Arrays.asList(\"AA\",\"BB\",\"CC\",\"DD\",\"DD\",\"EE\",\"AA\",\"FF\");\n//above AA and DD are duplicate\nSet<String> uniqueList = new HashSet<String>(duplicatList);\nduplicatList = new ArrayList<String>(uniqueList); //let GC will doing free memory\nSystem.out.println(\"Removed Duplicate : \"+duplicatList);  Note: Definitely, there will be memory overhead. ", "question_id": 203984}, ""], [{"answer_votes": "2", "answer_comments": null, "answer_body": " ArrayList<String> city=new ArrayList<String>();\ncity.add(\"rajkot\");\ncity.add(\"gondal\");\ncity.add(\"rajkot\");\ncity.add(\"gova\");\ncity.add(\"baroda\");\ncity.add(\"morbi\");\ncity.add(\"gova\");\n\nHashSet<String> hashSet = new HashSet<String>();\nhashSet.addAll(city);\ncity.clear();\ncity.addAll(hashSet);\nToast.makeText(getActivity(),\"\" + city.toString(),Toast.LENGTH_SHORT).show(); ", "question_id": 203984}, ""], [{"answer_votes": "1", "answer_comments": null, "answer_body": " As said before, you should use a class implementing Set interface instead of List to be sure of unicity of elements. If you have to keep the order of elements, the SortedSet interface can then be used ; the TreeSet class implements that interface. ", "question_id": 203984}, ""], [{"answer_votes": "1", "answer_comments": null, "answer_body": " LinkedHashSet will do the trick.  String[] arr2 = {\"5\",\"1\",\"2\",\"3\",\"3\",\"4\",\"1\",\"2\"};\nSet<String> set = new LinkedHashSet<String>(Arrays.asList(arr2));\nfor(String s1 : set)\n    System.out.println(s1);\n\nSystem.out.println( \"------------------------\" );\nString[] arr3 = set.toArray(new String[0]);\nfor(int i = 0; i < arr3.length; i++)\n     System.out.println(arr3[i].toString());  //output: 5,1,2,3,4 ", "question_id": 203984}, ""], [{"answer_votes": "1", "answer_comments": null, "answer_body": " List<String> result = new ArrayList<String>();\n        Set<String> set = new LinkedHashSet<String>();\n        String s = \"ravi is a good!boy. But ravi is very nasty fellow.\";\n        StringTokenizer st = new StringTokenizer(s, \" ,. ,!\");\n        while (st.hasMoreTokens()) {\n            result.add(st.nextToken());\n        }\n         System.out.println(result);\n         set.addAll(result);\n        result.clear();\n        result.addAll(set);\n        System.out.println(result);\n\noutput:\n[ravi, is, a, good, boy, But, ravi, is, very, nasty, fellow]\n[ravi, is, a, good, boy, But, very, nasty, fellow] ", "question_id": 203984}, ""], [{"answer_votes": "1", "answer_comments": [" This thread is years old... \u2013 WolfieeifloW  Nov 30 '17 at 18:43 "], "answer_body": " you can use nested loop in follow :  ArrayList<Class1> l1 = new ArrayList<Class1>();\nArrayList<Class1> l2 = new ArrayList<Class1>();\n\n        Iterator iterator1 = l1.iterator();\n        boolean repeated = false;\n\n        while (iterator1.hasNext())\n        {\n            Class1 c1 = (Class1) iterator1.next();\n            for (Class1 _c: l2) {\n                if(_c.getId() == c1.getId())\n                    repeated = true;\n            }\n            if(!repeated)\n                l2.add(c1);\n        } ", "question_id": 203984}, ""], [{"answer_votes": "0", "answer_comments": null, "answer_body": " for(int a=0;a<myArray.size();a++){\n        for(int b=a+1;b<myArray.size();b++){\n            if(myArray.get(a).equalsIgnoreCase(myArray.get(b))){\n                myArray.remove(b); \n                dups++;\n                b--;\n            }\n        }\n} ", "question_id": 203984}, ""], [{"answer_votes": "0", "answer_comments": null, "answer_body": " import java.util.*;\nclass RemoveDupFrmString\n{\n    public static void main(String[] args)\n    {\n\n        String s=\"appsc\";\n\n        Set<Character> unique = new LinkedHashSet<Character> ();\n\n        for(char c : s.toCharArray()) {\n\n            System.out.println(unique.add(c));\n        }\n        for(char dis:unique){\n            System.out.println(dis);\n        }\n\n\n    }\n} ", "question_id": 203984}, ""], [{"answer_votes": "0", "answer_comments": null, "answer_body": " public Set<Object> findDuplicates(List<Object> list) {\n        Set<Object> items = new HashSet<Object>();\n        Set<Object> duplicates = new HashSet<Object>();\n        for (Object item : list) {\n            if (items.contains(item)) {\n                duplicates.add(item);\n                } else { \n                    items.add(item);\n                    } \n            } \n        return duplicates;\n        } ", "question_id": 203984}, ""], [{"answer_votes": "0", "answer_comments": null, "answer_body": " ArrayList<String> list = new ArrayList<String>();\n    HashSet<String> unique = new LinkedHashSet<String>();\n    HashSet<String> dup = new LinkedHashSet<String>();\n    boolean b = false;\n    list.add(\"Hello\");\n    list.add(\"Hello\");\n    list.add(\"how\");\n    list.add(\"are\");\n    list.add(\"u\");\n    list.add(\"u\");\n\n    for(Iterator iterator= list.iterator();iterator.hasNext();)\n    {\n        String value = (String)iterator.next();\n        System.out.println(value);\n\n        if(b==unique.add(value))\n            dup.add(value);\n        else\n            unique.add(value);\n\n\n    }\n    System.out.println(unique);\n    System.out.println(dup); ", "question_id": 203984}, ""], [{"answer_votes": "0", "answer_comments": [" Why would you post a quadratic solution to a question that already has 2-year-old linear and log-linear solutions, that are also simpler? \u2013 abarnert  Sep 11 '14 at 7:40 "], "answer_body": " If you want to remove duplicates from ArrayList means find the below logic,  public static Object[] removeDuplicate(Object[] inputArray)\n{\n    long startTime = System.nanoTime();\n    int totalSize = inputArray.length;\n    Object[] resultArray = new Object[totalSize];\n    int newSize = 0;\n    for(int i=0; i<totalSize; i++)\n    {\n        Object value = inputArray[i];\n        if(value == null)\n        {\n            continue;\n        }\n\n        for(int j=i+1; j<totalSize; j++)\n        {\n            if(value.equals(inputArray[j]))\n            {\n                inputArray[j] = null;\n            }\n        }\n        resultArray[newSize++] = value;\n    }\n\n    long endTime = System.nanoTime()-startTime;\n    System.out.println(\"Total Time-B:\"+endTime);\n    return resultArray;\n} ", "question_id": 203984}, ""], [{"answer_votes": "0", "answer_comments": null, "answer_body": " The @jonathan-stafford solution is OK. But this don't preserve the list order.  If you want preserve the list order you have to use this:  public static <T> void removeDuplicate(List <T> list) {\nSet <T> set = new HashSet <T>();\nList <T> newList = new ArrayList <T>();\nfor (Iterator <T>iter = list.iterator();    iter.hasNext(); ) {\n   Object element = iter.next();\n   if (set.add((T) element))\n      newList.add((T) element);\n   }\n   list.clear();\n   list.addAll(newList);\n}  It's only to complete the answer. Very good! ", "question_id": 203984}, ""], [{"answer_votes": "0", "answer_comments": null, "answer_body": " Here is my answer without using any other data structure like set or hashmap etc.  public static <T> ArrayList<T> uniquefy(ArrayList<T> myList) {\n\n    ArrayList <T> uniqueArrayList = new ArrayList<T>();\n    for (int i = 0; i < myList.size(); i++){\n        if (!uniqueArrayList.contains(myList.get(i))){\n            uniqueArrayList.add(myList.get(i));\n        }\n    }\n\n    return uniqueArrayList;\n} ", "question_id": 203984}, ""], [{"answer_votes": "0", "answer_comments": null, "answer_body": " Would something like this work better ?  public static void removeDuplicates(ArrayList<String> list) {\nArraylist<Object> ar     = new Arraylist<Object>();\nArraylist<Object> tempAR = new Arraylist<Object>();\nwhile (list.size()>0){\n    ar.add(list(0));\n    list.removeall(Collections.singleton(list(0)));\n}\nlist.addAll(ar);  }  That should maintain the order and also not be quadratic in run time. ", "question_id": 203984}, ""], [{"answer_votes": "0", "answer_comments": null, "answer_body": " This is used for your Custom Objects list  public List<Contact> removeDuplicates(List<Contact> list) {\n    // Set set1 = new LinkedHashSet(list);\n    Set set = new TreeSet(new Comparator() {\n\n        @Override\n        public int compare(Object o1, Object o2) {\n            if (((Contact) o1).getId().equalsIgnoreCase(((Contact) o2).getId()) /*&&\n                    ((Contact)o1).getName().equalsIgnoreCase(((Contact)o2).getName())*/) {\n                return 0;\n            }\n            return 1;\n        }\n    });\n    set.addAll(list);\n\n    final List newList = new ArrayList(set);\n    return newList;\n} ", "question_id": 203984}, ""], [{"answer_votes": "0", "answer_comments": null, "answer_body": " If you are using model type List< T>/ArrayList< T> . Hope,it's help you.   Here is my code without using any other data structure like set or hashmap  for(int i = 0; i < Models.size(); i++) {\n     for(int j = i + 1; j < Models.size(); j++) {                                \n       if(Models.get(i).getName().equals(Models.get(j).getName())){    \n                                Models.remove(j);\n\n                                j--;\n                            }\n                        }\n                    } ", "question_id": 203984}, ""], [{"answer_votes": "-1", "answer_comments": null, "answer_body": " In Java, List permits ordered access of their elements. They can have duplicates because their lookup key is the position not some hash code, every element can be modified while they remain in the list where as Set represents a collection of unique elements and while elements are in set, they must not be modified.While there is no restriction preventing you from modifying elements in a set, if an element is modified, then it could become forever lost in the set.  public static void main(String[] args) {  \n           List<String> l = new ArrayList<String>();  \n           l.add(\"A\");  \n           l.add(\"B\");  \n           l.add(\"C\");  \n           l.add(\"A\");  \n           System.out.println(\"Before removing duplicates: \");  \n           for (String s : l) {  \n                System.out.println(s);  \n           }  \n           Set<String> set = new HashSet<String>(l);  \n           List<String> newlist = new ArrayList<String>(set);  \n           System.out.println(\"after removing duplicates: \");  \n           for (String s : newlist) {  \n                System.out.println(s);  \n           }  \n      }  for reference , refer this link How to remove duplicates from ArrayList  ", "question_id": 203984}, ""]], "question": {"question_title": "How do I remove repeated elements from ArrayList?", "question_code": ["ArrayList", "Strings"], "question_body": " I have an of , and I want to remove repeated strings from it. How can I do this? "}, "time_now": "2018-05-10 17:55:39", "nltk_title_analyze_title_result": [[{"answer_votes": "5", "answer_comments": null, "answer_body": " If you're willing to use a third-party library, you can use the method distinct() in Eclipse Collections (formerly GS Collections).  ListIterable<Integer> integers = FastList.newListWith(1, 3, 1, 2, 2, 1);\nAssert.assertEquals(\n    FastList.newListWith(1, 3, 2),\n    integers.distinct());  The advantage of using distinct() instead of converting to a Set and then back to a List is that distinct() preserves the order of the original List, retaining the first occurrence of each element. It's implemented by using both a Set and a List.  MutableSet<T> seenSoFar = UnifiedSet.newSet();\nint size = list.size();\nfor (int i = 0; i < size; i++)\n{\n    T item = list.get(i);\n    if (seenSoFar.add(item))\n    {\n        targetCollection.add(item);\n    }\n}\nreturn targetCollection;  If you cannot convert your original List into an Eclipse Collections type, you can use ListAdapter to get the same API.  MutableList<Integer> distinct = ListAdapter.adapt(integers).distinct();  Note: I am a committer for Eclipse Collections. ", "question_id": 203984}, 33], [{"answer_votes": "1", "answer_comments": null, "answer_body": " List<String> result = new ArrayList<String>();\n        Set<String> set = new LinkedHashSet<String>();\n        String s = \"ravi is a good!boy. But ravi is very nasty fellow.\";\n        StringTokenizer st = new StringTokenizer(s, \" ,. ,!\");\n        while (st.hasMoreTokens()) {\n            result.add(st.nextToken());\n        }\n         System.out.println(result);\n         set.addAll(result);\n        result.clear();\n        result.addAll(set);\n        System.out.println(result);\n\noutput:\n[ravi, is, a, good, boy, But, ravi, is, very, nasty, fellow]\n[ravi, is, a, good, boy, But, very, nasty, fellow] ", "question_id": 203984}, 24], [{"answer_votes": "10", "answer_comments": [" Why use ArrayList in parameter? Why not just List? Will that not work? \u2013 Shervin Asgari  Nov 12 '09 at 15:54 ", " A List will absolutely work as in-parameter for the first method listed. The method is however optimized for use with a random access list such as ArrayList, so if a LinkedList is passed instead you will get poor performance. For example, setting the n:th element in a LinkedList takes O(n) time, whereas setting the n:th element in a random access list (such as ArrayList) takes O(1) time. Again, though, this is probably overkill... If you need this kind of specialized code it will hopefully be in an isolated situation. \u2013 volley  Dec 9 '09 at 20:37 ", " This is precisely what I needed, thanks \u2013 Jasper Holton  Jun 1 '14 at 2:15 "], "answer_body": " Probably a bit overkill, but I enjoy this kind of isolated problem. :)  This code uses a temporary Set (for the uniqueness check) but removes elements directly inside the original list. Since element removal inside an ArrayList can induce a huge amount of array copying, the remove(int)-method is avoided.  public static <T> void removeDuplicates(ArrayList<T> list) {\n    int size = list.size();\n    int out = 0;\n    {\n        final Set<T> encountered = new HashSet<T>();\n        for (int in = 0; in < size; in++) {\n            final T t = list.get(in);\n            final boolean first = encountered.add(t);\n            if (first) {\n                list.set(out++, t);\n            }\n        }\n    }\n    while (out < size) {\n        list.remove(--size);\n    }\n}  While we're at it, here's a version for LinkedList (a lot nicer!):  public static <T> void removeDuplicates(LinkedList<T> list) {\n    final Set<T> encountered = new HashSet<T>();\n    for (Iterator<T> iter = list.iterator(); iter.hasNext(); ) {\n        final T t = iter.next();\n        final boolean first = encountered.add(t);\n        if (!first) {\n            iter.remove();\n        }\n    }\n}  Use the marker interface to present a unified solution for List:  public static <T> void removeDuplicates(List<T> list) {\n    if (list instanceof RandomAccess) {\n        // use first version here\n    } else {\n        // use other version here\n    }\n}  EDIT: I guess the generics-stuff doesn't really add any value here.. Oh well. :) ", "question_id": 203984}, 22], [{"answer_votes": "-1", "answer_comments": null, "answer_body": " In Java, List permits ordered access of their elements. They can have duplicates because their lookup key is the position not some hash code, every element can be modified while they remain in the list where as Set represents a collection of unique elements and while elements are in set, they must not be modified.While there is no restriction preventing you from modifying elements in a set, if an element is modified, then it could become forever lost in the set.  public static void main(String[] args) {  \n           List<String> l = new ArrayList<String>();  \n           l.add(\"A\");  \n           l.add(\"B\");  \n           l.add(\"C\");  \n           l.add(\"A\");  \n           System.out.println(\"Before removing duplicates: \");  \n           for (String s : l) {  \n                System.out.println(s);  \n           }  \n           Set<String> set = new HashSet<String>(l);  \n           List<String> newlist = new ArrayList<String>(set);  \n           System.out.println(\"after removing duplicates: \");  \n           for (String s : newlist) {  \n                System.out.println(s);  \n           }  \n      }  for reference , refer this link How to remove duplicates from ArrayList  ", "question_id": 203984}, 22], [{"answer_votes": "19", "answer_comments": null, "answer_body": " Java 8 streams provide a very simple way to remove duplicate elements from a list. Using the distinct method.\nIf we have a list of cities and we want to remove duplicates from that list it can be done in a single line -  List<String> cityList = new ArrayList<>();\n cityList.add(\"Delhi\");\n cityList.add(\"Mumbai\");\n cityList.add(\"Bangalore\");\n cityList.add(\"Chennai\");\n cityList.add(\"Kolkata\");\n cityList.add(\"Mumbai\");\n\n cityList = cityList.stream().distinct().collect(Collectors.toList());  How to remove duplicate elements from an arraylist ", "question_id": 203984}, 19], [{"answer_votes": "824", "answer_comments": [" See also LinkedHashSet, if you wish to retain the order. \u2013 volley  Dec 9 '09 at 20:38 ", " But this will just create the set without duplicates , I want to know which number was duplicate in O(n) time \u2013 Chetan  Mar 29 '12 at 19:43 ", " @Chetan finding all duplicates from ArrayList in O(n), its important to have correctly defined equals method on objects which you have in the list (no problem for numbers): public Set<Object> findDuplicates(List<Object> list)       {           Set<Object> items = new HashSet<Object>();           Set<Object> duplicates = new HashSet<Object>();           for (Object item : list) {               if (items.contains(item)) {                   duplicates.add(item);               } else {                   items.add(item);               }           }           return duplicates;       } \u2013 Ondrej Bozek  Jun 20 '12 at 12:06  ", " A good practice would be to define variables using the interface types List and Set (instead of implementation types ArrayList and HashSet as in your example). \u2013 Jonik  Aug 29 '13 at 7:27 ", " You can clean this up by using new HashSet(al) instead of initializing it to empty and calling addAll . \u2013 ashes999  Dec 26 '13 at 12:44 "], "answer_body": " If you don't want duplicates in a Collection , you should consider why you're using a Collection that allows duplicates. The easiest way to remove repeated elements is to add the contents to a Set (which will not allow duplicates) and then add the Set back to the ArrayList :  List<String> al = new ArrayList<>();\n// add elements to al, including duplicates\nSet<String> hs = new HashSet<>();\nhs.addAll(al);\nal.clear();\nal.addAll(hs);  Of course, this destroys the ordering of the elements in the ArrayList . ", "question_id": 203984}, 17], [{"answer_votes": "2", "answer_comments": null, "answer_body": " If you want to preserve your Order then it is best to use LinkedHashSet .\nBecause if you want to pass this List to an Insert Query by Iterating it, the order would be preserved.  Try this  LinkedHashSet link=new LinkedHashSet();\nList listOfValues=new ArrayList();\nlistOfValues.add(link);  This conversion will be very helpful when you want to return a List but not a Set. ", "question_id": 203984}, 17], [{"answer_votes": "258", "answer_comments": [" Does LinkedHashSet make any guarantees as to which of several duplicates are kept from the list?  For instance, if position 1, 3, and 5 are duplicates in the original list, can we assume that this process will remove 3 and 5?  Or maybe remove 1 and 3?  Thanks. \u2013 Matt Brian\u00e7on  May 1 '11 at 2:20 ", " @Matt: yes, it does guarantee that. The docs say: \"This linked list defines the iteration ordering, which is the order in which elements were inserted into the set (insertion-order). Note that insertion order is not affected if an element is re-inserted into the set.\" \u2013 abahgat  May 2 '11 at 9:00 ", " Very interesting. I have a different situation here. I am not trying to sort String but another object called AwardYearSource. This class has an int attribute called year. So I want to remove duplicates based on the year. i.e if there is year 2010 mentioned more than once, I want to remove that AwardYearSource object. How can I do that? \u2013 WowBow  Apr 16 '12 at 15:27 ", " @WowBow For example you can define Wrapper object which holds AwardYearSource. And define this Wrapper objects equals method based on AwardYearSources year field. Then you can use Set with these Wrapper objects. \u2013 Ondrej Bozek  Jun 20 '12 at 12:19 ", " @WowBow or implement Comparable/Comparator \u2013 shrini1000  Jan 11 '13 at 5:09 "], "answer_body": " Although converting the ArrayList to a HashSet effectively removes duplicates, if you need to preserve insertion order, I'd rather suggest you to use this variant  // list is some List of Strings\nSet<String> s = new LinkedHashSet<>(list);  Then, if you need to get back a List reference, you can use again the conversion constructor. ", "question_id": 203984}, 15], [{"answer_votes": "24", "answer_comments": [" +1 for Java 8 streams. But if case-sensitivity is not required then only Java 8 solution can be easily modified. List<String> deDupStringList3 = stringList.parallelStream().map(String::toLowerCase).distinct().collect(Collectors.toList()); should work. \u2013 Diablo  Jun 10 '16 at 8:13 "], "answer_body": " Suppose we have a list of String like:  List<String> strList = new ArrayList<>(5);\n// insert up to five items to list.  Then we can remove duplicate elements in in multiple ways.  Prior to Java 8  List<String> deDupStringList = new ArrayList<>(new HashSet<>(strList));  Using Guava  List<String> deDupStringList2 = Lists.newArrayList(Sets.newHashSet(strList));  Using Java 8  List<String> deDupStringList3 = strList.stream().distinct().collect(Collectors.toList());  Note: If we want to maintain the insertion order then we need to use LinkedHashSet in place of HashSet . ", "question_id": 203984}, 14], [{"answer_votes": "2", "answer_comments": null, "answer_body": " When you are filling the ArrayList, use a condition for each element. For example:  ArrayList< Integer > al = new ArrayList< Integer >(); \n\n    // fill 1 \n    for ( int i = 0; i <= 5; i++ ) \n        if ( !al.contains( i ) ) \n            al.add( i ); \n\n    // fill 2 \n    for (int i = 0; i <= 10; i++ ) \n        if ( !al.contains( i ) ) \n            al.add( i ); \n\n    for( Integer i: al )\n    {\n        System.out.print( i + \" \");     \n    }  We will get an array {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10} ", "question_id": 203984}, 13], [{"answer_votes": "1", "answer_comments": null, "answer_body": " As said before, you should use a class implementing Set interface instead of List to be sure of unicity of elements. If you have to keep the order of elements, the SortedSet interface can then be used ; the TreeSet class implements that interface. ", "question_id": 203984}, 12], [{"answer_votes": "48", "answer_comments": [" Similarly at the bottom of the thread, I have given an answer where I am using Set for Custom Object. In a case if anyone have custom object like \"Contact\" or \"Student\" can use that answer that works fine for me. \u2013 Muhammad Adil  Oct 25 '16 at 14:16 "], "answer_body": " If you don't want duplicates, use a Set instead of a List . To convert a List to a Set you can use the following code:  // list is some List of Strings\nSet<String> s = new HashSet<String>(list);  If really necessary you can use the same construction to convert a Set back into a List . ", "question_id": 203984}, 11], [{"answer_votes": "18", "answer_comments": [" It's slow and you might get a ConcurrentModificationException. \u2013 maaartinus  Oct 18 '13 at 9:39 ", " @maaartinus Have you tried that code ?. It won't produce any exceptions.Also it is pretty fast. I tried the code before posting. \u2013 CarlJohn  Oct 18 '13 at 10:35  ", " You're right, it doesn't as you iterate the array instead of the list. However, it's slow like hell. Try it with a few millions elements. Compare it to ImmutableSet.copyOf(lst).toList() . \u2013 maaartinus  Oct 18 '13 at 10:49  ", " answers the question I was asked in the interview .. How to remove repeated values from an ArrayList without using Sets. Thanx \u2013 Aniket Paul  May 5 '16 at 9:10 ", " Internally, indexOf iterates the lst using a for loop. \u2013 Patrick M  Jul 11 '16 at 17:32 "], "answer_body": " It is possible to remove duplicates from arraylist without using HashSet or one more arraylist .  Try this code..  ArrayList<String> lst = new ArrayList<String>();\n    lst.add(\"ABC\");\n    lst.add(\"ABC\");\n    lst.add(\"ABCD\");\n    lst.add(\"ABCD\");\n    lst.add(\"ABCE\");\n\n    System.out.println(\"Duplicates List \"+lst);\n\n    Object[] st = lst.toArray();\n      for (Object s : st) {\n        if (lst.indexOf(s) != lst.lastIndexOf(s)) {\n            lst.remove(lst.lastIndexOf(s));\n         }\n      }\n\n    System.out.println(\"Distinct List \"+lst);  Output is  Duplicates List [ABC, ABC, ABCD, ABCD, ABCE]\nDistinct List [ABC, ABCD, ABCE] ", "question_id": 203984}, 11], [{"answer_votes": "2", "answer_comments": null, "answer_body": " Code:  List<String> duplicatList = new ArrayList<String>();\nduplicatList = Arrays.asList(\"AA\",\"BB\",\"CC\",\"DD\",\"DD\",\"EE\",\"AA\",\"FF\");\n//above AA and DD are duplicate\nSet<String> uniqueList = new HashSet<String>(duplicatList);\nduplicatList = new ArrayList<String>(uniqueList); //let GC will doing free memory\nSystem.out.println(\"Removed Duplicate : \"+duplicatList);  Note: Definitely, there will be memory overhead. ", "question_id": 203984}, 10], [{"answer_votes": "0", "answer_comments": null, "answer_body": " The @jonathan-stafford solution is OK. But this don't preserve the list order.  If you want preserve the list order you have to use this:  public static <T> void removeDuplicate(List <T> list) {\nSet <T> set = new HashSet <T>();\nList <T> newList = new ArrayList <T>();\nfor (Iterator <T>iter = list.iterator();    iter.hasNext(); ) {\n   Object element = iter.next();\n   if (set.add((T) element))\n      newList.add((T) element);\n   }\n   list.clear();\n   list.addAll(newList);\n}  It's only to complete the answer. Very good! ", "question_id": 203984}, 10], [{"answer_votes": "1", "answer_comments": null, "answer_body": " LinkedHashSet will do the trick.  String[] arr2 = {\"5\",\"1\",\"2\",\"3\",\"3\",\"4\",\"1\",\"2\"};\nSet<String> set = new LinkedHashSet<String>(Arrays.asList(arr2));\nfor(String s1 : set)\n    System.out.println(s1);\n\nSystem.out.println( \"------------------------\" );\nString[] arr3 = set.toArray(new String[0]);\nfor(int i = 0; i < arr3.length; i++)\n     System.out.println(arr3[i].toString());  //output: 5,1,2,3,4 ", "question_id": 203984}, 9], [{"answer_votes": "14", "answer_comments": [" Works perfect.. Thanks for saving my head from loops :) :) \u2013 Sanoop  Dec 21 '16 at 11:17 "], "answer_body": " You can also do it this way, and preserve order:  // delete duplicates (if any) from 'myArrayList'\nmyArrayList = new ArrayList<String>(new LinkedHashSet<String>(myArrayList)); ", "question_id": 203984}, 7], [{"answer_votes": "24", "answer_comments": [" This answer lacks two things: 1) It does not use generics, but raw types ( ArrayList<T> should be used instead of ArrayList ) 2) The explicit iterator creating can be avoided by using a for (T current : l1) { ... } . Even if you wanted to use an Iterator explicitly, iterador is misspelled. \u2013 RAnders00  Dec 7 '15 at 16:22 ", " And this implementation runs in quadratic time, compared to the linked hash set implementation running in linear time. (i.e. this takes 10 times longer on a list with 10 elements, 10,000 times longer on a list with 10,000 elements. JDK 6 implementation for ArrayList.contains , JDK8 impl is the same.) \u2013 Patrick M  Jul 11 '16 at 16:09 "], "answer_body": " Here's a way that doesn't affect your list ordering:  ArrayList l1 = new ArrayList();\nArrayList l2 = new ArrayList();\n\nIterator iterator = l1.iterator();\n\n        while (iterator.hasNext())\n        {\n            YourClass o = (YourClass) iterator.next();\n            if(!l2.contains(o)) l2.add(o);\n        }  l1 is the original list, and l2 is the list whithout repeated items\n(Make sure YourClass has the equals method acording to what you want to stand for equality) ", "question_id": 203984}, 6], [{"answer_votes": "9", "answer_comments": [" I liked this solution better. \u2013 Tushar Gogna  Dec 5 '17 at 7:19 "], "answer_body": " this can solve the problem:  private List<SomeClass> clearListFromDuplicateFirstName(List<SomeClass> list1) {\n\nMap<String, SomeClass> cleanMap = new LinkedHashMap<String, SomeClass>();\nfor (int i = 0; i < list1.size(); i++) {\n     cleanMap.put(list1.get(i).getFirstName(), list1.get(i));\n}\nList<SomeClass> list = new ArrayList<SomeClass>(cleanMap.values());\nreturn list;\n} ", "question_id": 203984}, 5], [{"answer_votes": "3", "answer_comments": null, "answer_body": " This three lines of code can remove the duplicated element from ArrayList or any collection.  List<Entity> entities = repository.findByUserId(userId);\n\nSet<Entity> s = new LinkedHashSet<Entity>(entities);\nentities.clear();\nentities.addAll(s); ", "question_id": 203984}, 5], [{"answer_votes": "0", "answer_comments": [" Why would you post a quadratic solution to a question that already has 2-year-old linear and log-linear solutions, that are also simpler? \u2013 abarnert  Sep 11 '14 at 7:40 "], "answer_body": " If you want to remove duplicates from ArrayList means find the below logic,  public static Object[] removeDuplicate(Object[] inputArray)\n{\n    long startTime = System.nanoTime();\n    int totalSize = inputArray.length;\n    Object[] resultArray = new Object[totalSize];\n    int newSize = 0;\n    for(int i=0; i<totalSize; i++)\n    {\n        Object value = inputArray[i];\n        if(value == null)\n        {\n            continue;\n        }\n\n        for(int j=i+1; j<totalSize; j++)\n        {\n            if(value.equals(inputArray[j]))\n            {\n                inputArray[j] = null;\n            }\n        }\n        resultArray[newSize++] = value;\n    }\n\n    long endTime = System.nanoTime()-startTime;\n    System.out.println(\"Total Time-B:\"+endTime);\n    return resultArray;\n} ", "question_id": 203984}, 5], [{"answer_votes": "1", "answer_comments": [" This thread is years old... \u2013 WolfieeifloW  Nov 30 '17 at 18:43 "], "answer_body": " you can use nested loop in follow :  ArrayList<Class1> l1 = new ArrayList<Class1>();\nArrayList<Class1> l2 = new ArrayList<Class1>();\n\n        Iterator iterator1 = l1.iterator();\n        boolean repeated = false;\n\n        while (iterator1.hasNext())\n        {\n            Class1 c1 = (Class1) iterator1.next();\n            for (Class1 _c: l2) {\n                if(_c.getId() == c1.getId())\n                    repeated = true;\n            }\n            if(!repeated)\n                l2.add(c1);\n        } ", "question_id": 203984}, 4], [{"answer_votes": "0", "answer_comments": null, "answer_body": " Would something like this work better ?  public static void removeDuplicates(ArrayList<String> list) {\nArraylist<Object> ar     = new Arraylist<Object>();\nArraylist<Object> tempAR = new Arraylist<Object>();\nwhile (list.size()>0){\n    ar.add(list(0));\n    list.removeall(Collections.singleton(list(0)));\n}\nlist.addAll(ar);  }  That should maintain the order and also not be quadratic in run time. ", "question_id": 203984}, 4], [{"answer_votes": "0", "answer_comments": null, "answer_body": " If you are using model type List< T>/ArrayList< T> . Hope,it's help you.   Here is my code without using any other data structure like set or hashmap  for(int i = 0; i < Models.size(); i++) {\n     for(int j = i + 1; j < Models.size(); j++) {                                \n       if(Models.get(i).getName().equals(Models.get(j).getName())){    \n                                Models.remove(j);\n\n                                j--;\n                            }\n                        }\n                    } ", "question_id": 203984}, 4], [{"answer_votes": "83", "answer_comments": [" very elegant. Thanks \u2013 paskos  Feb 12 '15 at 20:04 ", " How do i do this for case insensitive distinct ? \u2013 StackFlowed  Sep 13 '16 at 20:04  ", " @StackFlowed If you don't need to preserve the order of the list you can addAll to new TreeSet<String>(String.CASE_INSENSITIVE_ORDER) .  The first element added will remain in the set so if your list contains \"Dog\" and \"dog\" (in that order) the TreeSet will contain \"Dog\". If order must be preserved then before the line in the answer put list.replaceAll(String::toUpperCase); . \u2013 Paul  Nov 3 '17 at 23:28  ", " I am getting this error :incompatible types: List<Object> cannot be converted to List<String> \u2013 Samir  Apr 4 at 14:34 "], "answer_body": " In Java 8:  List<String> deduped = list.stream().distinct().collect(Collectors.toList());  Please note that the hashCode-equals contract for list members should be respected for the filtering to work properly. ", "question_id": 203984}, 2], [{"answer_votes": "19", "answer_comments": [" Note that there is an ImmutableSet.asList() method, returning an ImmutableList , if you need it back as a List . \u2013 Andy Turner  Oct 27 '17 at 19:25 "], "answer_body": " There is also ImmutableSet from Guava as an option ( here is the documentation):  ImmutableSet.copyOf(list); ", "question_id": 203984}, 2], [{"answer_votes": "2", "answer_comments": null, "answer_body": " ArrayList<String> city=new ArrayList<String>();\ncity.add(\"rajkot\");\ncity.add(\"gondal\");\ncity.add(\"rajkot\");\ncity.add(\"gova\");\ncity.add(\"baroda\");\ncity.add(\"morbi\");\ncity.add(\"gova\");\n\nHashSet<String> hashSet = new HashSet<String>();\nhashSet.addAll(city);\ncity.clear();\ncity.addAll(hashSet);\nToast.makeText(getActivity(),\"\" + city.toString(),Toast.LENGTH_SHORT).show(); ", "question_id": 203984}, 2], [{"answer_votes": "0", "answer_comments": null, "answer_body": " import java.util.*;\nclass RemoveDupFrmString\n{\n    public static void main(String[] args)\n    {\n\n        String s=\"appsc\";\n\n        Set<Character> unique = new LinkedHashSet<Character> ();\n\n        for(char c : s.toCharArray()) {\n\n            System.out.println(unique.add(c));\n        }\n        for(char dis:unique){\n            System.out.println(dis);\n        }\n\n\n    }\n} ", "question_id": 203984}, 1], [{"answer_votes": "0", "answer_comments": null, "answer_body": " Here is my answer without using any other data structure like set or hashmap etc.  public static <T> ArrayList<T> uniquefy(ArrayList<T> myList) {\n\n    ArrayList <T> uniqueArrayList = new ArrayList<T>();\n    for (int i = 0; i < myList.size(); i++){\n        if (!uniqueArrayList.contains(myList.get(i))){\n            uniqueArrayList.add(myList.get(i));\n        }\n    }\n\n    return uniqueArrayList;\n} ", "question_id": 203984}, 1], [{"answer_votes": "0", "answer_comments": null, "answer_body": " This is used for your Custom Objects list  public List<Contact> removeDuplicates(List<Contact> list) {\n    // Set set1 = new LinkedHashSet(list);\n    Set set = new TreeSet(new Comparator() {\n\n        @Override\n        public int compare(Object o1, Object o2) {\n            if (((Contact) o1).getId().equalsIgnoreCase(((Contact) o2).getId()) /*&&\n                    ((Contact)o1).getName().equalsIgnoreCase(((Contact)o2).getName())*/) {\n                return 0;\n            }\n            return 1;\n        }\n    });\n    set.addAll(list);\n\n    final List newList = new ArrayList(set);\n    return newList;\n} ", "question_id": 203984}, 1], [{"answer_votes": "8", "answer_comments": [" This implementation return no element in the list because of the last j-- \u2013 neo7  Sep 23 '15 at 9:29 ", " This implementation work's very fine.there is no issue behind this and for this task i am only use one arraylist.so this answer is completely good.before giving negative feedback you shold also add testcase also so that every one can understand the result.Thanks Manash \u2013 Manash Ranjan Dakua  Sep 24 '15 at 13:14 ", " This saved the day! \u2013 YehCheez  Mar 9 '16 at 16:09 "], "answer_body": " public static void main(String[] args){\n    ArrayList<Object> al = new ArrayList<Object>();\n    al.add(\"abc\");\n    al.add('a');\n    al.add('b');\n    al.add('a');\n    al.add(\"abc\");\n    al.add(10.3);\n    al.add('c');\n    al.add(10);\n    al.add(\"abc\");\n    al.add(10);\n    System.out.println(\"Before Duplicate Remove:\"+al);\n    for(int i=0;i<al.size();i++){\n        for(int j=i+1;j<al.size();j++){\n            if(al.get(i).equals(al.get(j))){\n                al.remove(j);\n                j--;\n            }\n        }\n    }\n    System.out.println(\"After Removing duplicate:\"+al);\n} ", "question_id": 203984}, 0], [{"answer_votes": "0", "answer_comments": null, "answer_body": " for(int a=0;a<myArray.size();a++){\n        for(int b=a+1;b<myArray.size();b++){\n            if(myArray.get(a).equalsIgnoreCase(myArray.get(b))){\n                myArray.remove(b); \n                dups++;\n                b--;\n            }\n        }\n} ", "question_id": 203984}, 0], [{"answer_votes": "0", "answer_comments": null, "answer_body": " public Set<Object> findDuplicates(List<Object> list) {\n        Set<Object> items = new HashSet<Object>();\n        Set<Object> duplicates = new HashSet<Object>();\n        for (Object item : list) {\n            if (items.contains(item)) {\n                duplicates.add(item);\n                } else { \n                    items.add(item);\n                    } \n            } \n        return duplicates;\n        } ", "question_id": 203984}, 0], [{"answer_votes": "0", "answer_comments": null, "answer_body": " ArrayList<String> list = new ArrayList<String>();\n    HashSet<String> unique = new LinkedHashSet<String>();\n    HashSet<String> dup = new LinkedHashSet<String>();\n    boolean b = false;\n    list.add(\"Hello\");\n    list.add(\"Hello\");\n    list.add(\"how\");\n    list.add(\"are\");\n    list.add(\"u\");\n    list.add(\"u\");\n\n    for(Iterator iterator= list.iterator();iterator.hasNext();)\n    {\n        String value = (String)iterator.next();\n        System.out.println(value);\n\n        if(b==unique.add(value))\n            dup.add(value);\n        else\n            unique.add(value);\n\n\n    }\n    System.out.println(unique);\n    System.out.println(dup); ", "question_id": 203984}, 0]], "question_id": 203984}