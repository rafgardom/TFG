{"question_comments": [" There's a bug in your code: Tomato is a fruit. \u2013 Olle H\u00e4rstedt  Mar 2 '16 at 14:19 ", " This method has caveats, but often I just do , which is simple and fast. Of course, you should first be sure the array isn't empty, and you should have some knowledge on the possible contents of the array so that the method couldn't fail (like mixed numeric/associative, or non-sequential). \u2013 Gras Double  Mar 12 '16 at 17:58  ", " @Gras Double great, simple idea for most cases.  Thanks. \u2013 user949300  Sep 26 '16 at 4:55 ", " function isIndexed($someArray) { $keys=array_keys($someArray); return array_keys($keys)===array_values($keys); }[] \u2013 Radacina  Oct 13 '16 at 14:14  "], "question_title": "How to check if PHP array is associative or sequential?", "answers": [{"answer_votes": "477", "answer_comments": [" Very elegant solution. Note that it returns TRUE in the (ambiguous) case of an empty array. \u2013 Jonathan Lidbeck  Jan 8 '16 at 0:09 ", " I think it is more useful to think of sequential arrays as a special case of associative arrays. So every array is associative, but only some are sequential. Therefore, a function isSequential() would make more sense than isAssoc() . In such a function, the empty array should be seen as sequential. The formula could be array() === $arr || !isAssoc($arr) . \u2013 donquixote  Feb 21 '16 at 2:03 ", " I think this would avoid a lot of potential cpu time and memory if one would check if isset($arr[0]) is false before extracting all the keys as is it clearly associative if the array is not empty but has no element in 0 position. As \"most\" real associative arrays have strings as keys this should be a nice optimisation for the general case of such function. \u2013 OderWat  May 24 '17 at 23:57 ", " Then change the return statement to return sort(array_keys($arr)) !== range(0, count($arr) - 1); \u2013 Greg Borbonus  Jul 3 '17 at 16:06  ", " @OderWat - Your optimization should use array_key_exists instead of isset because if the zero element is a null value, the isset will return false incorrectly. A null value should ordinarily be a legitimate value in such an array. \u2013 OCDev  Sep 3 '17 at 19:55 "], "answer_body": " You have asked two questions that are not quite equivalent:   Firstly, how to determine whether an array has only numeric keys  Secondly, how to determine whether an array has sequential numeric keys, starting from 0   Consider which of these behaviours you actually need. (It may be that either will do for your purposes.)  The first question (simply checking that all keys are numeric) is answered well by Captain kurO .  For the second question (checking whether the array is zero-indexed and sequential), you can use the following function:  function isAssoc(array $arr)\n{\n    if (array() === $arr) return false;\n    return array_keys($arr) !== range(0, count($arr) - 1);\n}\n\nvar_dump(isAssoc(array('a', 'b', 'c'))); // false\nvar_dump(isAssoc(array(\"0\" => 'a', \"1\" => 'b', \"2\" => 'c'))); // false\nvar_dump(isAssoc(array(\"1\" => 'a', \"0\" => 'b', \"2\" => 'c'))); // true\nvar_dump(isAssoc(array(\"a\" => 'a', \"b\" => 'b', \"c\" => 'c'))); // true ", "question_id": 173400}, {"answer_votes": "377", "answer_comments": [" This method is much better than it seems. If count(filtered_array) == count(original_array), then it is an assoc array. If count(filtered_array) == 0, then it is an indexed array. If count(filtered_array) < count(original_array), then the array has both numeric and string keys. \u2013 Jamol  Jan 31 '12 at 13:31 ", " Way to slow. This will iterate and apply a function. Look below for faster alternatives or simply check the first key for being int. \u2013 LeMike  Jan 18 '14 at 19:27 ", " @MikePretzlaw of course it iterates; there is (obviously) no possible way to determine whether all the keys of the array are ints without looking at all the keys in the array. I assume the non-iterating alternatives we're supposed to be seeing below are ones like $isIndexed = array_values($arr) === $arr; ? To which I ask: how do you think array_values() works? How do you think === applied to arrays works? The answer is of course that they also iterate over the array. \u2013 Mark Amery  Dec 25 '15 at 16:25 ", " @ARW \"PHP seems to cast everything to an int in an array definition if it can.\" - yep, that's exactly what happens. The biggest WTF is that it even does this to floats; if you try var_dump([1.2 => 'foo', 1.5 => 'bar']); you'll discover that you get the array [1 => 'bar'] . There's no way whatsoever to find out a key's original type. Yes, all this is awful; PHP's arrays are by far the worst part of the language, and most of the damage is irreparable and owes to the idea of using a single construct for traditional arrays and traditional hashmaps being an awful one from the beginning. \u2013 Mark Amery  Dec 25 '15 at 16:35  ", " @MarkAmery The above, while simple, guarantees a 100% walk of the array.  It would be more efficient, especially if you're dealing with large arrays, if you were checking for string or int and broke out on the first you found.  For instance: function isAssociative($arr) { foreach ($arr as $key => $value) { if (is_string($key)) return true; } return false; } \u2013 Thought  Feb 18 '16 at 17:27  "], "answer_body": " To merely check whether the array has non-integer keys (not whether the array is sequentially-indexed or zero-indexed):  function has_string_keys(array $array) {\n  return count(array_filter(array_keys($array), 'is_string')) > 0;\n}  If there is at least one string key, $array will be regarded as an associative array. ", "question_id": 173400}, {"answer_votes": "120", "answer_comments": [" This will duplicate the values in the array, which is potentially very expensive. You're much better off examining the array keys. \u2013 meagar \u2666  Jan 20 '11 at 15:47  ", " I just used ==; I don't think there is a need for === here.  But to answer the \"unset and it doesn't work\": once you unset the first element, it's no longer an integer-indexed array starting at 0.  So IMO it does work. \u2013 grantwparks  Aug 2 '12 at 21:32 ", " Agree with @grantwparks: A sparse array isn't indexed. Interestingly because there's no way to actually delete an element out of the middle of an indexed array PHP is basically declaring all arrays as associative and numeric is just a 'make up the key for me' version. \u2013 RickMeasham  Jan 14 '13 at 1:01 ", " The only problem I have with this is that the === will waste time checking if the values are equal, even though we are only interested in the keys.  For this reason I prefer the $k = array_keys( $arr ); return $k === array_keys( $k ); version. \u2013 Jesse  Jan 20 '13 at 7:05  ", " An added note, this fails on arrays specified with numeric keys that are out of order. e.g. $myArr = array ( 0 => 'a', 3 => 'b', 4 => 1, 2 => 2, 1 => '3' ); One potential work around is running ksort($arr) before doing the test \u2013 Scott  Jun 5 '13 at 21:58  "], "answer_body": " Surely this is a better alternative.  <?php\n$arr = array(1,2,3,4);\n$isIndexed = array_values($arr) === $arr; ", "question_id": 173400}, {"answer_votes": "71", "answer_comments": [" This doesn't work for non-sequential integer keys.  Try it with [2 => 'a', 4 => 'b']. \u2013 DavidJ  Sep 4 '12 at 12:29 ", " @DavidJ, What do you mean by \"doesn't work\"? It successfully determines that all the keys are integers. Are you claiming that an array like the one you posted shouldn't be considered a \"numeric array\"? \u2013 CoreDumpError  Mar 16 '13 at 0:29 ", " A non-associative array must have keys ranging from 0 to count($array)-1 , in this strict order. A preliminary check with is_array() may help. Add an increasing variable to check the key sequence: for ($k = 0, reset($array) ; $k === key($array) ; next($array)) ++$k; That settles the deal. \u2013 ofavre  Jun 25 '13 at 15:52  ", " Using foreach instead of explicit iteration is about twice faster. \u2013 ofavre  Jun 26 '13 at 9:06 ", " If you want to make this into a function: function isAssocStr($array) {     \tfor (reset($array); is_int(key($array)); next($array)) {     \t\tif (is_null(key($array))) return false;     \t}     \treturn true;     } \u2013 GreeKatrina  Feb 18 '15 at 17:15  "], "answer_body": " Many commenters in this question don't understand how arrays work in PHP. From the array documentation :   A key may be either an integer or a string. If a key is the standard representation of an integer, it will be interpreted as such (i.e. \"8\" will be interpreted as 8, while \"08\" will be interpreted as \"08\"). Floats in key are truncated to integer. The indexed and associative array types are the same type in PHP, which can both contain integer and string indices.   In other words, there is no such thing as an array key of \"8\" because it will always be (silently) converted to the integer 8. So trying to differentiate between integers and numeric strings is unnecessary.  If you want the most efficient way to check an array for non-integer keys without making a copy of part of the array (like array_keys() does) or all of it (like foreach does):  for (reset($my_array); is_int(key($my_array)); next($my_array));\n$onlyIntKeys = is_null(key($my_array));  This works because key() returns NULL when the current array position is invalid and NULL can never be a valid key (if you try to use NULL as an array key it gets silently converted to \"\"). ", "question_id": 173400}, {"answer_votes": "35", "answer_comments": [" Except, as I mention below, it involves creating a duplicate array to the one being checked, making it very expensive for large arrays, and a potential source of out of memory crashes on shared hosts. \u2013 podperson  Jun 2 '15 at 15:48  "], "answer_body": " As stated by the OP :   PHP treats all arrays as associative   it is not quite sensible (IMHO) to write a function that checks if an array is associative . So first thing first: what is a key in a PHP array ?:   The key can either be an integer or a string .   That means there are 3 possible cases:   Case 1. all keys are numeric / integers .  Case 2. all keys are strings .  Case 3. some keys are strings , some keys are numeric / integers .   We can check each case with the following functions.  Case 1: all keys are numeric / integers .  Note : This function returns true for empty arrays too.  //! Check whether the input is an array whose keys are all integers.\n/*!\n    \\param[in] $InputArray          (array) Input array.\n    \\return                         (bool) \\b true iff the input is an array whose keys are all integers.\n*/\nfunction IsArrayAllKeyInt($InputArray)\n{\n    if(!is_array($InputArray))\n    {\n        return false;\n    }\n\n    if(count($InputArray) <= 0)\n    {\n        return true;\n    }\n\n    return array_unique(array_map(\"is_int\", array_keys($InputArray))) === array(true);\n}  Case 2: all keys are strings .  Note : This function returns true for empty arrays too.  //! Check whether the input is an array whose keys are all strings.\n/*!\n    \\param[in] $InputArray          (array) Input array.\n    \\return                         (bool) \\b true iff the input is an array whose keys are all strings.\n*/\nfunction IsArrayAllKeyString($InputArray)\n{\n    if(!is_array($InputArray))\n    {\n        return false;\n    }\n\n    if(count($InputArray) <= 0)\n    {\n        return true;\n    }\n\n    return array_unique(array_map(\"is_string\", array_keys($InputArray))) === array(true);\n}  Case 3. some keys are strings , some keys are numeric / integers .  Note : This function returns true for empty arrays too.  //! Check whether the input is an array with at least one key being an integer and at least one key being a string.\n/*!\n    \\param[in] $InputArray          (array) Input array.\n    \\return                         (bool) \\b true iff the input is an array with at least one key being an integer and at least one key being a string.\n*/\nfunction IsArraySomeKeyIntAndSomeKeyString($InputArray)\n{\n    if(!is_array($InputArray))\n    {\n        return false;\n    }\n\n    if(count($InputArray) <= 0)\n    {\n        return true;\n    }\n\n    return count(array_unique(array_map(\"is_string\", array_keys($InputArray)))) >= 2;\n}  It follows that:   If the value is not an array , all 3 functions return false .  If the value is an empty array , all 3 functions return true (which is by definition, as in \" the empty set is a subset of any set A because all its elements belong to A \").  If the value is a non-empty array , exactly 1 function returns true .    Now, for an array to be a \"genuine\" array that we are all accustomed to, meaning:   Its keys are all numeric / integers .  Its keys are sequential (i.e. increasing by step 1).  Its keys start from zero .   We can check with the following function.  Case 3a. keys are numeric / integers , sequential , and zero-based .  Note : This function returns true for empty arrays too.  //! Check whether the input is an array whose keys are numeric, sequential, and zero-based.\n/*!\n    \\param[in] $InputArray          (array) Input array.\n    \\return                         (bool) \\b true iff the input is an array whose keys are numeric, sequential, and zero-based.\n*/\nfunction IsArrayKeyNumericSequentialZeroBased($InputArray)\n{\n    if(!is_array($InputArray))\n    {\n        return false;\n    }\n\n    if(count($InputArray) <= 0)\n    {\n        return true;\n    }\n\n    return array_keys($InputArray) === range(0, count($InputArray) - 1);\n}  Caveats / Pitfalls (or, even more peculiar facts about array keys in PHP)  Integer keys  The keys for these arrays are integers :  array(0 => \"b\");\narray(13 => \"b\");\narray(-13 => \"b\");          // Negative integers are also integers.\narray(0x1A => \"b\");         // Hexadecimal notation.  String keys  The keys for these arrays are strings :  array(\"fish and chips\" => \"b\");\narray(\"\" => \"b\");                                   // An empty string is also a string.\narray(\"stackoverflow_email@example.com\" => \"b\");    // Strings may contain non-alphanumeric characters.\narray(\"stack\\t\\\"over\\\"\\r\\nflow's cool\" => \"b\");     // Strings may contain special characters.\narray('$t\u03b1\u20ack\u2194\u00f8v\u2208rfl\u00f6w\u26c4' => \"b\");                    // Strings may contain all kinds of symbols.\narray(\"funct\u0456on\" => \"b\");                           // You think this looks fine? Think again! (see https://stackoverflow.com/q/9246051/1402846)\narray(\"\u307e\ub9d0\u8f49\u8f6c\u0414\u0141\" => \"b\");                         // How about Japanese/Korean/Chinese/Russian/Polish?\narray(\"fi\\x0sh\" => \"b\");                            // Strings may contain null characters.\narray(file_get_contents(\"https://www.google.com/images/nav_logo114.png\") => \"b\");   // Strings may even be binary!  Integer keys that look like strings  If you think the key in array(\"13\" => \"b\") is a string , you are wrong . From the doc here :   Strings containing valid integers will be cast to the integer type. E.g. the key \"8\" will actually be stored under 8. On the other hand \"08\" will not be cast, as it isn't a valid decimal integer.   For example, the key for these arrays are integers :  array(\"13\" => \"b\");\narray(\"-13\" => \"b\");                        // Negative, ok.  But the key for these arrays are strings :  array(\"13.\" => \"b\");\narray(\"+13\" => \"b\");                        // Positive, not ok.\narray(\"-013\" => \"b\");\narray(\"0x1A\" => \"b\");                       // Not converted to integers even though it's a valid hexadecimal number.\narray(\"013\" => \"b\");                        // Not converted to integers even though it's a valid octal number.\narray(\"18446744073709551616\" => \"b\");       // Not converted to integers as it can't fit into a 64-bit integer.  What's more, according to the doc ,   The size of an integer is platform-dependent, although a maximum value of about two billion is the usual value (that's 32 bits signed). 64-bit platforms usually have a maximum value of about 9E18, except for Windows, which is always 32 bit. PHP does not support unsigned integers.   So the key for this array may or may not be an integer - it depends on your platform.  array(\"60000000000\" => \"b\");                // Array key could be integer or string, it can fit into a 64-bit (but not 32-bit) integer.  Even worse, PHP tends to be buggy if the integer is near the 2 31 = 2,147,483,648 boundary (see bug 51430 , bug 52899 ). For example, on my local environment (PHP 5.3.8 on XAMPP 1.7.7 on Windows 7), var_dump(array(\"2147483647\" => \"b\")) gives  array(1) {\n    [2147483647]=>\n    string(1) \"b\"\n}  but on this live demo on codepad (PHP 5.2.5), the same expression gives  array(1) {\n    [\"2147483647\"]=>\n    string(1) \"b\"\n}  So the key is an integer in one environment but a string in another, even though 2147483647 is a valid signed 32-bit integer . ", "question_id": 173400}, {"answer_votes": "30", "answer_comments": [" Here is a performance benchmark for the above: gist.github.com/1965669 \u2013 Artur Bodera  Mar 3 '12 at 13:44  ", " the following array: array(02=>11,1,2,456); is shown as not having numerical keys using the above algorithm, even if 02===2 \u2013 Galileo_Galilei  Nov 18 '15 at 9:50 "], "answer_body": " Speed-wise:  function isAssoc($array)\n{\n    return ($array !== array_values($array));\n}  Memory-wise:  function isAssoc($array)\n{\n    $array = array_keys($array); return ($array !== array_keys($array));\n} ", "question_id": 173400}, {"answer_votes": "19", "answer_comments": [" This is the only answer (at the time of my comment) that can deal with the following: $array = array(0=>'blah', 2=>'yep', 3=>'wahey') \u2013 Shabbyrobe  Aug 3 '10 at 11:01 ", " Does that work if one of the keys is the empty string? \u2013 Donal Fellows  Feb 9 '11 at 13:30 ", " but array('1'=>'asdf', '2'=>'too') will be regarded as associative array while it's actually not (the keys are actually string) \u2013 Captain kurO  Apr 14 '11 at 7:41 ", " @CaptainkurO You mean numerical. It is an associative array. \u2013 devios1  Feb 21 '12 at 16:51 ", " This function returns true if the keys are: zero, integers (positive only), an empty string, or any combination of the above, such as the string \"09\". This function does not take the order of the keys into account. So array(0=>'blah', 2=>'yep', 3=>'wahey') , array(0=>'blah', 2=>'yep', 1=>'wahey') and array('blah', 'yep', 'wahey') are all associative according to this function, while array('a'=>'blah', 'b'=>'yep', 'c'=>'wahey') is not. \u2013 Pang  Nov 23 '12 at 1:23 "], "answer_body": " function checkAssoc($array){\n    return  ctype_digit( implode('', array_keys($array) ) );\n} ", "question_id": 173400}, {"answer_votes": "17", "answer_comments": [" Clever, but not good. Why is this \"most efficient\"? It would be a lot more readable to just compare the array_keys($a) to range(0, count($a)).    The most clever solution is rarely the best one in my experience. Especially when being clever adds literally no value over the obvious and clean alternative. \u2013 Shane H  Jul 31 '12 at 1:45 ", " This function returns true for array(1=>\"a\") but false for array(\"a\"=>\"a\") . Would be more meaningful if != is replaced by !== . \u2013 Pang  Nov 23 '12 at 1:38  ", " @Pang you are correct. I thought your comment must surely be wrong at first, but, to my surprise, [0] == ['a'] in PHP (since 0 == 'a' , and, indeed, 0 == 'banana' ). PHP's == operator is insane. \u2013 Mark Amery  Jan 1 '16 at 23:59  ", " It's not efficient insofar as it involves calling array_keys vs. just checking until you find a non-sequential integer index. Under the hood you're doing that anyway , but you already duplicated a big array. \u2013 podperson  Mar 21 '17 at 21:50  "], "answer_body": " Actually the most efficient way is thus:  function is_assoc($array){\n   $keys = array_keys($array);\n   return $keys !== array_keys($keys);\n}  This works because it compares the keys (which for a sequential array are always 0,1,2 etc) to the keys of the keys (which will always be 0,1,2 etc). ", "question_id": 173400}, {"answer_votes": "16", "answer_comments": null, "answer_body": " I've used both array_keys($obj) !== range(0, count($obj) - 1) and array_values($arr) !== $arr (which are duals of each other, although the second is cheaper than the first) but both fail for very large arrays.  This is because array_keys and array_values are both very costly operations (since they build a whole new array of size roughly that of the original).  The following function is more robust than the methods provided above:  function array_type( $obj ){\n    $last_key = -1;\n    $type = 'index';\n    foreach( $obj as $key => $val ){\n        if( !is_int( $key ) || $key < 0 ){\n            return 'assoc';\n        }\n        if( $key !== $last_key + 1 ){\n            $type = 'sparse';\n        }\n        $last_key = $key;\n    }\n    return $type;\n}  Also note that if you don't care to differentiate sparse arrays from associative arrays you can simply return 'assoc' from both if blocks.  Finally, while this might seem much less \"elegant\" than a lot of \"solutions\" on this page, in practice it is vastly more efficient. Almost any associative array will be detected instantly. Only indexed arrays will get checked exhaustively, and the methods outlined above not only check indexed arrays exhaustively, they duplicate them. ", "question_id": 173400}, {"answer_votes": "13", "answer_comments": [" This is the best answer. The definition of \"associative\" or \"numeric\" array depends on the specific situation. \u2013 Pato  May 2 '13 at 18:38 "], "answer_body": " I think the following two functions are the best way to go for checking 'if an array is associative or numeric'. Since 'numeric' could mean only numeric keys or only sequential numeric keys, two functions are listed below that check either condition:  function is_indexed_array(&$arr) {\n  for (reset($arr); is_int(key($arr)); next($arr));\n  return is_null(key($arr));\n}\n\nfunction is_sequential_array(&$arr, $base = 0) {\n  for (reset($arr), $base = (int) $base; key($arr) === $base++; next($arr));\n  return is_null(key($arr));\n}  The first function checks if each key is an integer value. The second function checks if each key is an integer value and in addition checks if all keys are sequential starting at $base, which defaults to 0 and thus can be omitted if you do not need to specify another base value. key($my_array) returns null if the read pointer is moved past the end of the array, which is what ends the for loop and makes the statement after the for loop return true if all keys were integer. If not, the loop ends prematurely because a key is of type string, and the statement after the for loop will return false. The latter function in addition adds one to $base after each compare, to be able to check if the next key is of the correct value. The strict compare makes it also check if the key is of type integer. The $base = (int) $base part in the first section of the for loop can be left out when $base is omitted or if you make sure it is only called using an integer. But since I can't be sure for everybody, I left it in. The statement is executed only once, anyway. I think these are the most efficient solutions:   Memory wise: No copying of data or key ranges. Doing an array_values or array_keys may seem shorter (less code) but keep in mind what goes on in the background once you make that call. Yes there are more (visible) statements than in some other solutions, but that is not what counts, is it?  Time wise: Besides the fact that copying/extracting data and/or keys also takes time, this solution is more efficient than doing a foreach. Again a foreach may seem more efficient to some because it is shorter in notation, but in the background foreach also calls reset, key and next to do it's looping. But in addition it also calls valid to check the end condition, which is avoided here due to the combination with the integer check.   Remember that an array key can only be an integer or a string, and a strictly numeric string such as \"1\" (but not \"01\") will be translated into an integer. Which is what makes checking for an integer key the only needed operation besides counting if you want the array to be sequential. Naturally, if is_indexed_array returns false the array can be seen as associative. I say 'seen', because in fact they all are. ", "question_id": 173400}, {"answer_votes": "7", "answer_comments": [" \"if one of the keys is NOT an integer, it is associative array, otherwise it's sequential\" - huh? No, this is simply wrong. There's room for argument over what constitutes an \"associative\" array, but the meaning of \"sequential\" is pretty unambiguous, and it's not the same as all keys being numbers. \u2013 Mark Amery  Jan 2 '16 at 16:39 "], "answer_body": " This function can handle:   array with holes in index (e.g. 1,2,4,5,8,10)  array with \"0x\" keys: e.g. key '08' is associative while key '8' is sequential.   the idea is simple: if one of the keys is NOT an integer, it is associative array, otherwise it's sequential.  function is_asso($a){\n    foreach(array_keys($a) as $key) {if (!is_int($key)) return TRUE;}\n    return FALSE;\n} ", "question_id": 173400}, {"answer_votes": "7", "answer_comments": [" bad benchmark. You didn't test for big arrays. On my computer starting at 10K+ elements method #2 is faster. Try with $arrays = Array(   'Array #1' => range(0, 50000), ); \u2013 nonsensei  Jul 4 '16 at 11:07  ", " @nonsensei Share your findings / benchmark results \u2013 Manu M.  Jul 6 '16 at 4:56 ", " I did. stackoverflow.com/a/38183890/4805056 \u2013 nonsensei  Jul 6 '16 at 7:15  "], "answer_body": " I noticed two popular approaches for this question: one using array_values() and other using key() . To find out which is faster, I wrote a small program:  $arrays = Array(\n  'Array #1' => Array(1, 2, 3, 54, 23, 212, 123, 1, 1),\n  'Array #2' => Array(\"Stack\", 1.5, 20, Array(3.4)),\n  'Array #3' => Array(1 => 4, 2 => 2),\n  'Array #4' => Array(3.0, \"2\", 3000, \"Stack\", 5 => \"4\"),\n  'Array #5' => Array(\"3\" => 4, \"2\" => 2),\n  'Array #6' => Array(\"0\" => \"One\", 1.0 => \"Two\", 2 => \"Three\"),\n  'Array #7' => Array(3 => \"asdf\", 4 => \"asdf\"),\n  'Array #8' => Array(\"apple\" => 1, \"orange\" => 2),\n);\n\nfunction is_indexed_array_1(Array &$arr) {\n  return $arr === array_values($arr);\n}\n\nfunction is_indexed_array_2(Array &$arr) {\n  for (reset($arr), $i = 0; key($arr) === $i++; next($arr))\n    ;\n  return is_null(key($arr));\n}\n\n// Method #1\n$start = microtime(true);\nfor ($i = 0; $i < 1000; $i++) {\n  foreach ($arrays as $array) {\n    $dummy = is_indexed_array_1($array);\n  }\n}\n$end = microtime(true);\necho \"Time taken with method #1 = \".round(($end-$start)*1000.0,3).\"ms\\n\";\n\n// Method #2\n$start = microtime(true);\nfor ($i = 0; $i < 1000; $i++) {\n  foreach ($arrays as $array) {\n    $dummy = is_indexed_array_2($array);\n  }\n}\n$end = microtime(true);\necho \"Time taken with method #1 = \".round(($end-$start)*1000.0,3).\"ms\\n\";  Output for the program on PHP 5.2 on CentOS is as follows:   Time taken with method #1 = 10.745ms Time taken with method #2 = 18.239ms   Output on PHP 5.3 yielded similar results. Obviously using array_values() is much faster. ", "question_id": 173400}, {"answer_votes": "3", "answer_comments": [" Normally just assuming the array is the desired type would be the way to go. But in my case I'm looping through a multidimensional array and am formatting the output depending on which type of array a given node is. \u2013 Wilco  Oct 6 '08 at 7:24 "], "answer_body": " Unless PHP has a builtin for that, you won't be able to do it in less than O(n) - enumerating over all the keys and checking for integer type. In fact, you also want to make sure there are no holes, so your algorithm might look like:  for i in 0 to len(your_array):\n    if not defined(your-array[i]):\n        # this is not an array array, it's an associative array :)  But why bother? Just assume the array is of the type you expect. If it isn't, it will just blow up in your face - that's dynamic programming for you! Test your code and all will be well... ", "question_id": 173400}, {"answer_votes": "3", "answer_comments": null, "answer_body": " This would work too ( demo ):  function array_has_numeric_keys_only(array $array)\n{\n    try {\n        SplFixedArray::fromArray($array, true);\n    } catch (InvalidArgumentException $e) {\n        return false;\n    }\n    return true;\n}  Please note that the main point of this answer is to inform you about the existence of SplFixedArray and not to encourage you to use Exceptions for these kinds of tests. ", "question_id": 173400}, {"answer_votes": "3", "answer_comments": null, "answer_body": " By using xarray PHP extension  You can do this very fast (about 30+ times faster in PHP 5.6):  if (array_is_indexed($array)) {  }  Or:  if (array_is_assoc($array)) {  } ", "question_id": 173400}, {"answer_votes": "3", "answer_comments": [" -1; this is O(n) in additional memory used (since it created multiple new arrays with as many elements as $array ), the answer doesn't address the ambiguity of the question that was asked nor explain exactly how it's defining a list / non-associative array, and even if neither of these points were true it's unclear that this adds any value compared to other answers already posted. \u2013 Mark Amery  Jan 6 '16 at 23:46 "], "answer_body": " My solution:  function isAssociative(array $array)\n{\n    return array_keys(array_merge($array)) !== range(0, count($array) - 1);\n}  array_merge on a single array will reindex all integer keys, but not other. For example:  array_merge([1 => 'One', 3 => 'Three', 'two' => 'Two', 6 => 'Six']);\n\n// This will returns [0 => 'One', 1 => 'Three', 'two' => 'Two', 2 => 'Six']  So if a list (a non-associative array) is created ['a', 'b', 'c'] then a value is removed unset($a[1]) then array_merge is called, the list is reindexed starting from 0. ", "question_id": 173400}, {"answer_votes": "3", "answer_comments": null, "answer_body": " function array_is_assoc(array $a) {\n    $i = 0;\n    foreach ($a as $k => $v) {\n        if ($k !== $i++) {\n            return true;\n        }\n    }\n    return false;\n}  Fast, concise, and memory efficient. No expensive comparisons, function calls or array copying. ", "question_id": 173400}, {"answer_votes": "3", "answer_comments": [" more compact eval: array_keys(array_keys($array)) !== array_keys($array); \u2013 Data Mafia LLC  Apr 27 '17 at 3:39 ", " @Data Mafia LLC Really? You're calling array_keys 3 times there instead of 2.  For what benefit? You can put the return statement on the same line as the assignment if you really hate taking up lines in a file!  Not only that but most language parsers optimise like crazy... does PHP's? I have no idea: above all I don't care. \u2013 mike rodent  Nov 21 '17 at 17:50 ", " Why does this work? \u2013 Casey  Mar 6 at 18:43 "], "answer_body": " There are many answers already, but here is the method that Laravel relies on within its Arr class:  /**\n * Determines if an array is associative.\n *\n * An array is \"associative\" if it doesn't have sequential numerical keys beginning with zero.\n *\n * @param  array  $array\n * @return bool\n */\npublic static function isAssoc(array $array)\n{\n    $keys = array_keys($array);\n\n    return array_keys($keys) !== $keys;\n}  Source: https://github.com/laravel/framework/blob/5.4/src/Illuminate/Support/Arr.php ", "question_id": 173400}, {"answer_votes": "2", "answer_comments": null, "answer_body": " Here's the method I use:  function is_associative ( $a )\n{\n    return in_array(false, array_map('is_numeric', array_keys($a)));\n}\n\nassert( true === is_associative(array(1, 2, 3, 4)) );\n\nassert( false === is_associative(array('foo' => 'bar', 'bar' => 'baz')) );\n\nassert( false === is_associative(array(1, 2, 3, 'foo' => 'bar')) );  Note that this doesn't account for special cases like:  $a = array( 1, 2, 3, 4 );\n\nunset($a[1]);\n\nassert( true === is_associative($a) );  Sorry, can't help you with that. It's also somewhat performant for decently sized arrays, as it doesn't make needless copies. It is these little things that makes Python and Ruby so much nicer to write in... :P ", "question_id": 173400}, {"answer_votes": "2", "answer_comments": [" +1 Your is_list() is IMO the best answer. Some people don't have a clue about time & space complexity, and native vs PHP scripted function... \u2013 Ring \u00d8  Nov 16 '12 at 15:00  "], "answer_body": " <?php\n\nfunction is_list($array) {\n    return array_keys($array) === range(0, count($array) - 1);\n}\n\nfunction is_assoc($array) {\n    return count(array_filter(array_keys($array), 'is_string')) == count($array);\n}\n\n?>  Both of these examples, which scored the most points do not work correctly with arrays like $array = array('foo' => 'bar', 1) ", "question_id": 173400}, {"answer_votes": "2", "answer_comments": null, "answer_body": " I think the definition of a scalar array will vary by application.  That is, some applications will require a more strict sense of what qualifies as a scalar array, and some applications will require a more loose sense.  Below I present 3 methods of varying strictness.  <?php\n/**\n * Since PHP stores all arrays as associative internally, there is no proper\n * definition of a scalar array.\n * \n * As such, developers are likely to have varying definitions of scalar array,\n * based on their application needs.\n * \n * In this file, I present 3 increasingly strict methods of determining if an\n * array is scalar.\n * \n * @author David Farrell <DavidPFarrell@gmail.com>\n */\n\n/**\n * isArrayWithOnlyIntKeys defines a scalar array as containing\n * only integer keys.\n * \n * If you are explicitly setting integer keys on an array, you\n * may need this function to determine scalar-ness.\n * \n * @param array $a\n * @return boolean\n */ \nfunction isArrayWithOnlyIntKeys(array $a)\n{\n    if (!is_array($a))\n        return false;\n    foreach ($a as $k => $v)\n        if (!is_int($k))\n            return false;\n    return true;\n}\n\n/**\n * isArrayWithOnlyAscendingIntKeys defines a scalar array as\n * containing only integer keys in ascending (but not necessarily\n * sequential) order.\n * \n * If you are performing pushes, pops, and unsets on your array,\n * you may need this function to determine scalar-ness.\n * \n * @param array $a\n * @return boolean\n */ \nfunction isArrayWithOnlyAscendingIntKeys(array $a)\n{\n    if (!is_array($a))\n        return false;\n    $prev = null;\n    foreach ($a as $k => $v)\n    {\n        if (!is_int($k) || (null !== $prev && $k <= $prev))\n            return false;\n        $prev = $k;\n    }\n    return true;\n}\n\n/**\n * isArrayWithOnlyZeroBasedSequentialIntKeys defines a scalar array\n * as containing only integer keys in sequential, ascending order,\n * starting from 0.\n * \n * If you are only performing operations on your array that are\n * guaranteed to either maintain consistent key values, or that\n * re-base the keys for consistency, then you can use this function.\n * \n * @param array $a\n * @return boolean\n */\nfunction isArrayWithOnlyZeroBasedSequentialIntKeys(array $a)\n{\n    if (!is_array($a))\n        return false;\n    $i = 0;\n    foreach ($a as $k => $v)\n        if ($i++ !== $k)\n            return false;\n    return true;\n} ", "question_id": 173400}, {"answer_votes": "2", "answer_comments": [" This function returns false for both array(\"a\", \"b\") and array(\"a\", \"b\" => \"B\") as it only checks the first key. BTW, is_long is just an alias of is_int . \u2013 Pang  Nov 24 '12 at 2:20  ", " quite frankly I think this would be very effective in the vast majority of cases, and is far more efficient than the alternatives. If you understand the consequences of this method, and realize it will work for you, it's likely the best choice. \u2013 Gershom Maes  Jan 30 '15 at 19:58 ", " This is simply wrong; it only looks at the first key. \u2013 Mark Amery  Jan 2 '16 at 16:59 ", " @MarkAmery the question asked how to differentiate purely sequential arrays from purely associative arrays. This answer does exactly that and is the most efficient of them all. Having undefined behavior for mixed arrrays is perfectly fine in the context of the question. +1 \u2013 Tobia  Jul 20 '16 at 8:30 ", " @Tobia I don't think most people would agree with you classifying, say, [7 => 'foo', 2 => 'bar'] as a \"mixed\" array that is partly but not \"purely\" sequential. That seems like a plainly incorrect use of words to me. \u2013 Mark Amery  Jul 20 '16 at 8:57 "], "answer_body": " Could this be the solution?  public static function isArrayAssociative(array $array) {\n      reset($array);\n      return !is_int(key($array));\n  }  The caveat is obviously that the array cursor is reset but I'd say probably the function is used before the array is even traversed or used. ", "question_id": 173400}, {"answer_votes": "1", "answer_comments": [" one more point. array in form [1,2,null,4] will fail, but it is correct array. so i've added some enhancement at stackoverflow.com/a/25206156/501831 with addition array_key_exists check) \u2013 lazycommit  Aug 8 '14 at 18:14  ", " -1; isset() is the wrong tool here because it will return false if the value is set but is null , as pointed out by @lazycommit. \u2013 Mark Amery  Jan 2 '16 at 16:55 "], "answer_body": " I know it's a bit pointless adding an answer to this huge queue, but here's a readable O(n) solution that doesn't require duplicating any values:  function isNumericArray($array) {\n    $count = count($array);\n    for ($i = 0; $i < $count; $i++) {\n        if (!isset($array[$i])) {\n            return FALSE;\n        }\n    }\n    return TRUE;\n}  Rather than check the keys to see if they are all numeric, you iterate over the keys that would be there for a numeric array and make sure they exist. ", "question_id": 173400}, {"answer_votes": "1", "answer_comments": [" Why isset and array_key_exists ? wouldn't the latter be enough? \u2013 mcfedr  Jun 30 '15 at 21:33 ", " @mcfedr yes, it would - the isset() check here is completely redundant. \u2013 Mark Amery  Jan 2 '16 at 16:58 ", " @mcfedr, @mark-amery because of performance reasons. isset() is  faster than array_key_exists() . see ilia.ws/archives/\u2026 \u2013 lazycommit  Jan 29 '16 at 7:58 ", " @lazycommit Its going to depend on your array then on whether its better with or without, not that its likely to have an array with lots of null s, but then its also not that likely you have array large enough that there would be noticeable performance difference by using both checks \u2013 mcfedr  Jan 29 '16 at 8:25 ", " if you need to check if it would fit json_encode , you could simply check the first symbol of the string, returned by json_encode($your_arr) -- whether it's [ or { ;-) \u2013 pilat  Mar 29 '17 at 20:07  "], "answer_body": " One more fast from source .\nFit encoding of json_encode (and bson_encode ). So has javascript Array compliance.  function isSequential($value){\n    if(is_array($value) || ($value instanceof \\Countable && $value instanceof \\ArrayAccess)){\n        for ($i = count($value) - 1; $i >= 0; $i--) {\n            if (!isset($value[$i]) && !array_key_exists($i, $value)) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        throw new \\InvalidArgumentException(\n            sprintf('Data type \"%s\" is not supported by method %s', gettype($value), __METHOD__)\n        );\n    }\n} ", "question_id": 173400}, {"answer_votes": "1", "answer_comments": null, "answer_body": " answers are already given but there's too much disinformation about performance.\nI wrote this little benchmark script that shows that the foreach method is the fastest.  Disclaimer: following methods were copy-pasted from the other answers  <?php\n\nfunction method_1(Array &$arr) {\n    return $arr === array_values($arr);\n}\n\nfunction method_2(Array &$arr) {\n    for (reset($arr), $i = 0; key($arr) !== $i++; next($arr));\n    return is_null(key($arr));\n}\n\nfunction method_3(Array &$arr) {\n    return array_keys($arr) === range(0, count($arr) - 1);\n}\n\nfunction method_4(Array &$arr) {\n    $idx = 0;\n    foreach( $arr as $key => $val ){\n        if( $key !== $idx )\n            return FALSE;\n        $idx++;\n    }\n    return TRUE;\n}\n\n\n\n\nfunction benchmark(Array $methods, Array &$target){    \n    foreach($methods as $method){\n        $start = microtime(true);\n        for ($i = 0; $i < 1000; $i++)\n            $dummy = call_user_func($method, $target);\n\n        $end = microtime(true);\n        echo \"Time taken with $method = \".round(($end-$start)*1000.0,3).\"ms\\n\";\n    }\n}\n\n\n\n$targets = [\n    'Huge array' => range(0, 30000),\n    'Small array' => range(0, 1000),\n];\n$methods = [\n    'method_1',\n    'method_2',\n    'method_3',\n    'method_4',\n];\nforeach($targets as $targetName => $target){\n    echo \"==== Benchmark using $targetName ====\\n\";\n    benchmark($methods, $target);\n    echo \"\\n\";\n}  results:  ==== Benchmark using Huge array ====\nTime taken with method_1 = 5504.632ms\nTime taken with method_2 = 4509.445ms\nTime taken with method_3 = 8614.883ms\nTime taken with method_4 = 2720.934ms\n\n==== Benchmark using Small array ====\nTime taken with method_1 = 77.159ms\nTime taken with method_2 = 130.03ms\nTime taken with method_3 = 160.866ms\nTime taken with method_4 = 69.946ms ", "question_id": 173400}, {"answer_votes": "1", "answer_comments": [" While this may answer the question it\u2019s always a good idea to put some text in your answer to explain what you're doing. Read how to write a good answer . \u2013 J\u00f8rgen R  Jan 21 '16 at 8:45 "], "answer_body": " One way to approach this is to piggyback on json_encode , which already has its own internal method of differentiating between an associative array and an indexed array in order to output the correct JSON.  You can do this by checking to see if the first character returned after encoding is a { (associative array) or a [ (indexed array).  echo substr(json_encode($the_array), 0, 1) == '{' ? 'yes' : 'no'; ", "question_id": 173400}, {"answer_votes": "0", "answer_comments": [" -1; this uses O(n) additional memory when $array has n items, and writing (someboolean) ? false : true instead of !someboolean is horrible and gratuitously verbose. \u2013 Mark Amery  Jan 6 '16 at 23:54  "], "answer_body": " I compare the difference between the keys of the array and the keys of the result of array_values() of the array, which will always be an array with integer indices. If the keys are the same, it's not an associative array.  function isHash($array) {\n    if (!is_array($array)) return false;\n    $diff = array_diff_assoc($array, array_values($array));\n    return (empty($diff)) ? false : true;\n} ", "question_id": 173400}, {"answer_votes": "0", "answer_comments": [" -1; this will take O(n\u00b2) time to complete given a sequential array of size n . That's going to be horribly inefficient for large enough arrays. \u2013 Mark Amery  Jan 2 '16 at 17:08 "], "answer_body": " Modification on the most popular answer. This takes a little more processing, but is more accurate.  <?php\n//$a is a subset of $b\nfunction isSubset($a, $b)\n{\n    foreach($a =>$v)\n        if(array_search($v, $b) === false)\n            return false;\n\n    return true;\n\n    //less effecient, clearer implementation. (uses === for comparison)\n    //return array_intersect($a, $b) === $a;\n}\n\nfunction isAssoc($arr)\n{\n    return !isSubset(array_keys($arr), range(0, count($arr) - 1));\n}\n\nvar_dump(isAssoc(array('a', 'b', 'c'))); // false\nvar_dump(isAssoc(array(1 => 'a', 0 => 'b', 2 => 'c'))); // false\nvar_dump(isAssoc(array(\"0\" => 'a', \"1\" => 'b', \"2\" => 'c'))); // false \n//(use === in isSubset to get 'true' for above statement)\nvar_dump(isAssoc(array(\"a\" => 'a', \"b\" => 'b', \"c\" => 'c'))); // true\n?> ", "question_id": 173400}, {"answer_votes": "0", "answer_comments": [" 1. IsAssoc() returns false for non-zero-based arrays, e.g. array(91 => \"a\") (as stated in the answer). 2. IsAssoc() returns false even if the array keys are not in order, e.g. array(1 => \"a\", 0 => \"b\", 2 => \"c\") . \u2013 Pang  Nov 24 '12 at 2:32  ", " -1; your reasoning here doesn't really make sense. If, as you suggest here, you want to be able to loop over the array using a conventional for loop with $i as a loop variable ranging from 0 to count($arr) - 1 , then the array needs to be zero-indexed , not merely sequentially-indexed. Yet your code merely checks that the array is sequentially-indexed. \u2013 Mark Amery  Jan 2 '16 at 17:18  "], "answer_body": " In my opinion, an array should be accepted as associative if any of its keys is not integer e.g. float numbers and empty string ''.  Also non-sequenced integers has to be seen as associative like (0,2,4,6) because these kind of arrays cannot be used with for loops by this way:  $n =count($arr);\nfor($i=0,$i<$n;$i++)  The second part of the function below does check if the keys are indexed or not.It also works for keys with negative values. For example (-1,0,1,2,3,4,5)  count() = 7 , max = 5, min=-1\n\n\n\nif( 7 == (5-(-1)+1 ) // true\n    return false; // array not associative\n\n\n/** \n * isAssoc Checks if an array is associative\n * @param $arr reference to the array to be checked\n * @return bool \n */     \nfunction IsAssoc(&$arr){\n    $keys= array_keys($arr);\n    foreach($keys as $key){\n        if (!is_integer($key))\n            return true;\n    }\n    // if all keys are integer then check if they are indexed\n    if(count($arr) == (max($keys)-min($keys)+1))\n        return false;\n    else\n        return true;\n} ", "question_id": 173400}, {"answer_votes": "0", "answer_comments": [" -1 for the total lack of explanation. Dumping another code sample on a question that has had 42 answers without any explanation of why to prefer it over the alternatives helps absolutely nobody. Also, given the question's ambiguity and the arguments that have raged over it in the comments, some explanation of exactly how you're defining a \"associative\" or \"sequential\" array seems necessary here. \u2013 Mark Amery  Jan 6 '16 at 23:56  "], "answer_body": " function is_array_assoc($foo) {\n    if (is_array($foo)) {\n        return (count(array_filter(array_keys($foo), 'is_string')) > 0);\n    }\n    return false;\n} ", "question_id": 173400}, {"answer_votes": "0", "answer_comments": [" implode takes 2 arguments, plus, that function would return false for an array defined like this: $x = array(\"1\" => \"b\", \"0\" => \"a\"); \u2013 nickf  Oct 6 '08 at 7:20 ", " The glue parameter of implode() became optional in PHP 4.3.0. Your example array -- $x = array(\"1\" => \"b\", \"0\" => \"a\"); -- has an associative index of non-sequential strings. is_associative() will return true for that array, as expected. \u2013 scronide  Oct 6 '08 at 7:56 ", " I like this one.  The first conditional will detect associative arrays where numeric indices are not numerically sequential, or where the first index is not \"0\", because array_merge will re-index keys of a numerically indexed (but possibly associative) array. \u2013 DWright  Nov 10 '10 at 18:30 ", " -1; this uses O(n) additional memory when $arr has n items, plus there's no explanation of what it does nor exploration of the ambiguity of the question that was asked. It also treats an array that has sequential numeric keys and the empty string as a key as non-associative, which defies any sane definition one might draw up between an 'associative' and 'sequential' array. \u2013 Mark Amery  Jan 6 '16 at 23:49 ", " @MarkAmery Interesting point about the empty string as a key. \u2013 scronide  Jan 7 '16 at 0:25  "], "answer_body": " function is_associative($arr) {\n  return (array_merge($arr) !== $arr || count(array_filter($arr, 'is_string', ARRAY_FILTER_USE_KEY)) > 0);\n} ", "question_id": 173400}, {"answer_votes": "0", "answer_comments": [" This not work. Proof eval.in/859508 $asocArray is array with two arrays. Return true. Other proofs for others exaqmple also not work how to your latets example eval.in/859507 return true \u2013 abkrim  Sep 11 '17 at 15:55  "], "answer_body": " Checking if array has all assoc-keys. With using stdClass & get_object_vars ^):  $assocArray = array('fruit1' => 'apple', \n                    'fruit2' => 'orange', \n                    'veg1' => 'tomato', \n                    'veg2' => 'carrot');\n\n$assoc_object = (object) $assocArray;\n$isAssoc = (count($assocArray) === count (get_object_vars($assoc_object)));  \nvar_dump($isAssoc); // true  Why? Function get_object_vars returns only accessible properties (see more about what is occuring during converting array to object  here ). Then, just logically: if count of basic array's elements equals count of object's accessible properties - all keys are assoc.  Few tests :  $assocArray = array('apple', 'orange', 'tomato', 'carrot');\n$assoc_object = (object) $assocArray; \n$isAssoc = (count($assocArray) === count (get_object_vars($assoc_object)));\nvar_dump($isAssoc); // false \n//...\n\n$assocArray = array( 0 => 'apple', 'orange', 'tomato', '4' => 'carrot');\n$assoc_object = (object) $assocArray; \n$isAssoc = (count($assocArray) === count (get_object_vars($assoc_object)));\nvar_dump($isAssoc); // false \n\n//... \n$assocArray = array('fruit1' => 'apple', \n                    NULL => 'orange', \n                    'veg1' => 'tomato', \n                    'veg2' => 'carrot');\n\n$assoc_object = (object) $assocArray;\n$isAssoc = (count($assocArray) === count (get_object_vars($assoc_object)));  \nvar_dump($isAssoc); //false  Etc. ", "question_id": 173400}, {"answer_votes": "0", "answer_comments": null, "answer_body": " After some local benchmarking, debugging, compiler probing, profiling, and abusing 3v4l.org to benchmark across more versions (yes, I got a warning to stop) and\ncomparing against every variation I could find...  I give you an organically derived best-average-worst-case scenario associative array test function that is at worst roughly as good as or better than all other average-case scenarios.  May God have mercy on our souls.  /**\n * Tests if an array is an associative array.\n *\n * @param array $array An array to test.\n * @return boolean True if the array is associative, otherwise false.\n */\nfunction is_assoc(array &$arr) {\n    // don't try to check non-arrays or empty arrays\n    if (FALSE === is_array($arr) || 0 === ($l = count($arr))) {\n        return false;\n    }\n\n    // shortcut by guessing at the beginning\n    reset($arr);\n    if (key($arr) !== 0) {\n        return true;\n    }\n\n    // shortcut by guessing at the end\n    end($arr);\n    if (key($arr) !== $l-1) {\n        return true;\n    }\n\n    // rely on php to optimize test by reference or fast compare\n    return array_values($arr) !== $arr;\n}  From https://3v4l.org/rkieX :  <?php\n\n// array_values\nfunction method_1(Array &$arr) {\n    return $arr === array_values($arr);\n}\n\n// method_2 was DQ; did not actually work\n\n// array_keys\nfunction method_3(Array &$arr) {\n    return array_keys($arr) === range(0, count($arr) - 1);\n}\n\n// foreach\nfunction method_4(Array &$arr) {\n    $idx = 0;\n    foreach( $arr as $key => $val ){\n        if( $key !== $idx )\n            return FALSE;\n        ++$idx;\n    }\n    return TRUE;\n}\n\n// guessing\nfunction method_5(Array &$arr) {\n    global $METHOD_5_KEY;\n    $i = 0;\n    $l = count($arr)-1;\n\n    end($arr);\n    if ( key($arr) !== $l )\n        return FALSE;\n\n    reset($arr);\n    do {\n        if ( $i !== key($arr) )\n            return FALSE;\n        ++$i;\n        next($arr);\n    } while ($i < $l);\n    return TRUE;\n}\n\n// naieve\nfunction method_6(Array &$arr) {\n    $i = 0;\n    $l = count($arr);\n    do {\n        if ( NULL === @$arr[$i] )\n            return FALSE;\n        ++$i;\n    } while ($i < $l);\n    return TRUE;\n}\n\n// deep reference reliance\nfunction method_7(Array &$arr) {\n    return array_keys(array_values($arr)) === array_keys($arr);\n}\n\n\n// organic (guessing + array_values)\nfunction method_8(Array &$arr) {\n    reset($arr);\n    if ( key($arr) !== 0 )\n        return FALSE;\n\n    end($arr);\n    if ( key($arr) !== count($arr)-1 )\n        return FALSE;\n\n    return array_values($arr) === $arr;\n}\n\nfunction benchmark(Array &$methods, Array &$target, $expected){    \n    foreach($methods as $method){\n        $start = microtime(true);\n        for ($i = 0; $i < 2000; ++$i) {\n            //$dummy = call_user_func($method, $target);\n            if ( $method($target) !== $expected ) {\n                echo \"Method $method is disqualified for returning an incorrect result.\\n\";\n                unset($methods[array_search($method,$methods,true)]);\n                $i = 0;\n                break;\n            }\n        }\n        if ( $i != 0 ) {\n            $end = microtime(true);\n            echo \"Time taken with $method = \".round(($end-$start)*1000.0,3).\"ms\\n\";\n        }\n    }\n}\n\n\n\n$true_targets = [\n    'Giant array' => range(0, 500),\n    'Tiny array' => range(0, 20),\n];\n\n\n$g = range(0,10);\nunset($g[0]);\n\n$false_targets = [\n    'Large array 1' => range(0, 100) + ['a'=>'a'] + range(101, 200),\n    'Large array 2' => ['a'=>'a'] + range(0, 200),\n    'Tiny array' => range(0, 10) + ['a'=>'a'] + range(11, 20),\n    'Gotcha array' => $g,\n];\n\n$methods = [\n    'method_1',\n    'method_3',\n    'method_4',\n    'method_5',\n    'method_6',\n    'method_7',\n    'method_8'\n];\n\n\nforeach($false_targets as $targetName => $target){\n    echo \"==== Benchmark using $targetName expecing FALSE ====\\n\";\n    benchmark($methods, $target, false);\n    echo \"\\n\";\n}\nforeach($true_targets as $targetName => $target){\n    echo \"==== Benchmark using $targetName expecting TRUE ====\\n\";\n    benchmark($methods, $target, true);\n    echo \"\\n\";\n} ", "question_id": 173400}, {"answer_votes": "0", "answer_comments": null, "answer_body": " This is my function -  public function is_assoc_array($array){\n\n    if(is_array($array) !== true){\n        return false;\n    }else{\n\n        $check = json_decode(json_encode($array));\n\n        if(is_object($check) === true){\n            return true;\n        }else{\n            return false;\n        }\n\n    }\n\n}  Some examples  print_r((is_assoc_array(['one','two','three']))===true?'Yes':'No'); \\\\No\n    print_r(is_assoc_array(['one'=>'one','two'=>'two','three'=>'three'])?'Yes':'No'); \\\\Yes\n    print_r(is_assoc_array(['1'=>'one','2'=>'two','3'=>'three'])?'Yes':'No'); \\\\Yes\n    print_r(is_assoc_array(['0'=>'one','1'=>'two','2'=>'three'])?'Yes':'No'); \\\\No  There was a similar solution by @devios1 in one of the answers but this was just another way using the inbuilt json related functions of PHP. I haven't checked how this solution fairs in terms of performance compared to other solutions that have been posted here. But it certainly has helped me solve this problem. Hope this helps. ", "question_id": 173400}, {"answer_votes": "-1", "answer_comments": [" +1 for the isset method. Yes, it's dirty, but it's the only method that's O(1) instead of O(n). \u2013 TinkerTank  Jun 24 '12 at 17:47 ", " The thorough arrayIsAssociative() returns true for both array(\"a\", \"b\", \"c\") and array(\"a\", \"b\"=>\"b\", \"c\") , but false for both array(\"a\") and array(2=>\"a\") . \u2013 Pang  Nov 23 '12 at 1:50 "], "answer_body": " One cheap and dirty way would be to check like this:  isset($myArray[count($myArray) - 1])  ...you might get a false positive if your array is like this:  $myArray = array(\"1\" => \"apple\", \"b\" => \"banana\");  A more thorough way might be to check the keys:  function arrayIsAssociative($myArray) {\n    foreach (array_keys($myArray) as $ind => $key) {\n        if (!is_numeric($key) || (isset($myArray[$ind + 1]) && $myArray[$ind + 1] != $key + 1)) {\n            return true;\n        }\n    }\n    return false;\n}\n// this will only return true if all the keys are numeric AND sequential, which\n// is what you get when you define an array like this:\n// array(\"a\", \"b\", \"c\", \"d\", \"e\");  or  function arrayIsAssociative($myArray) {\n    $l = count($myArray);\n    for ($i = 0; $i < $l, ++$i) {\n        if (!isset($myArray[$i])) return true;\n    }\n    return false;\n}\n// this will return a false positive on an array like this:\n$x = array(1 => \"b\", 0 => \"a\", 2 => \"c\", 4 => \"e\", 3 => \"d\"); ", "question_id": 173400}, {"answer_votes": "-1", "answer_comments": null, "answer_body": " I met this problem once again some days ago and i thought to take advantage of the array_merge special property:   If the input arrays have the same string keys , then the later value for that key will overwrite the previous one . If, however, the arrays contain numeric keys , the later value will not overwrite the original value, but will be appended . Values in the input array with numeric keys will be renumbered with incrementing keys starting from zero in the result array. \n   So why not to use:   function Is_Indexed_Arr($arr){\n    $arr_copy = $arr;\n    if((2*count($arr)) == count(array_merge($arr, $arr_copy))){\n        return 1;\n    }\n    return 0;\n} ", "question_id": 173400}, {"answer_votes": "-1", "answer_comments": [" The question is how to check if an array is sequential though. The array array(1 => 'foo', 0 => 'bar') is not sequential but will pass your test. For why that makes a difference, try json_encode($array) with sequential and associative arrays. \u2013 deceze \u2666  Dec 17 '11 at 5:00 ", " yes, i guess i got pretty confused and stuck with the above answers. Which kept comparing array_keys with a range and thought they will have an output which is comparison whether it is a hash or not. So my answer is to them and also to whom thinks that array_keys gives values are sequential. that's all. And also function name is is_hash so yes it doesn't tell you whether it is sequential or not \u2013 GO'  Dec 19 '11 at 1:26 "], "answer_body": " My solution is to get keys of an array like below and check that if the key is not integer:  private function is_hash($array) {\n    foreach($array as $key => $value) {\n        return ! is_int($key);\n    }\n    return false;\n}  It is wrong to get array_keys of a hash array like below:  array_keys(array(\n       \"abc\" => \"gfb\",\n       \"bdc\" => \"dbc\"\n       )\n);  will output:  array(\n       0 => \"abc\",\n       1 => \"bdc\"\n)  So, it is not a good idea to compare it with a range of numbers as mentioned in top rated answer. It will always say that it is a hash array if you try to compare keys with a range. ", "question_id": 173400}, {"answer_votes": "-1", "answer_comments": [" This isAssociativeArray() returns false for array(4=>\"four\",9=>\"nine\") , array(\"002\"=>\"two\",\"007\"=>\"james\") and array(\"a\", \"\"=>\"empty\", \"b\") , which are clearly associative. \u2013 Pang  Nov 24 '12 at 2:45 "], "answer_body": " Actually, I found myself in a similar situation trying to take an array and parse it into XML.  XML element names cannot begin with numbers -- and the code snippets I found did not correctly deal with arrays with numeric indexes.   Details on my particular situation are below   The answer provided above by @null ( http:// stackoverflow .com/a/173589/293332 ) was actually pretty darn close.  I was dismayed that it got voted down tho:  Those who do not understand regex lead very frustrating lives.  Anyway, based upon his answer, here is what I ended up with:  /** \n * Checks if an array is associative by utilizing REGEX against the keys\n * @param   $arr    <array> Reference to the array to be checked\n * @return  boolean\n */     \nprivate function    isAssociativeArray( &$arr ) {\n    return  (bool)( preg_match( '/\\D/', implode( array_keys( $arr ) ) ) );\n}  See the PCRE Escape Sequences and PCRE Syntax pages for further details.  My Particular Situation  Here is an example array that I am dealing with: Case A return  array(\n    \"GetInventorySummary\"  => array(\n        \"Filters\"  => array( \n            \"Filter\"  => array(\n                array(\n                    \"FilterType\"  => \"Shape\",\n                    \"FilterValue\"  => \"W\",\n                ),\n                array(\n                    \"FilterType\"  => \"Dimensions\",\n                    \"FilterValue\"  => \"8 x 10\",\n                ),\n                array(\n                    \"FilterType\"  => \"Grade\",\n                    \"FilterValue\"  => \"A992\",\n                ),\n            ),\n        ),\n        \"SummaryField\"  => \"Length\",\n    ),\n);  The catch is that the filter key is variable.  For example: Case B return  array(\n    \"GetInventorySummary\"  => array(\n        \"Filters\"  => array( \n            \"Filter\"  => array(\n                \"foo\"   =>  \"bar\",\n                \"bar\"   =>  \"foo\",\n            ),\n        ),\n        \"SummaryField\"  => \"Length\",\n    ),\n);  Why I Need Assoc. Array Checker  If the array I am transforming is like Case A , what I want returned is:  <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<GetInventorySummary>\n    <Filters>\n        <Filter>\n            <FilterType>Shape</FilterType>\n            <FilterValue>W</FilterValue>\n        </Filter>\n        <Filter>\n            <FilterType>Dimensions</FilterType>\n            <FilterValue>8 x 10</FilterValue>\n        </Filter>\n        <Filter>\n            <FilterType>Grade</FilterType>\n             <FilterValue>A992</FilterValue>\n        </Filter>\n    </Filters>\n    <SummaryField>Length</SummaryField>\n</GetInventorySummary>  ... However, if the array I am transforming is like Case B , what I want returned is:  <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<GetInventorySummary>\n    <Filters>\n        <Filter>\n            <foo>bar</foo>\n            <bar>foo</bar>\n        </Filter>\n    </Filters>\n    <SummaryField>Length</SummaryField>\n</GetInventorySummary> ", "question_id": 173400}, {"answer_votes": "-1", "answer_comments": null, "answer_body": " Yet another way to do this.  function array_isassociative($array)\n{\n    // Create new Array,  Make it the same size as the input array\n    $compareArray = array_pad(array(), count($array), 0);\n\n    // Compare the two array_keys\n    return (count(array_diff_key($array, $compareArray))) ? true : false;\n\n} ", "question_id": 173400}, {"answer_votes": "-1", "answer_comments": [" Wait, what, where did I contribute this? Or did you mean to say \"Improvement on Mark Amery\", as in an improvement on the accepted answer that is attributed to me? Please be aware, in the latter case, that I didn't author that answer - my edits to it have simply caused the authorship attribution algorithm for Community Wiki posts to put my name on it. \u2013 Mark Amery  Jul 21 '16 at 8:10 "], "answer_body": " Improvement from Mark Amery  function isAssoc($arr)\n{\n    // Is it set, is an array, not empty and keys are not sequentialy numeric from 0\n    return isset($arr) && is_array($arr) && count($arr)!=0 && array_keys($arr) !== range(0, count($arr) - 1);\n}  This tests if variable exists, if it is an array, if it is not an empty array and if the keys are not sequential from 0.  To see if the array is associative  if (isAssoc($array)) ...  To see if it numeric  if (!isAssoc($array)) ... ", "question_id": 173400}, {"answer_votes": "-1", "answer_comments": null, "answer_body": " In simple way you can check is array is associative or not by below steps   convert all keys of array into one array by using array_keys()  filter out non numeric key from array using array_filter() and is_numeric()  compare number of elements in filtered array and actual array, If number of elements are not equals in both array then it is associative array.   Function for above step is as below.  function isAssociative(array $array)\n    {\n        return count(array_filter(array_keys($array), function($v){return is_numeric($v);})) !== count($array));\n    } ", "question_id": 173400}, {"answer_votes": "-2", "answer_comments": [" this assumes the array is indexed from 0 which is not necessarily true and will give wrong results for arrays like [10=>'x', 20=>'y'] \u2013 Gordon  Jun 21 '12 at 13:25 ", " This function returns true for both array(\"a\"=>\"b\") and array(\"a\",\"b\") . \u2013 Pang  Nov 23 '12 at 2:21 "], "answer_body": " function isAssoc($arr)\n{\n    $a = array_keys($arr);\n    for($i = 0, $t = count($a); $i < $t; $i++)\n    {\n        if($a[$i] != $i)\n        {\n            return false;\n        }\n    }\n    return true;\n} ", "question_id": 173400}, {"answer_votes": "-2", "answer_comments": [" No. var_dump((bool)key(array(1=>\"foo\"))); returns true.  -1. \u2013 ghoti  Jun 19 '12 at 13:54 ", " var_dump((bool)key(array(\"a\"=>\"foo\"))) returns true ; var_dump((bool)key(array(\"\"=>\"foo\"))) returns false . Also, both var_dump((bool)key(array(\"foo\",\"bar\"))) and var_dump((bool)key(array(\"0\"=>\"foo\",\"a\"=>\"bar\"))) returns false . \u2013 Pang  Nov 23 '12 at 1:55  "], "answer_body": " I just use the key() function. Observe:  <?php\nvar_dump(key(array('hello'=>'world', 'hello'=>'world'))); //string(5) \"hello\"\nvar_dump(key(array('world', 'world')));                  //int(0)\nvar_dump(key(array(\"0\" => 'a', \"1\" => 'b', \"2\" => 'c'))); //int(0) who makes string sequetial keys anyway????\n?>  Thus, just by checking for false, you can determine whether an array is associative or not. ", "question_id": 173400}, {"answer_votes": "-2", "answer_comments": [" This function returns false for array(2=>'a',3=>'b') , array('a','b') , array(\"0x\"=>'a','f'=>'g') , array(\"90\"=>'a',\"17\"=>'b') , array(\"\"=>'b',20=>'c') . \u2013 Pang  Nov 23 '12 at 2:12 ", " @Pang: if you could read : \"it's simply not accepting numerical keys,\", you could just remove the downvote. Thx. \u2013 hornetbzz  Nov 26 '12 at 16:56 ", " Your is_associative_array() is returning false for associative arrays such as array(\"0x\"=>'a','f'=>'g') and array(\"\"=>'b',20=>'c') . Now, I am confused. \u2013 Pang  Nov 27 '12 at 1:29  "], "answer_body": " Another variant not shown yet, as it's simply not accepting numerical keys, but I like Greg's one very much :  /* Returns true if $var associative array */  \n  function is_associative_array( $array ) {  \n    return is_array($array) && !is_numeric(implode('', array_keys($array)));  \n  } ", "question_id": 173400}, {"answer_votes": "-2", "answer_comments": [" This function returns true for both array(\"a\", \"b\") and array(\"a\", \"b\" => \"B\") as it only checks the first key (note the return and the break ). \u2013 Pang  Nov 24 '12 at 2:25  "], "answer_body": " Simple and performance friendly solution which only checks the first key.  function isAssoc($arr = NULL)\n{\n    if ($arr && is_array($arr))\n    {\n        foreach ($arr as $key => $val)\n        {\n            if (is_numeric($key)) { return true; }\n\n            break;\n        }\n    }\n\n    return false;\n} ", "question_id": 173400}, {"answer_votes": "-2", "answer_comments": [" fails for single element associative arrays \u2013 Jinu Joseph Daniel  Jul 5 '12 at 19:37 ", " Isn't this a duplicate answer ? \u2013 Sharique Abdullah  Jul 25 '12 at 7:30 ", " Can you give an example, Jinu?  I don't see this behavior.  (Although I use == not ===; I don't know why so many use ===.) \u2013 grantwparks  Aug 2 '12 at 21:39 "], "answer_body": " Best function to detect associative array (hash array)  <?php\nfunction is_assoc($arr) { return (array_values($arr) !== $arr); }\n?> ", "question_id": 173400}, {"answer_votes": "-4", "answer_comments": [" -1 for missing your apostrophe.  Oh, and test with array(\"@\"=>\"foo\"); .  And ... preg, really ? \u2013 ghoti  Jun 19 '12 at 14:03  "], "answer_body": " If your looking for just non-numeric keys (no matter the order) then you may want to try  function IsAssociative($array)\n{\n    return preg_match('/[a-z]/i', implode(array_keys($array)));\n} ", "question_id": 173400}], "question_body": " PHP treats all arrays as associative, so there aren't any built in functions. Can anyone recommend a fairly efficient way to check if an array contains only numeric keys?  Basically, I want to be able to differentiate between this:   and this:  ", "question_code": ["$sequentialArray = array('apple', 'orange', 'tomato', 'carrot');\n", "$assocArray = array('fruit1' => 'apple', \n                    'fruit2' => 'orange', \n                    'veg1' => 'tomato', \n                    'veg2' => 'carrot');\n"], "question_id": 173400}