{"question_comments": [" And a totally unrelated grammar question that's bothering me now - should my title be \"why aren't Java's generics\" or \"why isn't Java's generics\"?? Is \"generics\" plural because of the s or singular because it's one entity? \u2013 froadie  Apr 30 '10 at 14:44 ", " generics as done in Java are a very poor form of parametric polymorphism.  Don't put too much into faith into them (like I used to), because one day you'll hit hard their pathetic limitations: Surgeon extends Handable<Scalpel>, Handable<Sponge> KABOOM! Does not compute [TM].  There's your Java generics limitation.  Any OOA/OOD can be translated fine into Java (and MI can be done very nicely using Java interfaces) but generics just don't cut it.  They're fine for \"collections\" and procedural programming that said (which is what most Java programmers do anyway so...). \u2013 SyntaxT3rr0r  Apr 30 '10 at 15:43 ", " Super class of List<Dog> is not List<Animal> but List<?> (i.e list of unknown type) . Generics erases type information in compiled code. This is done so that code which is using generics(java 5 & above) is compatible with earlier versions of java without generics. \u2013 rai.skumar  Dec 4 '12 at 11:15  ", " Related SO question - Whats the use of saying <? extends SomeObject> instead of <SomeObject> \u2013 Aniket Thakur  Oct 2 '15 at 18:53 ", " @froadie since nobody seemed to respond... it should definitely be \"why aren't Java's generics...\". The other issue is that \"generic\" is actually an adjective, and so \"generics\" is referring to a dropped plural noun modified by \"generic\". You could say \"that function is a generic\", but that would be more cumbersome than saying \"that function is generic\". However, it's a bit cumbersome to say \"Java has generic functions and classes\", instead of just \"Java has generics\". As someone who wrote their master's thesis on adjectives, I think you've stumbled upon a very interesting question! \u2013 dantiston  May 30 '17 at 5:18 "], "question_title": "Is List<Dog> a subclass of List<Animal>? Why are Java generics not implicitly polymorphic?", "answers": [{"answer_votes": "733", "answer_comments": [" Interestingly, every list of dogs is indeed a list of animals, just like intuition tells us. The point is, that not every list of animals is a list of dogs, hence mutattion of the list by adding a cat is the problem. \u2013 Ingo  Jan 28 '13 at 19:29 ", " @Ingo: No, not really: you can add a cat to a list of animals, but you can't add a cat to a list of dogs. A list of dogs is only a list of animals if you consider it in a read-only sense. \u2013 Jon Skeet  Jan 28 '13 at 19:33 ", " @JonSkeet - Of course, but who is mandating that making a new list from a cat and a list of dogs actually changes the list of dogs? This is an arbitrary implementation decision in Java. One that goes counter to logic and intuition. \u2013 Ingo  Jan 28 '13 at 19:41 ", " @Ingo: I wouldn't have used that \"certainly\" to start with. If you have a list which says at the top \"Hotels we might want to go to\" and then someone added a swimming pool to it, would you think that valid? No - it's a list of hotels, which isn't a list of buildings. And it's not like I even said \"A list of dogs is not a list of animals\" - I put it in code terms , in a code font. I really don't think there's any ambiguity here. Using subclass would be incorrect anyway - it's about assignment compatibility, not subclassing. \u2013 Jon Skeet  Jan 28 '13 at 19:58 ", " @ruakh: The problem is that you're then punting to execution time something which can be blocked at compile-time. And I'd argue that array covariance was a design mistake to start with. \u2013 Jon Skeet  Jul 3 '13 at 17:22 "], "answer_body": " No, a List<Dog> is not a List<Animal> . Consider what you can do with a List<Animal> - you can add any animal to it... including a cat. Now, can you logically add a cat to a litter of puppies? Absolutely not.  // Illegal code - because otherwise life would be Bad\nList<Dog> dogs = new ArrayList<Dog>(); // ArrayList implements List\nList<Animal> animals = dogs; // Awooga awooga\nanimals.add(new Cat());\nDog dog = dogs.get(0); // This should be safe, right?  Suddenly you have a very confused cat.  Now, you can't add a Cat to a List<? extends Animal> because you don't know it's a List<Cat> . You can retrieve a value and know that it will be an Animal , but you can't add arbitrary animals. The reverse is true for List<? super Animal> - in that case you can add an Animal to it safely, but you don't know anything about what might be retrieved from it, because it could be a List<Object> . ", "question_id": 2745265}, {"answer_votes": "65", "answer_comments": [" Or use: List<Object> \u2013 Mo'in Creemers  Aug 29 '12 at 11:35  "], "answer_body": " What you are looking for is called covariant type parameters .  The problem is that they are not type-safe in the general case, specifically for mutable lists.  Suppose you have a List<Dog> , and it is allowed to function as a List<Animal> .  What happens when you try to add a Cat to this List<Animal> which is really a List<Dog> ?  Automatically allowing type parameters to be covariant therefore breaks the type system.  It would be useful to add syntax to allow type parameters to be specified as covariant, which avoids the ? extends Foo in method declarations, but that does add additional complexity. ", "question_id": 2745265}, {"answer_votes": "42", "answer_comments": null, "answer_body": " The reason a List<Dog> is not a List<Animal> , is that, for example, you can insert a Cat into a List<Animal> , but not into a List<Dog> ... you can use wildcards to make generics more extensible where possible; for example, reading from  a List<Dog> is the similar to reading from a List<Animal> -- but not writing.  The Generics in the Java Language and the Section on Generics from the Java Tutorials have a very good, in-depth explanation as to why some things are or are not polymorphic or permitted with generics. ", "question_id": 2745265}, {"answer_votes": "31", "answer_comments": [" Arguably, array covariance is a language design bug. Note that due to type erasure, the same behaviour is technically impossible for generic collection. \u2013 Michael Borgwardt  Apr 30 '10 at 14:55 ", " FYI: I mentioned your answer in stackoverflow.com/a/26551453/295802 \u2013 Mark Bennett  Oct 24 '14 at 17:16 ", " \" I would say the whole point of Generics is that it doesn't allow that. \". You can never be sure: Java and Scala's Type Systems are Unsound: The Existential Crisis of Null Pointers (presented at OOPSLA 2016) (since corrected it seems) \u2013 David Tonhofer  Aug 15 '17 at 17:52 "], "answer_body": " I would say the whole point of Generics is that it doesn't allow that. Consider the situation with arrays, which do allow that type of covariance:  Object[] objects = new String[10];\n  objects[0] = Boolean.FALSE;  That code compiles fine, but throws a runtime error ( java.lang.ArrayStoreException: java.lang.Boolean in the second line). It is not typesafe. The point of Generics is to add the compile time type safety, otherwise you could just stick with a plain class without generics.  Now there are times where you need to be more flexible and that is what the ? super Class and ? extends Class are for. The former is when you need to insert into a type Collection (for example), and the latter is for when you need to read from it, in a type safe manner. But the only way to do both at the same time is to have a specific type. ", "question_id": 2745265}, {"answer_votes": "26", "answer_comments": [" Yes, human language is more fuzzy. But still, once you add a different animal to the list of dogs, it is still a list of animals, but no longer a list of dogs. The difference being, a human, with the fuzzy logic, usually has no problem realizing that. \u2013 Vlasec  Nov 13 '17 at 12:14  ", " @Vlasec: Human logic can indeed be fuzzy, but that's not my point hear. You could apply very precise logic; it's just that in this context, we default to using an extensional definition of the list. \u2013 einpoklum  Mar 19 at 23:42 "], "answer_body": " A point I think should be added to what other  answers mention is that while   List<Dog> isn't-a List<Animal>  in Java   it is also true that   A list of dogs is-a list of animals in English (well, under a reasonable interpretation)   The way the OP's intuition works - which is completely valid of course - is the latter sentence. However, if we apply this intuition we get a language that is not Java-esque in its type system: Suppose our language does allow adding a cat to our list of dogs. What would that mean? It would mean that the list ceases to be a list of dogs, and remains merely a list of animals. And a list of mammals, and a list of quadrapeds.  To put it another way: A List<Dog> in Java does not mean \"a list of dogs\" in English, it means \"a list which can have dogs, and nothing else\".  More generally, OP's intuition lends itself towards a language in which operations on objects can change their type , or rather, an object's type(s) is a (dynamic) function of its value. ", "question_id": 2745265}, {"answer_votes": "5", "answer_comments": [" It might be argued that, precisely because of that, Arrays in Java are broken , \u2013 leonbloy  Dec 15 '17 at 14:41 ", " Arrays being covariant is a compiler \"feature\". \u2013 Cristik  Mar 2 at 7:40 "], "answer_body": " To understand the problem it's useful to make comparison to arrays.  List<Dog> is not subclass of List<Animal> .  But  Dog[]  is subclass of Animal[] .  Arrays are reifiable and covariant . Reifiable means their type information is fully available at runtime. Therefore arrays provide runtime type safety but not compile-time type safety.  // All compiles but throws ArrayStoreException at runtime at last line\n    Dog[] dogs = new Dog[10];\n    Animal[] animals = dogs; // compiles\n    animals[0] = new Cat(); // throws ArrayStoreException at runtime  It's vice versa for generics:  Generics are erased and invariant . Therefore generics can't provide runtime type safety, but they provide compile-time type safety. In the code below if generics were covariant it will be possible to make heap pollution at line 3.  List<Dog> dogs = new ArrayList<>();\n    List<Animal> animals = dogs; // compile-time error, otherwise heap pollution\n    animals.add(new Cat()); ", "question_id": 2745265}, {"answer_votes": "4", "answer_comments": null, "answer_body": " The basis logic for such behavior is that Generics follow a mechanism of type erasure. So at run time you have no way if identifying the type of collection unlike arrays where there is no such erasure process. So coming back to your question...  So suppose there is a method as given below:  add(List<Animal>){//You can add List<Dog or List<Cat> and this will compile as per rules of polymorphism}  Now if java allows caller to add List of type Animal to this method then you might add wrong thing into collection and at run time too it will run due to type erasure. While in case of arrays you will get a run time exception for such scenarios...  Thus in essence this behavior is implemented so that one cannot add wrong thing into collection. Now  I believe type erasure exists so as to give compatibility with legacy java without generics.... ", "question_id": 2745265}, {"answer_votes": "4", "answer_comments": [" Among the 4 versions, #2 is probably incorrect. e.g. we cannot call it with (Consumer<Runnable>, Supplier<Dog>) while Dog is subtype of Animal & Runnable \u2013 ZhongYu  Jul 27 '15 at 20:10  ", " groups.google.com/forum/#!topic/java-lang-fans/0GDv0salPTs \u2013 ZhongYu  Jul 27 '15 at 20:39 "], "answer_body": " The answers given here didn't fully convince me. So instead, I make another example.  public void passOn(Consumer<Animal> consumer, Supplier<Animal> supplier) {\n    consumer.accept(supplier.get());\n}  sounds fine, doesn't it? But you can only pass Consumer s and Supplier s for Animal s. If you have a Mammal consumer, but a Duck supplier, they should not fit although both are animals. In order to disallow this, additional restrictions have been added.  Instead of the above, we have to define relationships between the types we use.  E. g.,  public <A extends Animal> void passOn(Consumer<A> consumer, Supplier<? extends A> supplier) {\n    consumer.accept(supplier.get());\n}  makes sure that we can only use a supplier which provides us the right type of object for the consumer.  OTOH, we could as well do  public <A extends Animal> void passOn(Consumer<? super A> consumer, Supplier<A> supplier) {\n    consumer.accept(supplier.get());\n}  where we go the other way: we define the type of the Supplier and restrict that it can be put into the Consumer .  We even can do  public <A extends Animal> void passOn(Consumer<? super A> consumer, Supplier<? extends A> supplier) {\n    consumer.accept(supplier.get());\n}  where, having the intuitive relations Life -> Animal -> Mammal -> Dog , Cat etc., we could even put a Mammal into a Life consumer, but not a String into a Life consumer. ", "question_id": 2745265}, {"answer_votes": "3", "answer_comments": null, "answer_body": " Actually you can use an interface to achieve what you want.  public interface Animal {\n    String getName();\n    String getVoice();\n}\npublic class Dog implements Animal{\n    @Override \n    String getName(){return \"Dog\";}\n    @Override\n    String getVoice(){return \"woof!\";}  }  you can then use the collections using  List <Animal> animalGroup = new ArrayList<Animal>();\nanimalGroup.add(new Dog()); ", "question_id": 2745265}, {"answer_votes": "1", "answer_comments": [" This will create more problems than it actually solves \u2013 Ferrybig  Feb 1 '16 at 15:33 ", " If you try to add a Cat to the list, sure it will create problems, but for looping purposes i think its the only non verbose answer. \u2013 sagits  Feb 2 '16 at 12:28 "], "answer_body": " If you are sure that the list items are subclasses of that given super type you can cast the list using this approach:  (List<Animal>) (List<?>) dogs  This is usefull when you want to pass the list in a constructor or iterate over it ", "question_id": 2745265}, {"answer_votes": "1", "answer_comments": [" This is a good idea, so much so that it exists in Java SE already. ; ) Collections.unmodifiableCollection \u2013 Radiodef  May 8 '15 at 21:30 ", " Right but the collection I define can be modified. \u2013 dan b  May 9 '15 at 11:40 ", " Yes, it can be modified. Collection<? extends E> already handles that behavior correctly though, unless you use it in a way that is not type-safe (e.g. casting it to something else). The only advantage I see there is, when you call the add operation, it throws an exception even if you casted it. \u2013 Vlasec  Nov 13 '17 at 12:47 "], "answer_body": " The answer as well as other answers are correct. I am  going to add to those answers with a solution that I think will be helpful.  I think this comes up often in programming. One thing to note is that for Collections (Lists, Sets, etc.) the main issue is adding to the Collection. That is where things break down.  Even removing is OK.  In most cases, we can use Collection<? extends T> rather then Collection<T> and that should be the first choice.  However, I am finding cases where it is not easy to do that.  It is up for debate as to whether that is always the best thing to do.  I am presenting here a class DownCastCollection that can take convert a Collection<? extends T> to a Collection<T> (we can define similar classes for List, Set, NavigableSet,..) to be used when using the standard approach is very inconvenient.  Below is an example of how to use it (we could also use Collection<? extends Object> in this case, but I am keeping it simple to illustrate using DownCastCollection.  /**Could use Collection<? extends Object> and that is the better choice. \n* But I am doing this to illustrate how to use DownCastCollection. **/\n\npublic static void print(Collection<Object> col){  \n    for(Object obj : col){\n    System.out.println(obj);\n    }\n}\npublic static void main(String[] args){\n  ArrayList<String> list = new ArrayList<>();\n  list.addAll(Arrays.asList(\"a\",\"b\",\"c\"));\n  print(new DownCastCollection<Object>(list));\n}  Now the class:  import java.util.AbstractCollection;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\n\npublic class DownCastCollection<E> extends AbstractCollection<E> implements Collection<E> {\nprivate Collection<? extends E> delegate;\n\npublic DownCastCollection(Collection<? extends E> delegate) {\n    super();\n    this.delegate = delegate;\n}\n\n@Override\npublic int size() {\n    return delegate ==null ? 0 : delegate.size();\n}\n\n@Override\npublic boolean isEmpty() {\n    return delegate==null || delegate.isEmpty();\n}\n\n@Override\npublic boolean contains(Object o) {\n    if(isEmpty()) return false;\n    return delegate.contains(o);\n}\nprivate class MyIterator implements Iterator<E>{\n    Iterator<? extends E> delegateIterator;\n\n    protected MyIterator() {\n        super();\n        this.delegateIterator = delegate == null ? null :delegate.iterator();\n    }\n\n    @Override\n    public boolean hasNext() {\n        return delegateIterator != null && delegateIterator.hasNext();\n    }\n\n    @Override\n    public  E next() {\n        if(!hasNext()) throw new NoSuchElementException(\"The iterator is empty\");\n        return delegateIterator.next();\n    }\n\n    @Override\n    public void remove() {\n        delegateIterator.remove();\n\n    }\n\n}\n@Override\npublic Iterator<E> iterator() {\n    return new MyIterator();\n}\n\n\n\n@Override\npublic boolean add(E e) {\n    throw new UnsupportedOperationException();\n}\n\n@Override\npublic boolean remove(Object o) {\n    if(delegate == null) return false;\n    return delegate.remove(o);\n}\n\n@Override\npublic boolean containsAll(Collection<?> c) {\n    if(delegate==null) return false;\n    return delegate.containsAll(c);\n}\n\n@Override\npublic boolean addAll(Collection<? extends E> c) {\n    throw new UnsupportedOperationException();\n}\n\n@Override\npublic boolean removeAll(Collection<?> c) {\n    if(delegate == null) return false;\n    return delegate.removeAll(c);\n}\n\n@Override\npublic boolean retainAll(Collection<?> c) {\n    if(delegate == null) return false;\n    return delegate.retainAll(c);\n}\n\n@Override\npublic void clear() {\n    if(delegate == null) return;\n        delegate.clear();\n\n}  } ", "question_id": 2745265}, {"answer_votes": "0", "answer_comments": null, "answer_body": " Lets take the example from JavaSE tutorial   public abstract class Shape {\n    public abstract void draw(Canvas c);\n}\n\npublic class Circle extends Shape {\n    private int x, y, radius;\n    public void draw(Canvas c) {\n        ...\n    }\n}\n\npublic class Rectangle extends Shape {\n    private int x, y, width, height;\n    public void draw(Canvas c) {\n        ...\n    }\n}  So why a list of dogs (circles) should not be considered implicitly a list of animals (shapes) is because of this situation:  // drawAll method call\ndrawAll(circleList);\n\n\npublic void drawAll(List<Shape> shapes) {\n   shapes.add(new Rectangle());    \n}  So Java \"architects\" had 2 options which address this problem:   do not consider that a subtype is implicitly it's supertype, and give a compile error, like it happens now  consider the subtype to be it's supertype and restrict at compile the \"add\" method (so in the drawAll method, if a list of circles, subtype of shape, would be passed, the compiler should detected that and restrict you with compile error into doing that).   For obvious reasons, that chose the first way. ", "question_id": 2745265}, {"answer_votes": "0", "answer_comments": null, "answer_body": " We should also take in consideration how the compiler threats the generic classes: in \"instantiates\" a different type whenever we fill the generic arguments.  Thus we have ListOfAnimal , ListOfDog , ListOfCat , etc, which are distinct classes that end up being \"created\" by the compiler when we specify the generic arguments. And this is a flat hierarchy (actually regarding to List is not a hierarchy at all).  Another argument why covariance doesn't make sense in case of generic classes is the fact that at base all classes are the same - are List instances. Specialising a List by filling the generic argument doesn't extend the class, it just makes it work for that particular generic argument. ", "question_id": 2745265}, {"answer_votes": "0", "answer_comments": null, "answer_body": " The problem has been well-identified. But there's a solution; make doSomething generic:  <T extends Animal> void doSomething<List<T> animals) {\n}  now you can call doSomething with either List<Dog> or List<Cat> or List<Animal>. ", "question_id": 2745265}, {"answer_votes": "0", "answer_comments": null, "answer_body": " Subtyping is invariant for parameterized types. Even tough the class Dog is a subtype of Animal , the parameterized type List<Dog> is not a subtype of List<Animal> . In contrast, covariant subtyping is used by arrays, so the array\ntype Dog[] is a subtype of Animal[] .  Invariant subtyping ensures that the type constraints enforced by Java are not violated. Consider the following code given by @Jon Skeet:  List<Dog> dogs = new ArrayList<Dog>(1);\nList<Animal> animals = dogs;\nanimals.add(new Cat()); // compile-time error\nDog dog = dogs.get(0);  As stated by @Jon Skeet, this code is illegal, because otherwise it would violate the type constraints by returning a cat when a dog expected.  It is instructive to compare the above to analogous code for arrays.  Dog[] dogs = new Dog[1];\nObject[] animals = dogs;\nanimals[0] = new Cat(); // run-time error\nDog dog = dogs[0];  The code is legal. However, throws an array store exception .\nAn array carries its type at run-time this way JVM can enforce\ntype safety of covariant subtyping.  To understand this further let's look at the bytecode generated by javap of the class below:  import java.util.ArrayList;\nimport java.util.List;\n\npublic class Demonstration {\n    public void normal() {\n        List normal = new ArrayList(1);\n        normal.add(\"lorem ipsum\");\n    }\n\n    public void parameterized() {\n        List<String> parameterized = new ArrayList<>(1);\n        parameterized.add(\"lorem ipsum\");\n    }\n}  Using the command javap -c Demonstration , this shows the following Java bytecode:  Compiled from \"Demonstration.java\"\npublic class Demonstration {\n  public Demonstration();\n    Code:\n       0: aload_0\n       1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n       4: return\n\n  public void normal();\n    Code:\n       0: new           #2                  // class java/util/ArrayList\n       3: dup\n       4: iconst_1\n       5: invokespecial #3                  // Method java/util/ArrayList.\"<init>\":(I)V\n       8: astore_1\n       9: aload_1\n      10: ldc           #4                  // String lorem ipsum\n      12: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z\n      17: pop\n      18: return\n\n  public void parameterized();\n    Code:\n       0: new           #2                  // class java/util/ArrayList\n       3: dup\n       4: iconst_1\n       5: invokespecial #3                  // Method java/util/ArrayList.\"<init>\":(I)V\n       8: astore_1\n       9: aload_1\n      10: ldc           #4                  // String lorem ipsum\n      12: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z\n      17: pop\n      18: return\n}  Observe that the translated code of method bodies are identical. Compiler replaced each parameterized type by its erasure . This property is crucial meaning that it did not break backwards compatibility.  In conclusion, run-time safety is not possible for parameterized types, since compiler replaces each parameterized type by its erasure. This makes parameterized types are nothing more than syntactic sugar. ", "question_id": 2745265}], "question_body": " I'm a bit confused about how Java generics handle inheritance / polymorphism.  Assume the following hierarchy -  Animal (Parent)  Dog - Cat (Children)  So suppose I have a method . By all the rules of inheritance and polymorphism, I would assume that a  is a and a  is a - and so either one could be passed to this method. Not so. If I want to achieve this behavior, I have to explicitly tell the method to accept a list of any subset of Animal by saying .  I understand that this is Java's behavior. My question is why ? Why is polymorphism generally implicit, but when it comes to generics it must be specified? ", "question_code": ["doSomething(List<Animal> animals)", "List<Dog>", "List<Animal>", "List<Cat>", "List<Animal>", "doSomething(List<? extends Animal> animals)"], "question_id": 2745265}