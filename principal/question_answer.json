{"question_comments": [" stackoverflow.com/questions/21294/\u2026 \u2013 Daniel A. White  Jun 4 '09 at 12:01 ", " @Daniel, I do not want to use an AJAX call. \u2013 Alec Smart  Jun 4 '09 at 12:02 ", " Why not declaring the imported file before the other one that requires it, simply using ordered tags? \u2013 falsarella  Jan 6 '15 at 21:07 ", " @Claudiu That wouldn't help to import anything, but it should work as well. If you have a JS file that depends of another JS file, just declare the script tags of the dependency files first, so the later will already have its dependencies loaded. If you have a situation where it isn't a possible approach, the answers here should be helpful. \u2013 falsarella  Feb 19 '16 at 12:29 ", " what is the practical advantage of doing this?  either way the code base dependent on javascript file isn't going to load and start working in any case it is not loaded ! \u2013 Ciasto piekarz  Jan 21 '17 at 10:52 "], "question_title": "How do I include a JavaScript file in another JavaScript file?", "answers": [{"answer_votes": "3358", "answer_comments": [" not all javascript files are executed in a browser. \u2013 Michael Paulukonis  Jul 14 '10 at 17:42 ", " Nope but somebody that uses something as advanced as Rhino or else wouldn't ask this question. \u2013 e-satis  Jul 15 '10 at 3:53 ", " Just to be complete, there is a third way: In certain solutions when you control both javascript files, you can just make 1 giant javascript file which combines the content of both files. \u2013 Toad  Sep 7 '12 at 8:36 ", " Shouldn't \"document.createElement(\"my_lovely_script.js\");\" in the example be \"document.createElement(\"script\")\" ? \u2013 Russell Silva  Dec 14 '12 at 23:28 ", " How does eval open the door to hacks if it's your code that you're executing? \u2013 Vince Panuccio  Jan 6 '13 at 9:39 "], "answer_body": " The old versions of JavaScript had no import, include, or require, so many different approaches to this problem have been developed.  But recent versions of JavaScript have standards like ES6 modules to import modules, although this is not supported yet by most browsers.  Many people using modules with browser applications use build and/or transpilation tools to make it practical to use new syntax with features like modules.  ES6 Modules  Note that currently, browser support for ES6 Modules is not particularly great, but it is on its way. According to this StackOverflow answer , they are supported in Chrome 61, Firefox 54(behind the dom.moduleScripts.enabled setting in about:config ) and MS Edge 16, with only Safari 10.1 providing support without flags.  Thus, you will currently still need to use build and/or transpilation tools to valid JavaScript that will run in without any requirement for the user to use those browser versions or enable any flags.  Once ES6 Modules are commonplace, here is how you would go about using them:  // module.js\nexport function hello() {\n  return \"Hello\";\n}  // main.js\nimport {hello} from 'module'; // or './module'\nlet val = hello(); // val is \"Hello\";  Node.js require  Node.js is currently using a module.exports/require system.  You can use babel to transpile if you want the import syntax.  // mymodule.js\nmodule.exports = {\n   hello: function() {\n      return \"Hello\";\n   }\n}  // server.js\nconst myModule = require('./mymodule');\nlet val = myModule.hello(); // val is \"Hello\"  There are other ways for JavaScript to include external JavaScript contents in browsers that do not require preprocessing.  AJAX Loading  You could load an additional script with an AJAX call and then use eval to run it. This is the most straightforward way, but it is limited to your domain because of the JavaScript sandbox security model. Using eval also opens the door to bugs, hacks and security issues.  jQuery Loading  The jQuery library provides loading functionality in one line :  $.getScript(\"my_lovely_script.js\", function() {\n   alert(\"Script loaded but not necessarily executed.\");\n});  Dynamic Script Loading  You could add a script tag with the script URL into the HTML. To avoid the overhead of jQuery, this is an ideal solution.  The script can even reside on a different server. Furthermore, the browser evaluates the code. The <script> tag can be injected into either the web page <head> , or inserted just before the closing </body> tag.  Here is an example of how this could work:  function dynamicallyLoadScript(url) {\n    var script = document.createElement(\"script\"); // Make a script DOM node\n    script.src = url; // Set it's src to the provided URL\n\n    document.head.appendChild(script); // Add it to the end of the head section of the page (could change 'head' to 'body' to add it to the end of the body section instead)\n}  This function will add a new <script> tag to end of the head section of the page, where the src attribute is set to the URL which is given to the function as the first parameter.  Both of these solutions are discussed and illustrated in JavaScript Madness: Dynamic Script Loading .  Detecting when the script has been executed  Now, there is a big issue you must know about. Doing that implies that you remotely load the code . Modern web browsers will load the file and keep executing your current script because they load everything asynchronously to improve performance. (This applies to both the jQuery method and the manual dynamic script loading method.)  It means that if you use these tricks directly, you won't be able to use your newly loaded code the next line after you asked it to be loaded , because it will be still loading.  For example: my_lovely_script.js contains MySuperObject :  var js = document.createElement(\"script\");\n\njs.type = \"text/javascript\";\njs.src = jsFilePath;\n\ndocument.body.appendChild(js);\n\nvar s = new MySuperObject();\n\nError : MySuperObject is undefined  Then you reload the page hitting F5 . And it works! Confusing...  So what to do about it ?  Well, you can use the hack the author suggests in the link I gave you. In summary, for people in a hurry, he uses an event to run a callback function when the script is loaded. So you can put all the code using the remote library in the callback function. For example:  function loadScript(url, callback)\n{\n    // Adding the script tag to the head as suggested before\n    var head = document.getElementsByTagName('head')[0];\n    var script = document.createElement('script');\n    script.type = 'text/javascript';\n    script.src = url;\n\n    // Then bind the event to the callback function.\n    // There are several events for cross browser compatibility.\n    script.onreadystatechange = callback;\n    script.onload = callback;\n\n    // Fire the loading\n    head.appendChild(script);\n}  Then you write the code you want to use AFTER the script is loaded in a lambda function :  var myPrettyCode = function() {\n   // Here, do whatever you want\n};  Then you run all that:  loadScript(\"my_lovely_script.js\", myPrettyCode);  Note that the script may execute after the DOM has loaded, or before, depending on the browser and whether you included the line script.async = false; . There's a great article on Javascript loading in general which discusses this.  Source Code Merge/Preprocessing  As mentioned at the top of this answer, many developers now use build/transpilation tool(s) like WebPack, Babel, or Gulp in their projects, allowing them to use new syntax and support modules better, combine files, minify, etc. ", "question_id": 950087}, {"answer_votes": "493", "answer_comments": [" +1 for citing the right way to do it :-) It would be even better if you included an example! \u2013 Sean Vieira  Jan 2 '13 at 2:15 ", " @Sean per your suggestion - I added a short example \u2013 John Strickler  Jan 2 '13 at 15:15 ", " @aaaidan: MattDmo's reason plus it relies on an external library which in return rely on the accepted answer. \u2013 David Mulder  Mar 20 '14 at 21:28 ", " To overcome require.js the most latest would be angular js which is more stable and easy to use with along with other binding and rich HTML features. \u2013 zeeshan  Nov 17 '14 at 20:00 ", " -1: Those abstractions -- \"some_dependency\" -- are really poor, with indexes adding to confusion. I struggle to understand what a working code example looks like. If author supplied working example, almost anybody would be able to tailor and generalize it to his needs. \u2013 Tegiri Nenashi  Nov 17 '14 at 23:38 "], "answer_body": " If anyone is looking for something more advanced, try out RequireJS . You'll get added benefits such as dependency management, better concurrency, and avoid duplication (that is, retrieving a script more than once).  You can write your JavaScript files in \"modules\" and then reference them as dependencies in other scripts. Or you can use RequireJS as a simple \"go get this script\" solution.  Example:  Define dependencies as modules:  some-dependency.js  define(['lib/dependency1', 'lib/dependency2'], function (d1, d2) {\n\n     //Your actual script goes here.   \n     //The dependent scripts will be fetched if necessary.\n\n     return libraryObject;  //For example, jQuery object\n});  implementation.js is your \"main\" JavaScript file that depends on some-dependency.js  require(['some-dependency'], function(dependency) {\n\n    //Your script goes here\n    //some-dependency.js is fetched.   \n    //Then your script is executed\n});  Excerpt from the GitHub README:   RequireJS loads plain JavaScript files as well as more defined\n  modules. It is optimized for in-browser use, including in a Web\n  Worker, but it can be used in other JavaScript environments, like\n  Rhino and Node. It implements the Asynchronous Module API.  RequireJS uses plain script tags to load modules/files, so it should\n  allow for easy debugging. It can be used simply to load existing\n  JavaScript files, so you can add it to your existing project without\n  having to re-write your JavaScript files.  ...  ", "question_id": 950087}, {"answer_votes": "152", "answer_comments": [" I am trying this method, but is not working for me, the  element just does not appear in head tag. \u2013 juanpastas  Mar 12 '13 at 15:24 ", " @juanpastas - use jQuery.getScript , that way you don't have to worry about writing the plugin... \u2013 MattDMo  Jun 1 '13 at 17:44 ", " Does this technique really block until the imported script is both loaded and executed? \u2013 Flimm  Jun 18 '15 at 14:28 ", " Hmm, according to this article , appending a script element to head will cause it to run asynchronously, unless the async is specifically set to false . \u2013 Flimm  Jun 18 '15 at 15:36 ", " Shouldn't the script variable have html entities encoded? If the link contains the \" , code will break \u2013 Soaku  Aug 31 '17 at 13:55 "], "answer_body": " There actually is a way to load a JavaScript file not asynchronously, so you could use the functions included in your newly loaded file right after loading it, and I think it works in all browsers.  You need to use jQuery.append() on the <head> element of your page, that is:  $(\"head\").append('<script type=\"text/javascript\" src=\"' + script + '\"></script>');  However, this method also has a problem: if an error happens in the imported JavaScript file, Firebug (and also Firefox Error Console and Chrome Developer Tools as well) will report its place incorrectly, which is a big problem if you use Firebug to track JavaScript errors down a lot (I do). Firebug simply doesn't know about the newly loaded file for some reason, so if an error occurs in that file, it reports that it occurred in your main HTML file, and you will have trouble finding out the real reason for the error.  But if that is not a problem for you, then this method should work.  I have actually written a jQuery plugin called $.import_js() which uses this method:  (function($)\n{\n    /*\n     * $.import_js() helper (for JavaScript importing within JavaScript code).\n     */\n    var import_js_imported = [];\n\n    $.extend(true,\n    {\n        import_js : function(script)\n        {\n            var found = false;\n            for (var i = 0; i < import_js_imported.length; i++)\n                if (import_js_imported[i] == script) {\n                    found = true;\n                    break;\n                }\n\n            if (found == false) {\n                $(\"head\").append('<script type=\"text/javascript\" src=\"' + script + '\"></script>');\n                import_js_imported.push(script);\n            }\n        }\n    });\n\n})(jQuery);  So all you would need to do to import JavaScript is:   $.import_js('/path_to_project/scripts/somefunctions.js');   I also made a simple test for this at http://www.kipras.com/dev/import_js_test/ .  It includes a main.js file in the main HTML and then the script in main.js uses $.import_js() to import an additional file called included.js , which defines this function:  function hello()\n{\n    alert(\"Hello world!\");\n}  And right after including included.js , the hello() function is called, and you get the alert.  (This answer is in response to e-satis' comment). ", "question_id": 950087}, {"answer_votes": "128", "answer_comments": [" Good solution, the head include is async unfortunately, the ajax solution works. \u2013 Matteo Conta  Nov 25 '11 at 9:21 ", " As someone else mentioned, requirejs.org does this and also has a pre-compiler that puts js files together so they load faster. You may want to check it out. \u2013 Ariel  Jan 9 '12 at 6:57  ", " Found I could do debug it by adding this directive at the bottom of the file for Chrome :  //@ sourceURL=view_index.js \u2013 Todd Vance  Apr 11 '13 at 0:02 ", " unfortunatelly, async:false is now deprecated in jQuery. Might break in the future, so i'd avoid. \u2013 sqram  Oct 17 '13 at 1:45 ", " @katsh We are not using jqXHR objects here. Your quote doesn't seem to back up your previous comment stating that async: false supposedly is deprecated. It is not! As your quote states, only the jqXHR related stuff is. \u2013 Zero3  Apr 27 '15 at 16:50 "], "answer_body": " Another way, that in my opinion is much cleaner, is to make a synchronous Ajax request instead of using a <script> tag. Which is also how Node.js handles includes.  Here's an example using jQuery:  function require(script) {\n    $.ajax({\n        url: script,\n        dataType: \"script\",\n        async: false,           // <-- This is the key\n        success: function () {\n            // all good...\n        },\n        error: function () {\n            throw new Error(\"Could not load script \" + script);\n        }\n    });\n}  You can then use it in your code as you'd usually use an include:  require(\"/scripts/subscript.js\");  And be able to call a function from the required script in the next line:  subscript.doSomethingCool(); ", "question_id": 950087}, {"answer_votes": "81", "answer_comments": [" require/import on the jsfile has been way too long in the coming. (IMO). \u2013 rwheadon  Apr 10 '13 at 16:12 ", " @rwheadon yeah seems appalling that this isnt part of the language!  How js people get anything done is beyond me!  Im new to it and this seems the worst (of many) bits of madness \u2013 Jonny Leeds  Feb 7 '14 at 12:04 ", " @jonny-leeds Even without built-in module-loading, JavaScript in the browser is flexible enough that we can implement a library like RequireJS for our module management. \u2013 Keen  May 2 '14 at 15:06 ", " mid 2015- Still not implemented in any browsers, developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/\u2026 \u2013 scape  Jul 2 '15 at 16:14 ", " yeah you are right. now I'm starting to feel bad for this :(. Thouh, once implemented in all browsers this will be a great feature built in to javascript. \u2013 Imdad  Jul 7 '15 at 11:01  "], "answer_body": " There is a good news for you. Very soon you will be able to load JavaScript code easily. It will become a standard way of importing modules of JavaScript code and will be part of core JavaScript itself.  You simply have to write import cond from 'cond.js'; to load a macro named cond from a file cond.js .  So you don't have to rely upon any JavaScript framework nor do you have to explicitly make Ajax calls.  Refer to:   Static module resolution  Module loaders  ", "question_id": 950087}, {"answer_votes": "65", "answer_comments": [" It does work, but has serious issues because of the asynchonous loading. \u2013 e-satis  Jun 4 '09 at 12:11 ", " Um... which exactly? \u2013 Svitlana Maksymchuk  Jun 4 '09 at 12:14 ", " @e-satis - Actually, this is an advantage, a sync script would be blocking. Horses for courses, but 9 times in 10 you want the non-blocking option. \u2013 annakata  Jun 4 '09 at 12:15 ", " @Svitlana - script elements created like this are async. Currently this could be viewed as exploiting a loophole so it might not be future proof, I've not seen anything in any standard which clarifies this. \u2013 annakata  Jun 4 '09 at 12:16 ", " @e-satis asynchronous is good because it wont freeze your page. Use callback to be notified when it's done js.onload = callback; \u2013 Vitim.us  Aug 23 '13 at 15:40 "], "answer_body": " It is possible to dynamically generate a JavaScript tag and append it to HTML document from inside other JavaScript code. This will load targeted JavaScript file.  function includeJs(jsFilePath) {\n    var js = document.createElement(\"script\");\n\n    js.type = \"text/javascript\";\n    js.src = jsFilePath;\n\n    document.body.appendChild(js);\n}\n\nincludeJs(\"/path/to/some/file.js\"); ", "question_id": 950087}, {"answer_votes": "56", "answer_comments": [" ... but is not supported by any browser to date, according to the compatibility table on the page you linked to. \u2013 Zero3  Apr 22 '15 at 20:34  ", " You can now write ES6 code and compile it with Babel.js ( babeljs.io ) to whatever your preferred current module system is (CommonJS/AMD/UMD): babeljs.io/docs/usage/modules \u2013 Jeremy Harris  Jun 12 '15 at 20:35 ", " @Zero3 Apparently the new IE (Edge) is the only one \u2013 Julian Avar  Jun 25 '16 at 23:36 ", " is there a way to do this without ES6? Browser compatibility and those who don't have ES6 demands it. \u2013 IamGuest  Feb 2 '17 at 23:32 "], "answer_body": " Statement import is in ECMAScript 6.  Syntax  import name from \"module-name\";\nimport { member } from \"module-name\";\nimport { member as alias } from \"module-name\";\nimport { member1 , member2 } from \"module-name\";\nimport { member1 , member2 as alias2 , [...] } from \"module-name\";\nimport name , { member [ , [...] ] } from \"module-name\";\nimport \"module-name\" as name; ", "question_id": 950087}, {"answer_votes": "46", "answer_comments": [" Should be useful to add script.onload = callback; \u2013 Vitim.us  Aug 23 '13 at 15:37 ", " @SvitlanaMaksymchuk so, if I don't use var , the variable will be global ? \u2013 Francisco Corrales Morales  Mar 18 '14 at 15:22 ", " @FranciscoCorrales yes. \u2013 Christopher Chiche  May 21 '14 at 10:03 ", " It ends up in global with or without the var :) \u2013 Vedran Maricevic.  Jan 16 '15 at 8:27 ", " This fails if the page has no head . \u2013 Dan Dascalescu  Jul 8 '15 at 2:50 "], "answer_body": " Maybe you can use this function that I found on this page How do I include a JavaScript file in a JavaScript file? :  function include(filename)\n{\n    var head = document.getElementsByTagName('head')[0];\n\n    var script = document.createElement('script');\n    script.src = filename;\n    script.type = 'text/javascript';\n\n    head.appendChild(script)\n} ", "question_id": 950087}, {"answer_votes": "44", "answer_comments": [" Excellent function! Loads the JavaScript before any additional JS is written after the body. Very important when loading multiple scripts. \u2013 tfont  Feb 28 '14 at 21:50 ", " @heinob : What can I do to get it working for cross-domain? (loading script from http://web.archive.org/web/20140905044059/http://www.howtocreate.co.uk/operaStuff/userjs/aagmfunctions.js ) \u2013 user2284570  Sep 14 '14 at 2:20  ", " @user2284570: If you are the owner of the foreign domain: set `allow-origin' header in server answer. If you are'nt the owner: nothing. Sorry! That is cross-origin-policy. \u2013 heinob  Sep 14 '14 at 5:42 ", " @user2284570: I understand your comment in that way, that you are not the owner of the domain from which you want to load the script. In that case you only can load a script via an inserted <script> tag, not via XMLHttpRequest . \u2013 heinob  Sep 14 '14 at 16:10 ", " For those planning to use this in Firefox (say for imacros scripting), add this line to the top of the file: const XMLHttpRequest = Components.Constructor(\"@mozilla.org/xmlextras/xmlhttprequest;1\"); \u2013 Kwestion  Mar 16 '16 at 0:16  "], "answer_body": " Here is a synchronous version without jQuery :  function myRequire( url ) {\n    var ajax = new XMLHttpRequest();\n    ajax.open( 'GET', url, false ); // <-- the 'false' makes it synchronous\n    ajax.onreadystatechange = function () {\n        var script = ajax.response || ajax.responseText;\n        if (ajax.readyState === 4) {\n            switch( ajax.status) {\n                case 200:\n                    eval.apply( window, [script] );\n                    console.log(\"script loaded: \", url);\n                    break;\n                default:\n                    console.log(\"ERROR: script not loaded: \", url);\n            }\n        }\n    };\n    ajax.send(null);\n}  Note that to get this working cross-domain, the server will need to set allow-origin header in its response. ", "question_id": 950087}, {"answer_votes": "40", "answer_comments": [" jrburke wrote this as RequireJS. Github: requirejs.org/docs/requirements.html \u2013 Mike Caron  Sep 14 '11 at 17:14 ", " Isn't this putting the loaded script outside of the scope where require() is called? Seems like eval() is the only way to do it within scope. Or is there another way? \u2013 trusktr  Mar 31 '14 at 3:35  "], "answer_body": " I just wrote this JavaScript code (using Prototype for DOM manipulation):  var require = (function() {\n    var _required = {};\n    return (function(url, callback) {\n        if (typeof url == 'object') {\n            // We've (hopefully) got an array: time to chain!\n            if (url.length > 1) {\n                // Load the nth file as soon as everything up to the\n                // n-1th one is done.\n                require(url.slice(0, url.length - 1), function() {\n                    require(url[url.length - 1], callback);\n                });\n            } else if (url.length == 1) {\n                require(url[0], callback);\n            }\n            return;\n        }\n        if (typeof _required[url] == 'undefined') {\n            // Haven't loaded this URL yet; gogogo!\n            _required[url] = [];\n\n            var script = new Element('script', {\n                src: url,\n                type: 'text/javascript'\n            });\n            script.observe('load', function() {\n                console.log(\"script \" + url + \" loaded.\");\n                _required[url].each(function(cb) {\n                    cb.call(); // TODO: does this execute in the right context?\n                });\n                _required[url] = true;\n            });\n\n            $$('head')[0].insert(script);\n        } else if (typeof _required[url] == 'boolean') {\n            // We already loaded the thing, so go ahead.\n            if (callback) {\n                callback.call();\n            }\n            return;\n        }\n\n        if (callback) {\n            _required[url].push(callback);\n        }\n    });\n})();  Usage:  <script src=\"prototype.js\"></script>\n<script src=\"require.js\"></script>\n<script>\n    require(['foo.js','bar.js'], function () {\n        /* Use foo.js and bar.js here */\n    });\n</script>  Gist: http://gist.github.com/284442 . ", "question_id": 950087}, {"answer_votes": "32", "answer_comments": [" Damn nice! Some of the methods here work too, but under a dynamic setting this works the best. \u2013 tfont  Jul 13 '16 at 15:51 "], "answer_body": " Here's the generalized version of how Facebook does it for their ubiquitous Like button:    <script>\r\n  var firstScript = document.getElementsByTagName('script')[0],\r\n      js = document.createElement('script');\r\n  js.src = 'https://cdnjs.cloudflare.com/ajax/libs/Snowstorm/20131208/snowstorm-min.js';\r\n  js.onload = function () {\r\n    // do stuff with your dynamically loaded script\r\n    snowStorm.snowColor = '#99ccff';\r\n  };\r\n  firstScript.parentNode.insertBefore(js, firstScript);\r\n</script>     If it works for Facebook, it will work for you.  The reason why we look for the first script element instead of head or body is because some browsers don't create one if missing, but we're guaranteed to have a script element - this one. Read more at http://www.jspatterns.com/the-ridiculous-case-of-adding-a-script-element/ . ", "question_id": 950087}, {"answer_votes": "30", "answer_comments": [" \"it's part of the standard\" :D Good comments though. \u2013 Almo  Jun 5 '12 at 14:45 ", " ecmascript 6 seems like a real programming language. until then, we need to bear with it. \u2013 allenhwkim  Feb 23 '13 at 18:24 ", " See this answer below: stackoverflow.com/a/29688912/266535 \u2013 styfle  Sep 6 '16 at 19:13 "], "answer_body": " This is perhaps the biggest weakness of JavaScript in my opinion. It's caused me no end of problems over the years with dependency tracing. Anyhow, it does appear that the only practical solution is to use script includes in the HTML file and thus horribly making your JavaScript code dependent upon the user including the source you need and making reuse unfriendly.  Sorry if this comes across as a lecture ;) It's a (bad) habit of mine, but I want to make this point.  The problem comes back to the same as everything else with the web, the history of JavaScript. It really wasn't designed to be used in the widespread manner it's used in today. Netscape made a language that would allow you to control a few things, but they didn't envisage its widespread use for so many things as it is put to now and for one reason or another it's expanded from there, without addressing some of the fundamental weaknesses of the original strategy.  It's not alone of course. HTML wasn't designed for the modern webpage; it was designed to be a way of expressing the logic of a document, so that readers (browsers in the modern world) could display this in an applicable form that was within the capabilities of the system, and it took years for a solution (other than the hacks of MS and Netscape) to come along. CSS solves this problem, but it was a long time coming and even longer to get people to use it rather than the established BAD techniques. It happened though, praise be.  Hopefully JavaScript (especially now it's part of the standard) will develop to take on board the concept of proper modularity (as well as some other things) as every other (extant) programming language in the world does and this stupidity will go away. Until then you just have to not like it and lump it, I'm afraid. ", "question_id": 950087}, {"answer_votes": "24", "answer_comments": [" wouldn't document.write remove everything else? \u2013 Eisa Adil  Jan 14 '14 at 0:53 "], "answer_body": " If you want in pure JavaScript, you can use document.write.  document.write('<script src=\"myscript.js\" type=\"text/javascript\"></script>');  If you use the jQuery library, you can use the $.getScript method.  $.getScript(\"another_script.js\"); ", "question_id": 950087}, {"answer_votes": "23", "answer_comments": [" Since this post I came up with much better solution - CommonJS module compiler - github.com/dsheiko/cjsc So you can simply write CommonJs or NodeJs modules and access each other yet keeping them in isolated scopes. The benefits:  No need of multiple HTTP requests that affect performance You don't need manually wrapping you module code - it is responsibility of the compiler (so better source code readability)  You don't need any external libraries  It is compatible with UMD- and NodeJs modules (e.g. you can address jQuery, Backbone as modules without touching their code) \u2013 Dmitry Sheiko  Mar 7 '14 at 16:07 "], "answer_body": " Most of solutions shown here imply dynamical loading. I was searching instead for a compiler which assemble all the depended files into a single output file. The same as Less / Sass preprocessors deal with the CSS @import at-rule. Since I didn't find anything decent of this sort, I wrote a simple tool solving the issue.  So here is the compiler, https://github.com/dsheiko/jsic , which replaces $import(\"file-path\") with the requested file content securely. Here is the corresponding Grunt plugin: https://github.com/dsheiko/grunt-jsic .  On the jQuery master branch, they simply concatenate atomic source files into a single one starting with intro.js and ending with outtro.js . That doesn't suits me as it provides no flexibility on the source code design. Check out how it works with jsic:  src/main.js  var foo = $import(\"./Form/Input/Tel\");  src/Form/Input/Tel.js  function() {\n    return {\n          prop: \"\",\n          method: function(){}\n    }\n}  Now we can run the compiler:  node jsic.js src/main.js build/mail.js  And get the combined file  build/main.js  var foo = function() {\n    return {\n          prop: \"\",\n          method: function(){}\n    }\n}; ", "question_id": 950087}, {"answer_votes": "22", "answer_comments": [" Sounds like the point is to keep this all in javascript in the front end \u2013 Ariel  Sep 8 '11 at 18:23 ", " Thanks for reminding this. You can also have PHP write <script> tags in your HTML header, so that the js files you need (and only those) will be loaded. \u2013 Rolf  Dec 18 '13 at 12:38  "], "answer_body": " You can also assemble your scripts using PHP :  File main.js.php :  <?php\n    header('Content-type:text/javascript; charset=utf-8');\n    include_once(\"foo.js.php\");\n    include_once(\"bar.js.php\");\n?>\n\n// Main JavaScript code goes here ", "question_id": 950087}, {"answer_votes": "18", "answer_comments": [" the eval is what's wrong with it. From Crockford , \" eval is evil.  The eval function is the most misused feature of JavaScript. Avoid it. eval has aliases. Do not use the Function constructor. Do not pass strings to setTimeout or setInterval .\" If you haven't read his \"JavaScript: The Good Parts\" then go out and do it right now. You will not regret it. \u2013 MattDMo  Jun 1 '13 at 17:56 ", " @MattDMo \"Someone said it was bad\" isn't really an argument. \u2013 Casey  Sep 3 '14 at 19:05 ", " @emodendroket I take it you're not aware of who Douglas Crockford is. \u2013 MattDMo  Sep 3 '14 at 19:24 ", " @MattDMo I'm fully aware of who he is, but he's a human being, not a god. \u2013 Casey  Sep 3 '14 at 19:52 ", " @tggagne : What can I do to get it working for cross-domain? (loading script from http://web.archive.org/web/20140905044059/http://www.howtocreate.co.uk/operaStuff/userjs/aagmfunctions.js ) \u2013 user2284570  Sep 14 '14 at 2:18  "], "answer_body": " This should do:  xhr = new XMLHttpRequest();\nxhr.open(\"GET\", \"/soap/ajax/11.0/connection.js\", false);\nxhr.send();\neval(xhr.responseText); ", "question_id": 950087}, {"answer_votes": "16", "answer_comments": [" Browserify is far more popular than Sprockets. \u2013 Dan Dascalescu  Jul 8 '15 at 2:52 "], "answer_body": " Or rather than including at run time, use a script to concatenate prior to upload.  I use Sprockets (I don't know if there are others). You build your JavaScript code in separate files and include comments that are processed by the Sprockets engine as includes. For development you can include files sequentially, then for production to merge them...  See also:   Introducing Sprockets: JavaScript dependency management and concatenation  ", "question_id": 950087}, {"answer_votes": "15", "answer_comments": null, "answer_body": " If your intention to load the JavaScript file is using the functions from the imported/included file , you can also define a global object and set the functions as object items. For instance:  global.js  A = {};  file1.js  A.func1 = function() {\n  console.log(\"func1\");\n}  file2.js  A.func2 = function() {\n  console.log(\"func2\");\n}  main.js  A.func1();\nA.func2();  You just need to be careful when you are including scripts in an HTML file. The order should be as in below:  <head>\n  <script type=\"text/javascript\" src=\"global.js\"></script>\n  <script type=\"text/javascript\" src=\"file1.js\"></script>\n  <script type=\"text/javascript\" src=\"file2.js\"></script>\n  <script type=\"text/javascript\" src=\"main.js\"></script>\n</head> ", "question_id": 950087}, {"answer_votes": "12", "answer_comments": null, "answer_body": " In case you are using Web Workers and want to include additional scripts in the scope of the worker, the other answers provided about adding scripts to the head tag, etc. will not work for you.  Fortunately, Web Workers have their own importScripts function which is a global function in the scope of the Web Worker, native to the browser itself as it is part of the specification .  Alternatively, as the second highest voted answer to your question highlights , RequireJS can also handle including scripts inside a Web Worker (likely calling importScripts itself, but with a few other useful features). ", "question_id": 950087}, {"answer_votes": "10", "answer_comments": null, "answer_body": " I wrote a simple module that automates the job of importing/including module scripts in JavaScript. For detailed explanation of the code, refer to the blog post JavaScript require / import / include modules .  // ----- USAGE -----\n\nrequire('ivar.util.string');\nrequire('ivar.net.*');\nrequire('ivar/util/array.js');\nrequire('http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js');\n\nready(function(){\n    //Do something when required scripts are loaded\n});\n\n    //--------------------\n\nvar _rmod = _rmod || {}; //Require module namespace\n_rmod.LOADED = false;\n_rmod.on_ready_fn_stack = [];\n_rmod.libpath = '';\n_rmod.imported = {};\n_rmod.loading = {\n    scripts: {},\n    length: 0\n};\n\n_rmod.findScriptPath = function(script_name) {\n    var script_elems = document.getElementsByTagName('script');\n    for (var i = 0; i < script_elems.length; i++) {\n        if (script_elems[i].src.endsWith(script_name)) {\n            var href = window.location.href;\n            href = href.substring(0, href.lastIndexOf('/'));\n            var url = script_elems[i].src.substring(0, script_elems[i].length - script_name.length);\n            return url.substring(href.length+1, url.length);\n        }\n    }\n    return '';\n};\n\n_rmod.libpath = _rmod.findScriptPath('script.js'); //Path of your main script used to mark\n                                                   //the root directory of your library, any library.\n\n\n_rmod.injectScript = function(script_name, uri, callback, prepare) {\n\n    if(!prepare)\n        prepare(script_name, uri);\n\n    var script_elem = document.createElement('script');\n    script_elem.type = 'text/javascript';\n    script_elem.title = script_name;\n    script_elem.src = uri;\n    script_elem.async = true;\n    script_elem.defer = false;\n\n    if(!callback)\n        script_elem.onload = function() {\n            callback(script_name, uri);\n        };\n    document.getElementsByTagName('head')[0].appendChild(script_elem);\n};\n\n_rmod.requirePrepare = function(script_name, uri) {\n    _rmod.loading.scripts[script_name] = uri;\n    _rmod.loading.length++;\n};\n\n_rmod.requireCallback = function(script_name, uri) {\n    _rmod.loading.length--;\n    delete _rmod.loading.scripts[script_name];\n    _rmod.imported[script_name] = uri;\n\n    if(_rmod.loading.length == 0)\n        _rmod.onReady();\n};\n\n_rmod.onReady = function() {\n    if (!_rmod.LOADED) {\n        for (var i = 0; i < _rmod.on_ready_fn_stack.length; i++){\n            _rmod.on_ready_fn_stack[i]();\n        });\n        _rmod.LOADED = true;\n    }\n};\n\n_.rmod = namespaceToUri = function(script_name, url) {\n    var np = script_name.split('.');\n    if (np.getLast() === '*') {\n        np.pop();\n        np.push('_all');\n    }\n\n    if(!url)\n        url = '';\n\n    script_name = np.join('.');\n    return  url + np.join('/')+'.js';\n};\n\n//You can rename based on your liking. I chose require, but it\n//can be called include or anything else that is easy for you\n//to remember or write, except \"import\", because it is reserved\n//for future use.\nvar require = function(script_name) {\n    var uri = '';\n    if (script_name.indexOf('/') > -1) {\n        uri = script_name;\n        var lastSlash = uri.lastIndexOf('/');\n        script_name = uri.substring(lastSlash+1, uri.length);\n    } \n    else {\n        uri = _rmod.namespaceToUri(script_name, ivar._private.libpath);\n    }\n\n    if (!_rmod.loading.scripts.hasOwnProperty(script_name)\n     && !_rmod.imported.hasOwnProperty(script_name)) {\n        _rmod.injectScript(script_name, uri,\n            _rmod.requireCallback,\n                _rmod.requirePrepare);\n    }\n};\n\nvar ready = function(fn) {\n    _rmod.on_ready_fn_stack.push(fn);\n}; ", "question_id": 950087}, {"answer_votes": "10", "answer_comments": [" The problem with this answer is that it is not something like import . You need an HTML file to get stuff from one js file to another. \u2013 IamGuest  Feb 2 '17 at 23:34 ", " Agreed. What is your use case? \u2013 Manohar Reddy Poreddy  Feb 3 '17 at 4:27 "], "answer_body": " I had a simple issue, but I was baffled by responses to this question.  I had to use a variable (myVar1) defined in one JavaScript file (myvariables.js) in another JavaScript file (main.js).  For this I did as below:  Loaded the JavaScript code in the HTML file, in the correct order, myvariables.js first, then main.js:  <html>\n    <body onload=\"bodyReady();\" >\n\n        <script src=\"myvariables.js\" > </script>\n        <script src=\"main.js\" > </script>\n\n        <!-- Some other code -->\n    </body>\n</html>  File: myvariables.js  var myVar1 = \"I am variable from myvariables.js\";  File: main.js  // ...\nfunction bodyReady() {\n    // ...\n    alert (myVar1);    // This shows \"I am variable from myvariables.js\", which I needed\n    // ...\n}\n// ...  As you saw, I had use a variable in one JavaScript file in another JavaScript file, but I didn't need to include one in another. I just needed to ensure that the first JavaScript file loaded before the second JavaScript file, and, the first JavaScript file's variables are accessible in the second JavaScript file, automatically.  This saved my day. I hope this helps. ", "question_id": 950087}, {"answer_votes": "10", "answer_comments": [" This would be awesome if it were a node module. \u2013 b01  Apr 19 '15 at 19:07 ", " @b01 Sounds like a challenge ;) If only I had the time... perhaps someone else does? \u2013 Isaac Gregson  Apr 6 '16 at 10:05 "], "answer_body": " The @import syntax for achieving CSS-like JavaScript importing is possible using a tool such as Mixture via their special .mix file type (see here ). I imagine the application simply uses one of the aforementioned methods interally, though I don't know.  From the Mixture documentation on .mix files:   Mix files are simply .js or .css files with .mix. in the file name. A\n  mix file simply     extends the functionality of a normal style or\n  script file and allows you to import and combine.   Here's an example .mix file that combines multiple .js files into one:  // scripts-global.mix.js\n// Plugins - Global\n\n@import \"global-plugins/headroom.js\";\n@import \"global-plugins/retina-1.1.0.js\";\n@import \"global-plugins/isotope.js\";\n@import \"global-plugins/jquery.fitvids.js\";  Mixture outputs this as scripts-global.js and also as a minified version ( scripts-global.min.js ).  Note: I'm not in any way affiliated with Mixture, other than using it as a front-end development tool. I came across this question upon seeing a .mix JavaScript file in action (in one of the Mixture boilerplates) and being a bit confused by it (\"you can do this?\" I thought to myself). Then I realized that it was an application-specific file type (somewhat disappointing, agreed). Nevertheless, figured the knowledge might be helpful for others.  UPDATE : Mixture is now free (offline).  UPDATE : Mixture is now discontinued. Old mixture releases are still available ", "question_id": 950087}, {"answer_votes": "9", "answer_comments": [" This is the simplest code, but will fail in some edge cases when body doesn't yet exist or can't be modified. Also, it helps to explain answers. \u2013 Dan Dascalescu  Jul 8 '15 at 2:54  "], "answer_body": " var js = document.createElement(\"script\");\n\njs.type = \"text/javascript\";\njs.src = jsFilePath;\n\ndocument.body.appendChild(js); ", "question_id": 950087}, {"answer_votes": "9", "answer_comments": null, "answer_body": " My usual method is:  var require = function (src, cb) {\n    cb = cb || function () {};\n\n    var newScriptTag = document.createElement('script'),\n        firstScriptTag = document.getElementsByTagName('script')[0];\n    newScriptTag.src = src;\n    newScriptTag.async = true;\n    newScriptTag.onload = newScriptTag.onreadystatechange = function () {\n        (!this.readyState || this.readyState === 'loaded' || this.readyState === 'complete') && (cb());\n    };\n    firstScriptTag.parentNode.insertBefore(newScriptTag, firstScriptTag);\n}  It works great and uses no page-reloads for me. I've tried the AJAX method (one of the other answers) but it doesn't seem to work as nicely for me.  Here's an explanation of how the code works for those that are curious: essentially, it creates a new script tag (after the first one) of the URL. It sets it to asynchronous mode so it doesn't block the rest of the code, but calls a callback when the readyState (the state of the content to be loaded) changes to 'loaded'. ", "question_id": 950087}, {"answer_votes": "8", "answer_comments": null, "answer_body": " There is also Head.js . It is very easy to deal with:  head.load(\"js/jquery.min.js\",\n          \"js/jquery.someplugin.js\",\n          \"js/jquery.someplugin.css\", function() {\n  alert(\"Everything is ok!\");\n});  As you see, it's easier than Require.js and as convenient as jQuery's $.getScript method. It also has some advanced features, like conditional loading, feature detection and much more . ", "question_id": 950087}, {"answer_votes": "7", "answer_comments": [" @will, your solution looks much cleaner than mine and I'm worried I might have some errors if I use mine, as it makes use of .append(). So to use this, you can just call that function once for each plugin file you wish to include? \u2013 rgb_life  Dec 1 '11 at 5:55  "], "answer_body": " I came to this question because I was looking for a simple way to maintain a collection of useful JavaScript plugins. After seeing some of the solutions here, I came up with this:  1) Set up a file called \"plugins.js\" (or extentions.js or what have you). Keep your plugin files together with that one master file.  2) plugins.js will have an array called \"pluginNames[]\" that we will iterate over each(),\nthen append a  tag to the head for each plugin  //set array to be updated when we add or remove plugin files\n var pluginNames = [\"lettering\", \"fittext\", \"butterjam\", etc.];\n//one script tag for each plugin\n $.each(pluginNames, function(){\n   $('head').append('<script src=\"js/plugins/' + this + '.js\"></script>');\n });  3) manually call just the one file in your head:  <script src=\"js/plugins/plugins.js\"></script>  UPDATE: I found that even though all of the plugins were getting dropped into the head tag the way they ought to, they weren't always being run by the browser when you click into the page or refresh.  I found it's more reliable to just write the script tags in a PHP include. You only have to write it once and that's just as much work as calling the plugin using JavaScript. ", "question_id": 950087}, {"answer_votes": "7", "answer_comments": null, "answer_body": " I have created a function that will allow you to use similar verbiage to C#/Java to include a JavaScript file. I've tested it a little bit even from inside of another JavaScript file and it seems to work. It does require jQuery though for a bit of \"magic\" at the end.  I put this code in a file at the root of my script directory (I named it global.js , but you can use whatever you want. Unless I'm mistaken this and jQuery should be the only required scripts on a given page. Keep in mind this is largely untested beyond some basic usage, so there may or may not be any issues with the way I've done it; use at your own risk yadda yadda I am not responsible if you screw anything up yadda yadda:  /**\n* @fileoverview This file stores global functions that are required by other libraries.\n*/\n\nif (typeof(jQuery) === 'undefined') {\n    throw 'jQuery is required.';\n}\n\n/** Defines the base script directory that all .js files are assumed to be organized under. */\nvar BASE_DIR = 'js/';\n\n/**\n* Loads the specified file, outputting it to the <head> HTMLElement.\n*\n* This method mimics the use of using in C# or import in Java, allowing\n* JavaScript files to \"load\" other JavaScript files that they depend on\n* using a familiar syntax.\n*\n* This method assumes all scripts are under a directory at the root and will\n* append the .js file extension automatically.\n*\n* @param {string} file A file path to load using C#/Java \"dot\" syntax.\n*\n* Example Usage:\n* imports('core.utils.extensions');\n* This will output: <script type=\"text/javascript\" src=\"/js/core/utils/extensions.js\"></script>\n*/\nfunction imports(file) {\n    var fileName = file.substr(file.lastIndexOf('.') + 1, file.length);\n\n    // Convert PascalCase name to underscore_separated_name\n    var regex = new RegExp(/([A-Z])/g);\n    if (regex.test(fileName)) {\n        var separated = fileName.replace(regex, \",$1\").replace(',', '');\n        fileName = separated.replace(/[,]/g, '_');\n    }\n\n    // Remove the original JavaScript file name to replace with underscore version\n    file = file.substr(0, file.lastIndexOf('.'));\n\n    // Convert the dot syntax to directory syntax to actually load the file\n    if (file.indexOf('.') > 0) {\n        file = file.replace(/[.]/g, '/');\n    }\n\n    var src = BASE_DIR + file + '/' + fileName.toLowerCase() + '.js';\n    var script = document.createElement('script');\n    script.type = 'text/javascript';\n    script.src = src;\n\n    $('head').find('script:last').append(script);\n} ", "question_id": 950087}, {"answer_votes": "7", "answer_comments": [" The jQuery docs say that the callback passed to getScript will run \"once the script has been loaded but not necessarily executed\". \u2013 Flimm  Jun 18 '15 at 14:47 "], "answer_body": " Better use the jQuery way. To delay the ready event, first call $.holdReady(true) .\nExample ( source ):  $.holdReady(true);\n$.getScript(\"myplugin.js\", function() {\n    $.holdReady(false);\n}); ", "question_id": 950087}, {"answer_votes": "7", "answer_comments": null, "answer_body": " This script will add a JavaScript file to the top of any other <script> tag:  (function () {\n    var li = document.createElement('script'); \n    li.type = 'text/javascript'; \n    li.src= \"http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js\"; \n    li.async=true; \n    var s = document.getElementsByTagName('script')[0]; \n    s.parentNode.insertBefore(li, s);\n})(); ", "question_id": 950087}, {"answer_votes": "7", "answer_comments": [" Nice. Good solution. \u2013 Neal  Jul 20 '17 at 18:25 ", " Concise and only needs ES5, and elegantly avoids formally having a call back. Thank you Dmitry! \u2013 Eureka  Oct 2 '17 at 7:08  ", " Wow, works in the browser without server.  pi.js = simply var pi = 3.14 .  call the loadJS() function via loadJs(\"pi.js\").then(function(){                     console.log(pi);                     }); \u2013 zipzit  Nov 7 '17 at 2:43  "], "answer_body": " In modern language it would be  function loadJs( url ){\n  return new Promise( resolve => {\n    const script = document.createElement( \"script\" );\n    script.src = url;\n    script.onload = resolve;\n    document.head.appendChild( script );\n  });\n} ", "question_id": 950087}, {"answer_votes": "6", "answer_comments": null, "answer_body": " Here is a Grunt plugin allowing you to use @import \"path/to/file.js\"; syntax in any file including JavaScript files. It can be paired with uglify or watch or any other plugin.  It can be installed with npm install: https://npmjs.org/package/grunt-import ", "question_id": 950087}, {"answer_votes": "6", "answer_comments": [" This is exactly what the currently accepted answer states: just not enough. \u2013 IamGuest  Feb 2 '17 at 23:31 ", " The main difference is that if there is a missing dependency it will add the script tag for the dependency, then also add the script tag for the calling file, and throw an error which halts execution. This causes the scripts to be processed and ran in the correct order and removes the need for callbacks. So the dependent script will be loaded and executed before the calling script while supporting nesting. \u2013 curlyhairedgenius  Feb 17 '17 at 0:19 "], "answer_body": " There are a lot of potential answers for this question. My answer is obviously based on a number of them. Thank you for all the help. This is what I ended up with after reading through all the answers.  The problem with $.getScript and really any other solution that requires a callback when loading is complete is that if you have multiple files that use it and depend on each other you no longer have a way to know when all scripts have been loaded (once they are nested in multiple files).  Example:  file3.js  var f3obj = \"file3\";\n\n// Define other stuff  file2.js:  var f2obj = \"file2\";\n$.getScript(\"file3.js\", function(){\n\n    alert(f3obj);\n\n    // Use anything defined in file3.\n});  file1.js:  $.getScript(\"file2.js\", function(){\n    alert(f3obj); //This will probably fail because file3 is only guaranteed to have loaded inside the callback in file2.\n    alert(f2obj);\n\n    // Use anything defined in the loaded script...\n});  You are right when you say that you could specify Ajax to run synchronously or use XMLHttpRequest , but the current trend appears to be to deprecate synchronous requests, so you may not get full browser support now or in the future.  You could try to use $.when to check an array of deferred objects, but now you are doing this in every file and file2 will be considered loaded as soon as the $.when is executed not when the callback is executed, so file1 still continues execution before file3 is loaded. This really still has the same problem.  I decided to go backwards instead of forwards. Thank you document.writeln . I know it's taboo, but as long as it is used correctly this works well. You end up with code that can be debugged easily, shows in the DOM correctly and can ensure the order the dependencies are loaded correctly.  You can of course use $(\"body\").append(), but then you can no longer debug correctly any more.  NOTE: You must use this only while the page is loading, otherwise you get a blank screen. In other words, always place this before / outside of document.ready . I have not tested using this after the page is loaded in a click event or anything like that, but I am pretty sure it'll fail.  I liked the idea of extending jQuery, but obviously you don't need to.  Before calling document.writeln , it checks to make sure the script has not already been loading by evaluating all the script elements.  I assume that a script is not fully executed until its document.ready event has been executed. (I know using document.ready is not required, but many people use it, and handling this is a safeguard.)  When the additional files are loaded the document.ready callbacks will get executed in the wrong order. To address this when a script is actually loaded, the script that imported it is re-imported itself and execution halted. This causes the originating file to now have its document.ready callback executed after any from any scripts that it imports.  Instead of this approach you could attempt to modify the jQuery readyList , but this seemed like a worse solution.  Solution:  $.extend(true,\n{\n    import_js : function(scriptpath, reAddLast)\n    {\n        if (typeof reAddLast === \"undefined\" || reAddLast === null)\n        {\n            reAddLast = true; // Default this value to true. It is not used by the end user, only to facilitate recursion correctly.\n        }\n\n        var found = false;\n        if (reAddLast == true) // If we are re-adding the originating script we do not care if it has already been added.\n        {\n            found = $('script').filter(function () {\n                return ($(this).attr('src') == scriptpath);\n            }).length != 0; // jQuery to check if the script already exists. (replace it with straight JavaScript if you don't like jQuery.\n        }\n\n        if (found == false) {\n\n            var callingScriptPath = $('script').last().attr(\"src\"); // Get the script that is currently loading. Again this creates a limitation where this should not be used in a button, and only before document.ready.\n\n            document.writeln(\"<script type='text/javascript' src='\" + scriptpath + \"'></script>\"); // Add the script to the document using writeln\n\n            if (reAddLast)\n            {\n                $.import_js(callingScriptPath, false); // Call itself with the originating script to fix the order.\n                throw 'Readding script to correct order: ' + scriptpath + ' < ' + callingScriptPath; // This halts execution of the originating script since it is getting reloaded. If you put a try / catch around the call to $.import_js you results will vary.\n            }\n            return true;\n        }\n        return false;\n    }\n});  Usage:  file3:  var f3obj = \"file3\";\n\n// Define other stuff\n$(function(){\n    f3obj = \"file3docready\";\n});  file2:  $.import_js('js/file3.js');\nvar f2obj = \"file2\";\n$(function(){\n    f2obj = \"file2docready\";\n});  file1:  $.import_js('js/file2.js');\n\n// Use objects from file2 or file3\nalert(f3obj); // \"file3\"\nalert(f2obj); // \"file2\"\n\n$(function(){\n    // Use objects from file2 or file3 some more.\n    alert(f3obj); //\"file3docready\"\n    alert(f2obj); //\"file2docready\"\n}); ", "question_id": 950087}, {"answer_votes": "6", "answer_comments": null, "answer_body": " Here's a workaround for browsers (not Node.js) using HTML imports.  First, all JavaScript classes and scripts are not in .js files, but in .js.html files (the .js . html is just to recognize between HTML pages and complete JavaScript script/classes), inside <script> tags, like this:  MyClass.js.html :  <script>\n   class MyClass {\n\n      // Your code here..\n\n   }\n\n</script>  Then if you wish to import your class, you just need to use HTML imports:  <link rel=\"import\" href=\"relative/path/to/MyClass.js.html\"/>\n\n<script>\n   var myClass = new MyClass();\n   // Your code here..\n</script>  EDIT : HTML imports will be dropped  HTML imports and ES6 modules are both already well implemented in most browser accross the world . But since HTML imports are definitly not going to be part of the standards, unlike ES6 modules, its development will be dropped, then you should definitly start to use ES6 modules. ", "question_id": 950087}, {"answer_votes": "5", "answer_comments": null, "answer_body": " Keep it nice, short, simple, and maintainable! :]  // 3rd party plugins / script (don't forget the full path is necessary)\nvar FULL_PATH = '', s =\n[\n    FULL_PATH + 'plugins/script.js'      // Script example\n    FULL_PATH + 'plugins/jquery.1.2.js', // jQuery Library \n    FULL_PATH + 'plugins/crypto-js/hmac-sha1.js',      // CryptoJS\n    FULL_PATH + 'plugins/crypto-js/enc-base64-min.js'  // CryptoJS\n];\n\nfunction load(url)\n{\n    var ajax = new XMLHttpRequest();\n    ajax.open('GET', url, false);\n    ajax.onreadystatechange = function ()\n    {\n        var script = ajax.response || ajax.responseText;\n        if (ajax.readyState === 4)\n        {\n            switch(ajax.status)\n            {\n                case 200:\n                    eval.apply( window, [script] );\n                    console.log(\"library loaded: \", url);\n                    break;\n                default:\n                    console.log(\"ERROR: library not loaded: \", url);\n            }\n        }\n    };\n    ajax.send(null);\n}\n\n // initialize a single load \nload('plugins/script.js');\n\n// initialize a full load of scripts\nif (s.length > 0)\n{\n    for (i = 0; i < s.length; i++)\n    {\n        load(s[i]);\n    }\n}  This code is simply a short functional example that could require additional feature functionality for full support on any (or given) platform. ", "question_id": 950087}, {"answer_votes": "5", "answer_comments": null, "answer_body": " I basically do it like the following, creating a new element and attach that to head:  var x = document.createElement('script');\nx.src = 'http://example.com/test.js';\ndocument.getElementsByTagName(\"head\")[0].appendChild(x);  In jQuery :  // jQuery\n$.getScript('/path/to/imported/script.js', function()\n{\n    // Script is now loaded and executed.\n    // Put your dependent JavaScript code here.\n}); ", "question_id": 950087}, {"answer_votes": "4", "answer_comments": null, "answer_body": " In a past project I had quite a bit of success using ajile to do imports of reusable JavaScript files. I always wished there was a feature for this built into JavaScript itself. ", "question_id": 950087}, {"answer_votes": "4", "answer_comments": null, "answer_body": " Now, I may be totally misguided, but here's what I've recently started doing... \nStart and end your JavaScript files with a carriage return, place in the PHP script, followed by one more carriage return.\nThe JavaScript comment \"//\" is ignored by PHP so the inclusion happens anyway. The purpose for the carriage returns is so that the first line of your included JavaScript isn't commented out.  Technically, you don't need the comment, but it posts errors in Dreamweaver that annoy me. If you're scripting in an IDE that doesn't post errors, you shouldn't need the comment or the carriage returns.  \\n\n//<?php require_once(\"path/to/javascript/dependency.js\"); ?>\n\nfunction myFunction(){\n    // stuff\n}\n\\n ", "question_id": 950087}, {"answer_votes": "4", "answer_comments": null, "answer_body": " It's very simple. Suppose you want to import file A.js in file B.js.  Now it's sure you have linked B.js in an HTML file, then just link A.js before B.js in that HTML file. Then the public variables of A.js will be available inside the B.js  This does not require a complicated answer. ", "question_id": 950087}, {"answer_votes": "4", "answer_comments": [" Please explain your down vote. This is a method that can include a javascript file in another javascript file. This is what the question is asking and is a method that no one else has mentioned. \u2013 gm2008  Apr 14 '17 at 8:07 "], "answer_body": " If you use Angular, then a plugin module $ocLazyLoad can help you to do that.  Here are some quotes from its documentation:   Load one or more modules & components with multiple files:  $ocLazyLoad.load(['testModule.js', 'testModuleCtrl.js', 'testModuleService.js']);  Load one or more modules with multiple files and specify a type where necessary:\n  Note: When using the requireJS style formatting (with js! at the beginning for example), do not specify a file extension. Use one or the other.  $ocLazyLoad.load([\n  'testModule.js',\n   {type: 'css', path: 'testModuleCtrl'},\n   {type: 'html', path: 'testModuleCtrl.html'},\n   {type: 'js', path: 'testModuleCtrl'},\n   'js!testModuleService',\n   'less!testModuleLessFile'\n]);  You can load external libs (not angular):  $ocLazyLoad.load(['testModule.js', \n   'bower_components/bootstrap/dist/js/bootstrap.js', 'anotherModule.js']);  You can also load css and template files:  $ocLazyLoad.load([\n     'bower_components/bootstrap/dist/js/bootstrap.js',\n     'bower_components/bootstrap/dist/css/bootstrap.css',\n     'partials/template1.html'\n ]);  ", "question_id": 950087}, {"answer_votes": "3", "answer_comments": [" Unfortunately, it's not really under development any more , and there's no guarantee that some future browser or JS engine or language version won't break it. You should try to be as up-to-date as possible with JS, although there is something to be said for stability. Even though this could be a good option for somebody, I'd much rather steer them toward RequireJS or jQuery.getScript() , both of which are stable and under constant development. \u2013 MattDMo  Jun 1 '13 at 18:02  "], "answer_body": " Don't forget to check out LAB.js !  <script type=\"text/javascript\">\n       $LAB\n       .script(\"jquery-1.8.3.js\").wait()\n       .script(\"scripts/clientscript.js\");      \n</script> ", "question_id": 950087}, {"answer_votes": "3", "answer_comments": null, "answer_body": " var s=[\"Hscript.js\",\"checkRobert.js\",\"Hscript.js\"];\nfor(i=0;i<s.length;i++){\n  var script=document.createElement(\"script\");\n  script.type=\"text/javascript\";\n  script.src=s[i];\n  document.getElementsByTagName(\"head\")[0].appendChild(script)\n}; ", "question_id": 950087}, {"answer_votes": "3", "answer_comments": null, "answer_body": " I also wrote a JavaScript dependency manager for Java web applications: JS-Class-Loader . ", "question_id": 950087}, {"answer_votes": "3", "answer_comments": [" script.onreadystatechange will never fire. It's specific to XMLHttpRequest . If it would fire, for example because you were actually loading the script using XMLHttpRequest , it would cause your callback to be called too often. So you should remove that line. \u2013 Julian  Aug 7 '16 at 21:27 "], "answer_body": " I have the requirement to asynchronously load an array of JavaScript files and at the final make a callback. Basically my best approach is the following:  // Load a JavaScript file from other JavaScript file\nfunction loadScript(urlPack, callback) {\n    var url = urlPack.shift();\n    var subCallback;\n\n    if (urlPack.length == 0) subCallback = callback;\n    else subCallback = function () {\n        console.log(\"Log script: \" + new Date().getTime());\n        loadScript(urlPack, callback);\n    }\n\n    // Adding the script tag to the head as suggested before\n    var head = document.getElementsByTagName('head')[0];\n    var script = document.createElement('script');\n    script.type = 'text/javascript';\n    script.src = url;\n\n    // Then bind the event to the callback function.\n    // There are several events for cross browser compatibility.\n    script.onreadystatechange = subCallback;\n    script.onload = subCallback;\n\n    // Fire the loading\n    head.appendChild(script);\n}  Example:  loadScript(\n[\n    \"js/DataTable/jquery.dataTables.js\",\n    \"js/DataTable/dataTables.bootstrap.js\",\n    \"js/DataTable/dataTables.buttons.min.js\",\n    \"js/DataTable/dataTables.colReorder.min.js\",\n    \"js/DataTable/dataTables.fixedHeader.min.js\",\n    \"js/DataTable/buttons.bootstrap.min.js\",\n    \"js/DataTable/buttons.colVis.min.js\",\n    \"js/DataTable/buttons.html5.min.js\"\n], function() { gpLoad(params); });  The second script will not load until the first is completely loaded, and so...  Results:  ", "question_id": 950087}, {"answer_votes": "2", "answer_comments": [" just using for node+react test! \u2013 xgqfrms  Oct 4 '16 at 13:55 "], "answer_body": " Here is maybe another way! In Node.js you do that just like the following! http://requirejs.org/docs/node.html  sub.js  module.exports = {\n  log: function(string) {\n    if(console) console.log(string);\n  }\n  mylog: function(){\n    console.log('just for log test!');\n  }\n}  main.js  var mylog =require('./sub');\n\nmylog.log('Hurray, it works! :)');\nmylog.mylog(); ", "question_id": 950087}, {"answer_votes": "2", "answer_comments": null, "answer_body": " Another approach is to use HTML imports. These can contain script references as well as stylesheet references.  You can just link an HTML file like  <link rel=\"import\" href=\"vendorScripts.html\"/>  Within the vendorScripts.html file you can include your script references like:  <script src=\"scripts/vendors/jquery.js\"></script>\n<script src=\"scripts/vendors/bootstrap.js\"></script>\n<script src=\"scripts/vendors/angular.js\"></script>\n<script src=\"scripts/vendors/angular-route.js\"></script>  Look at https://www.html5rocks.com/en/tutorials/webcomponents/imports/ for more details.  Unfortunately this only works in Chrome. ", "question_id": 950087}, {"answer_votes": "2", "answer_comments": null, "answer_body": " You can't import, but you can reference.  PhpShtorm IDE. To reference, in one .js file to another .js , just add this to the top of the file:  <reference path=\"../js/file.js\" />  Of course, you should use your own PATH to the JavaScript file.  I don't know if it will work in other IDEs. Probably yes, just try. It should work in Visual Studio too. ", "question_id": 950087}, {"answer_votes": "-1", "answer_comments": [" Why was this downvoted? I'm no JS expert, but wouldn't this work? \u2013 Gottlieb Notschnabel  Oct 20 '13 at 11:35 ", " Because if the page is already done loading when it is executing, or if it is executed because of a user action, then it will clear the page first. \u2013 SevenBits  Oct 20 '13 at 11:56 ", " @SevenBits is correct and this answer is buggy, see this page: developer.mozilla.org/en-US/docs/Web/API/Document/write \u2013 Flimm  Jun 18 '15 at 14:52 ", " @Flimm you could have linked to the page on writeln instead, but it's basically the same. \u2013 gcampbell  Jun 22 '16 at 19:21 "], "answer_body": " function include(js)\n{\n    document.writeln(\"<script src=\" + js + \"><\" + \"/script>\");\n} ", "question_id": 950087}, {"answer_votes": "-1", "answer_comments": [" Is it plain javascript? \u2013 Washington Guedes  Oct 20 '16 at 11:52 ", " yes it's modern javascript (es6) and it's taking over real fast \u2013 Thielicious  Oct 31 '16 at 14:16 "], "answer_body": " var xxx = require(\"../lib/your-library.js\")  or  import xxx from \"../lib/your-library.js\" //get default export\nimport {specificPart} from '../lib/your-library.js' //get named export\nimport * as _name from '../lib/your-library.js'  //get full export to alias _name ", "question_id": 950087}], "question_body": " Is there something in JavaScript similar to in CSS that allows you to include a JavaScript file inside another JavaScript file? ", "question_code": ["@import"], "question_id": 950087}