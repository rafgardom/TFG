{"question_comments": [" just tested: your way is actually the fastest for across browsers: jsperf.com/find-element-in-obj-vs-array/2 (apart from pre-saving a.length in a variable) while using indexOf (as in $.inArray) is much slower \u2013 J\u00f6rn Berkefeld  Jul 2 '12 at 11:56 ", " many have replied that the Array#indexOf is your best choice here. But if you want something that can be correctly cast to Boolean, use this: will return 0 which will evaluate as false, whereas will return -3 which will evaluate as true. \u2013 lordvlad  Oct 2 '13 at 7:59 ", " is not what you want to use to convert to a boolean, for that you need . But in this case you want to check equality with -1, s o the function might end  is a binary not, it will invert each bit of the value individually. \u2013 mcfedr  Jun 20 '14 at 12:49 ", " IE9 supports as per w3schools.com/jsref/jsref_indexof_array.asp . If older browser better approach is to define for function as given in Array.indexOf in Internet Explorer \u2013 Lijo  Jan 21 '15 at 21:42  ", " @Iordvlad will actually return -1 . As @mcfedr pointed out, is the bitwise-NOT operator , see ES5 11.4.8. Thing is, since the binary representation of consists of only 1's, it's complement is , which evaluates as false. The complement of any other number will be non-zero, hence true. So, works just fine and is often used in conjunction with . \u2013 mknecht  Mar 14 '15 at 5:35  "], "question_title": "How do I check if an array includes an object in JavaScript?", "answers": [{"answer_votes": "3502", "answer_comments": [" MooTools also has Array.contains that returns a boolean, which sounds like the real question here. \u2013 Ryan Florence  Jun 8 '10 at 14:10 ", " prototype also has Array.include that returns a boolean \u2013 user102008  Sep 10 '10 at 22:54 ", " If you are using a good browser, you can just use array.indexOf(object) != -1 \u2013 Sam Soffes  Oct 6 '10 at 16:17 ", " Also, dont use indexOf alone as a condition, because the first element will return 0 and will be evaluated as falsy \u2013 plus-  Feb 29 '12 at 17:17 ", " inArray is a terrible name for a function that returns the index of the element, and -1 if it doesn't exist. I would expect a boolean to be returned. \u2013 Tim  Jul 22 '12 at 9:45 "], "answer_body": " Current browsers have Array#includes , which does exactly that, is widely supported , and has a polyfill for older browsers.  You can also use Array#indexOf , which is less direct, but doesn't require Polyfills for out of date browsers.  jQuery offers $.inArray , which is functionally equivalent to Array#indexOf .  underscore.js , a JavaScript utility library, offers _.contains(list, value) , alias _.include(list, value) , both of which use indexOf internally if passed a JavaScript array.  Some other frameworks offer similar methods:   Dojo Toolkit: dojo.indexOf(array, value, [fromIndex, findLast])  Prototype: array.indexOf(value)  MooTools: array.indexOf(value)  MochiKit: findValue(array, value)  MS Ajax: array.indexOf(value)  Ext: Ext.Array.contains(array, value)  Lodash: _.includes(array, value, [from]) (is _.contains prior 4.0.0)  ECMAScript 2016: array.includes(value)   Notice that some frameworks implement this as a function, while others add the function to the array prototype. "}, {"answer_votes": "345", "answer_comments": [" But be careful: stackoverflow.com/questions/237104/javascript-array-containsobj/\u2026 \u2013 MatrixFrog  Aug 12 '10 at 23:16 ", " \"Proven\" is a strong word. JS engines constantly improve, and execution time measured 3 years ago is terribly outdated. \u2013 orip  Nov 20 '11 at 8:09 ", " @Damir - I agree. Perhaps change the sample to use indexOf if available, just so people copy-pasting this code blindly will get the best performance they can. \u2013 orip  Nov 20 '11 at 12:45 ", " @cbmeeks yeah, care is definitely needed. It was probably a case of doing for (o in array) which shouldn't be done when looping through the array generally... \u2013 Damir Zeki\u0107  Oct 12 '12 at 13:18 ", " The best way to do this is check if [1, 2, 3].indexOf(1) > -1 \u2013 Devin G Rhode  Oct 28 '12 at 23:25 "], "answer_body": " Update: As @orip mentions in comments, the linked benchmark was done in 2008, so results may not be relevant for modern browsers. However, you probably need this to support non-modern browsers anyway and they probably haven't been updated since. Always test for yourself.  As others have said, the iteration through the array is probably the best way, but it has been proven that a decreasing while loop is the fastest way to iterate in JavaScript. So you may want to rewrite your code as follows:  function contains(a, obj) {\n    var i = a.length;\n    while (i--) {\n       if (a[i] === obj) {\n           return true;\n       }\n    }\n    return false;\n}  Of course, you may as well extend Array prototype:  Array.prototype.contains = function(obj) {\n    var i = this.length;\n    while (i--) {\n        if (this[i] === obj) {\n            return true;\n        }\n    }\n    return false;\n}  And now you can simply use the following:  alert([1, 2, 3].contains(2)); // => true\nalert([1, 2, 3].contains('2')); // => false "}, {"answer_votes": "140", "answer_comments": [" actually, there is an example of the an implementation of the indexOf extension for browsers that do not support it on the developer.mozilla.org page you linked to. \u2013 Lloyd Cotten  Mar 24 '09 at 21:24 ", " actually, if you add indexof to the prototype of Array for browsers that don't support it (i.e. IE7) they will also try to loop over this function when looping through the items in the array. nasty. \u2013 CpILL  Jul 11 '12 at 9:13 ", " IE9 now supports this \u2013 Liam  May 29 '14 at 14:33 "], "answer_body": " indexOf maybe, but it's a \"JavaScript extension to the ECMA-262 standard; as such it may not be present in other implementations of the standard.\"  Example:  [1, 2, 3].indexOf(1) => 0\n[\"foo\", \"bar\", \"baz\"].indexOf(\"bar\") => 1\n[1, 2, 3].indexOf(4) => -1  AFAICS Microsoft does not offer some kind of alternative to this, but you can add similar functionality to arrays in Internet Explorer (and other browsers that don't support indexOf ) if you want to, as a quick Google search reveals (for example, this one ). "}, {"answer_votes": "115", "answer_comments": [" Not supported for IE and Microsfot Edge (2015) ( developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/\u2026 ) \u2013 Adriano Resende  Nov 5 '15 at 23:04  ", " Also relevant, the ES7 compatibility table (looks like chrome supports it now) \u2013 styfle  Mar 11 '16 at 20:25  ", " Worth noting that this is supported in Node 6+, according to node.green \u2013 Ryan  Mar 20 '17 at 4:32 "], "answer_body": " ECMAScript 7 introduces Array.prototype.includes .  It can be used like this:  [1, 2, 3].includes(2); // true\n[1, 2, 3].includes(4); // false  It also accepts an optional second argument fromIndex :  [1, 2, 3].includes(3, 3); // false\n[1, 2, 3].includes(3, -1); // true  Unlike indexOf , which uses Strict Equality Comparison , includes compares using SameValueZero equality algorithm. That means that you can detect if an array includes a NaN :  [1, 2, NaN].includes(NaN); // true  Also unlike indexOf , includes does not skip missing indices:  new Array(5).includes(undefined); // true  Currently it's still a draft but can be polyfilled to make it work on all browsers. "}, {"answer_votes": "92", "answer_comments": [" This part I dont understand \"!!~\". And I think this will not work in IE8 because IE8 doesnt support indexOf() on Array object. \u2013 svlada  Jun 18 '12 at 5:29  ", " \"~\" is an operator that floors, inverts and subtracts 1 from a number. indexOf returns -1 if it fails, so \"~\" turns -1 into \"0\". using \"!!\" turns numbers into boleans (!!0===false) \u2013 william malo  Jun 19 '12 at 14:41  ", " the same performance as !=-1 jsperf.com/indexof-check \u2013 aelgoa  Feb 6 '13 at 12:28 ", " Just a bit of throw-up, right in my mouth.  Absolutely unprofessional code. \u2013 Michael Cole  Oct 22 '15 at 21:28 ", " I'd call the lack of knowledge about the effects of boolean operators unprofessional. But I agree about the value of readable code, I would certainly wrap this in a clearly labelled function. And that's exactly what most major JS frameworks do. \u2013 Fx32  Jan 19 '16 at 11:18 "], "answer_body": " b is the value, and a is the array. It returns true or false :  function(a, b) {\n    return a.indexOf(b) != -1\n} "}, {"answer_votes": "61", "answer_comments": [" This looks great, but a little confused:  * Aren't the tests on lines 1 and 3 equivalent? * Wouldn't it be better to test the prototype, and add the function to Array.prototype if necessary? \u2013 Avi Flax  Jul 11 '10 at 12:31 ", " They aren't equvialent. [].indexOf is a shorthand for Array.prototype.indexOf .  Us paranoid-defensive Javascript programmers avoid extending native prototypes at all cost. \u2013 M\u00e1r \u00d6rlygsson  Jul 14 '10 at 12:03 ", " Isn't [].indexOf creating a new array and then accessing indexOf , whilst Array.prototype.indexOf just accesses the prototype directly? \u2013 alex  Mar 8 '11 at 11:47 ", " @alex yes [].indexOf === Array.prototype.indexOf (try it out in FireBug), but conversely [].indexOf !== Array.indexOf . \u2013 M\u00e1r \u00d6rlygsson  Mar 11 '11 at 13:32 "], "answer_body": " Here's a JavaScript 1.6 compatible implementation of Array.indexOf :  if (!Array.indexOf)\n{\n  Array.indexOf = [].indexOf ?\n      function (arr, obj, from) { return arr.indexOf(obj, from); }:\n      function (arr, obj, from) { // (for IE6)\n        var l = arr.length,\n            i = from ? parseInt( (1*from) + (from<0 ? l:0), 10) : 0;\n        i = i<0 ? 0 : i;\n        for (; i<l; i++) {\n          if (i in arr  &&  arr[i] === obj) { return i; }\n        }\n        return -1;\n      };\n} "}, {"answer_votes": "43", "answer_comments": [" x ? true : false is usually redundant. It is here. \u2013 Ryan \u2666  Feb 26 '14 at 16:38 ", " @minitech Why do you say it is redundant? \u2013 Mat\u00edas C\u00e1nepa  May 3 '14 at 15:40 ", " array.indexOf(search) >= 0 is already a boolean. Just return array.indexOf(search) >= 0 . \u2013 Ryan \u2666  May 3 '14 at 17:38 ", " @minitech well thanks! Actually I didn't know that such a construction could be returned. TIL something new. \u2013 Mat\u00edas C\u00e1nepa  Jul 29 '14 at 18:25 ", " Literally any construct in javascript can be returned \u2013 B T  Jan 15 '15 at 22:20 "], "answer_body": " Use:  function isInArray(array, search)\n{\n    return array.indexOf(search) >= 0;\n}\n\n// Usage\nif(isInArray(my_array, \"my_value\"))\n{\n    //...\n} "}, {"answer_votes": "34", "answer_comments": [" I disagree. For-in loops should not be used for arrays for precisely this reason. Using for-in loops will break when using one of the popular js libraries \u2013 Tomas  Feb 18 '11 at 14:51 ", " Would this be considered monkey patching?  lol   Some people like that. \u2013 cbmeeks  Oct 10 '12 at 20:36 "], "answer_body": " Extending the JavaScript Array object is a really bad idea because you introduce new properties (your custom methods) into for-in loops which can break existing scripts. A few years ago the authors of the Prototype library had to re-engineer their library implementation to remove just this kind of thing.  If you don't need to worry about compatibility with other JavaScript running on your page, go for it, otherwise, I'd recommend the more awkward, but safer free-standing function solution. "}, {"answer_votes": "26", "answer_comments": null, "answer_body": " You can use Array.prototype.some()  const items = [ {a: '1'}, {a: '2'}, {a: '3'} ]\n\nitems.some(item => item.a === '3')  // returns true\nitems.some(item => item.a === '4')  // returns false  Upside to this is that the iteration is aborted once the element is found so unnecessary iteration cycles are saved.  One thing to note is that some() is not present in all js versions: (from the website)   some was added to the ECMA-262 standard in the 5th edition; as such it\n  may not be present in all implementations of the standard   You can use it in Node.js without any issue. If you need to support all browsers then there's this polyfill (from the same link):  if (!Array.prototype.some)\n{\n  Array.prototype.some = function(fun /*, thisArg */)\n  {\n    'use strict';\n\n    if (this === void 0 || this === null)\n      throw new TypeError();\n\n    var t = Object(this);\n    var len = t.length >>> 0;\n    if (typeof fun !== 'function')\n      throw new TypeError();\n\n    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\n    for (var i = 0; i < len; i++)\n    {\n      if (i in t && fun.call(thisArg, t[i], i, t))\n        return true;\n    }\n\n    return false;\n  };\n} "}, {"answer_votes": "18", "answer_comments": [" array.filter(e=>e==x).length > 0 is equivalent to array.some(e=>e==x) but some is more efficient \u2013 Apolo  Apr 22 '16 at 9:22 "], "answer_body": " One-liner:  function contains(arr, x) {\n    return arr.filter(function(elem) { return elem == x }).length > 0;\n} "}, {"answer_votes": "17", "answer_comments": null, "answer_body": " I use the following:  Array.prototype.contains = function (v) {\n    return this.indexOf(v) > -1;\n}\n\nvar a = [ 'foo', 'bar' ];\n\na.contains('foo'); // true\na.contains('fox'); // false "}, {"answer_votes": "16", "answer_comments": null, "answer_body": " Thinking out of the box for a second, if you are in making this call many many times, it is vastly more efficient to use an associative array a Map to do lookups using a hash function.  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map "}, {"answer_votes": "13", "answer_comments": null, "answer_body": " function contains(a, obj) {\n    return a.some(function(element){return element == obj;})\n}  Array.prototype.some() was added to the ECMA-262 standard in the 5th edition "}, {"answer_votes": "11", "answer_comments": null, "answer_body": " A hopefully faster bidirectional indexOf / lastIndexOf alternative  2015  While the new method includes is very nice, the support is basically zero for now.  It's long time that I was thinking of way to replace the slow indexOf/lastIndexOf functions.  A performant way has already been found, looking at the top answers. From those I chose the contains function posted by @Damir Zekic which should be the fastest one. But it also states that the benchmarks are from 2008 and so are outdated.  I also prefer while over for , but for not a specific reason I ended writing the function with a for loop. It could be also done with a while -- .  I was curious if the iteration was much slower if I check both sides of the array while doing it. Apparently no, and so this function is around two times faster than the top voted ones. Obviously it's also faster than the native one. This in a real world environment, where you never know if the value you are searching is at the beginning or at the end of the array.  When you know you just pushed an array with a value, using lastIndexOf remains probably the best solution, but if you have to travel through big arrays and the result could be everywhere, this could be a solid solution to make things faster.  Bidirectional indexOf/lastIndexOf  function bidirectionalIndexOf(a, b, c, d, e){\n  for(c=a.length,d=c*1; c--; ){\n    if(a[c]==b) return c; //or this[c]===b\n    if(a[e=d-1-c]==b) return e; //or a[e=d-1-c]===b\n  }\n  return -1\n}\n\n//Usage\nbidirectionalIndexOf(array,'value');  Performance test  http://jsperf.com/bidirectionalindexof  As test I created an array with 100k entries.  Three queries: at the beginning, in the middle & at the end of the array.  I hope you also find this interesting and test the performance.  Note: As you can see I slightly modified the contains function to reflect the indexOf & lastIndexOf output (so basically true with the index and false with -1 ). That shouldn't harm it.  The array prototype variant  Object.defineProperty(Array.prototype,'bidirectionalIndexOf',{value:function(b,c,d,e){\n  for(c=this.length,d=c*1; c--; ){\n    if(this[c]==b) return c; //or this[c]===b\n    if(this[e=d-1-c] == b) return e; //or this[e=d-1-c]===b\n  }\n  return -1\n},writable:false, enumerable:false});\n\n// Usage\narray.bidirectionalIndexOf('value');  The function can also be easily modified to return true or false or even the object, string or whatever it is.  And here is the while variant:  function bidirectionalIndexOf(a, b, c, d){\n  c=a.length; d=c-1;\n  while(c--){\n    if(b===a[c]) return c;\n    if(b===a[d-c]) return d-c;\n  }\n  return c\n}\n\n// Usage\nbidirectionalIndexOf(array,'value');  How is this possible?  I think that the simple calculation to get the reflected index in an array is so simple that it's two times faster than doing an actual loop iteration.  Here is a complex example doing three checks per iteration, but this is only possible with a longer calculation which causes the slowdown of the code.  http://jsperf.com/bidirectionalindexof/2 "}, {"answer_votes": "9", "answer_comments": [" Or if possible, stop using an Array entirely, and instead use an Object as a dictionary, as MattMcKnight and ninjagecko have suggested. \u2013 joeytwiddle  Jul 8 '13 at 17:08  "], "answer_body": " If you are checking repeatedly for existence of an object in an array you should maybe look into   Keeping the array sorted at all times by doing insertion sort in your array (put new objects in on the right place)  Make updating objects as remove+sorted insert operation and  Use a binary search lookup in your contains(a, obj) .  "}, {"answer_votes": "9", "answer_comments": null, "answer_body": " function inArray(elem,array)\n{\n    var len = array.length;\n    for(var i = 0 ; i < len;i++)\n    {\n        if(array[i] == elem){return i;}\n    }\n    return -1;\n}  Returns array index if found, or -1 if not found "}, {"answer_votes": "8", "answer_comments": [" I'll just leave it here JS-inArray \u2013 dr.dimitru  Nov 9 '15 at 19:21 "], "answer_body": " We use this snippet (works with objects, arrays, strings):  /*\n * @function\n * @name Object.prototype.inArray\n * @description Extend Object prototype within inArray function\n *\n * @param {mix}    needle       - Search-able needle\n * @param {bool}   searchInKey  - Search needle in keys?\n *\n */\nObject.defineProperty(Object.prototype, 'inArray',{\n    value: function(needle, searchInKey){\n\n        var object = this;\n\n        if( Object.prototype.toString.call(needle) === '[object Object]' || \n            Object.prototype.toString.call(needle) === '[object Array]'){\n            needle = JSON.stringify(needle);\n        }\n\n        return Object.keys(object).some(function(key){\n\n            var value = object[key];\n\n            if( Object.prototype.toString.call(value) === '[object Object]' || \n                Object.prototype.toString.call(value) === '[object Array]'){\n                value = JSON.stringify(value);\n            }\n\n            if(searchInKey){\n                if(value === needle || key === needle){\n                return true;\n                }\n            }else{\n                if(value === needle){\n                    return true;\n                }\n            }\n        });\n    },\n    writable: true,\n    configurable: true,\n    enumerable: false\n});  Usage:  var a = {one: \"first\", two: \"second\", foo: {three: \"third\"}};\na.inArray(\"first\");          //true\na.inArray(\"foo\");            //false\na.inArray(\"foo\", true);      //true - search by keys\na.inArray({three: \"third\"}); //true\n\nvar b = [\"one\", \"two\", \"three\", \"four\", {foo: 'val'}];\nb.inArray(\"one\");         //true\nb.inArray('foo');         //false\nb.inArray({foo: 'val'})   //true\nb.inArray(\"{foo: 'val'}\") //false\n\nvar c = \"String\";\nc.inArray(\"S\");        //true\nc.inArray(\"s\");        //false\nc.inArray(\"2\", true);  //true\nc.inArray(\"20\", true); //false "}, {"answer_votes": "7", "answer_comments": null, "answer_body": " Use lodash's some function.  It's concise, accurate and has great cross platform support.  The accepted answer does not even meet the requirements.  Requirements: Recommend most concise and efficient way to find out if a JavaScript array contains an object.  Accepted Answer:  $.inArray({'b': 2}, [{'a': 1}, {'b': 2}])\n> -1  My recommendation:  _.some([{'a': 1}, {'b': 2}], {'b': 2})\n> true  Notes:  $.inArray works fine for determining whether a scalar value exists in an array of scalars...  $.inArray(2, [1,2])\n> 1  ... but the question clearly asks for an efficient way to determine if an object is contained in an array.  In order to handle both scalars and objects, you could do this:  (_.isObject(item)) ? _.some(ary, item) : (_.indexOf(ary, item) > -1) "}, {"answer_votes": "7", "answer_comments": null, "answer_body": " While array.indexOf(x)!=-1 is the most concise way to do this (and has been supported by non-Internet\u00a0Explorer browsers for over decade...), it is not O(1), but rather O(N), which is terrible. If your array will not be changing, you can convert your array to a hashtable, then do table[x]!==undefined or ===undefined :  Array.prototype.toTable = function() {\n    var t = {};\n    this.forEach(function(x){t[x]=true});\n    return t;\n}  Demo:  var toRemove = [2,4].toTable();\n[1,2,3,4,5].filter(function(x){return toRemove[x]===undefined})  (Unfortunately, while you can create an Array.prototype.contains to \"freeze\" an array and store a hashtable in this._cache in two lines, this would give wrong results if you chose to edit your array later. JavaScript has insufficient hooks to let you keep this state, unlike Python for example.) "}, {"answer_votes": "6", "answer_comments": null, "answer_body": " If you are using JavaScript 1.6 or later (Firefox 1.5 or later) you can use Array.indexOf .  Otherwise, I think you are going to end up with something similar to your original code. "}, {"answer_votes": "6", "answer_comments": [" This is now a standard: ecma-international.org/ecma-262/6.0/#sec-array.prototype.find \u2013 Madbreaks  Aug 16 '16 at 17:38 "], "answer_body": " ECMAScript 6 has an elegant proposal on find.   The find method executes the callback function once for each element\n  present in the array until it finds one where callback returns a true\n  value. If such an element is found, find immediately returns the value\n  of that element. Otherwise, find returns undefined. callback is\n  invoked only for indexes of the array which have assigned values; it\n  is not invoked for indexes which have been deleted or which have never\n  been assigned values.   Here is the MDN documentation on that.  The find functionality works like this.  function isPrime(element, index, array) {\n    var start = 2;\n    while (start <= Math.sqrt(element)) {\n        if (element % start++ < 1) return false;\n    }\n    return (element > 1);\n}\n\nconsole.log( [4, 6, 8, 12].find(isPrime) ); // Undefined, not found\nconsole.log( [4, 5, 8, 12].find(isPrime) ); // 5  You can use this in ECMAScript 5 and below by defining the function .  if (!Array.prototype.find) {\n  Object.defineProperty(Array.prototype, 'find', {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function(predicate) {\n      if (this == null) {\n        throw new TypeError('Array.prototype.find called on null or undefined');\n      }\n      if (typeof predicate !== 'function') {\n        throw new TypeError('predicate must be a function');\n      }\n      var list = Object(this);\n      var length = list.length >>> 0;\n      var thisArg = arguments[1];\n      var value;\n\n      for (var i = 0; i < length; i++) {\n        if (i in list) {\n          value = list[i];\n          if (predicate.call(thisArg, value, i, list)) {\n            return value;\n          }\n        }\n      }\n      return undefined;\n    }\n  });\n} "}, {"answer_votes": "6", "answer_comments": [" This particular chunk of code may work in IE6 (haven't tested), but IE didn't support ES5 until IE9. \u2013 Mark Reed  Apr 9 '17 at 12:51 ", " For performance reasons you should avoid stringifying. At least you should avoid to JSON.stringify the \"obj\" on every loop because it is expensive and will slow down you application. Therefor you should capture it before the for-loop in a temp variable \u2013 itinance  Apr 14 '17 at 8:45 ", " @itinance good point. Updated the includes function with your suggestion. I've ran jsperf with my function. It's about 5x slower than lodash's includes. Though lodash doesn't compare by value and can't find {a: 1} in [{a: 1}] . I don't know if any library does it. But I'm curious if there's any more performant and not insanely complex way of doing it. \u2013 Igor Barbashin  Apr 17 '17 at 4:57  "], "answer_body": " Solution that works in all modern browsers:  function contains(arr, obj) {\n  const stringifiedObj = JSON.stringify(obj); // Cache our object to not call `JSON.stringify` on every iteration\n  return arr.some(item => JSON.stringify(item) === stringifiedObj);\n}  Usage:  contains([{a: 1}, {a: 2}], {a: 1}); // true  IE6+ solution:  function contains(arr, obj) {\n  var stringifiedObj = JSON.stringify(obj)\n  return arr.some(function (item) {\n    return JSON.stringify(item) === stringifiedObj;\n  });\n}\n\n// .some polyfill, not needed for IE9+\nif (!('some' in Array.prototype)) {\n  Array.prototype.some = function (tester, that /*opt*/) {\n    for (var i = 0, n = this.length; i < n; i++) {\n      if (i in this && tester.call(that, this[i], i, this)) return true;\n    } return false;\n  };\n}  Usage:  contains([{a: 1}, {a: 2}], {a: 1}); // true  Why to use JSON.stringify ?  Array.indexOf and Array.includes (as well as most of the answers here) only compare by reference and not by value.  [{a: 1}, {a: 2}].includes({a: 1});\n// false, because {a: 1} is a new object  Bonus  Non-optimized ES6 one-liner:  [{a: 1}, {a: 2}].some(item => JSON.stringify(item) === JSON.stringify({a: 1));\n// true   Note:\nComparing objects by value will work better if the keys are in the same order, so to be safe you might sort the keys first with a package like this one: https://www.npmjs.com/package/sort-keys   Updated the contains function with a perf optimization. Thanks itinance for pointing it out. "}, {"answer_votes": "4", "answer_comments": [" This was already posted year and half ago no need to repeat it. \u2013 Shadow Wizard  Oct 6 '13 at 12:33 "], "answer_body": " Use:  var myArray = ['yellow', 'orange', 'red'] ;\n\nalert(!!~myArray.indexOf('red')); //true  Demo  To know exactly what the tilde  ~ do at this point, refer to this question What does a tilde do when it precedes an expression? . "}, {"answer_votes": "3", "answer_comments": null, "answer_body": " Use:  Array.prototype.contains = function(x){\n  var retVal = -1;\n\n  // x is a primitive type\n  if([\"string\",\"number\"].indexOf(typeof x)>=0 ){ retVal = this.indexOf(x);}\n\n  // x is a function\n  else if(typeof x ==\"function\") for(var ix in this){\n    if((this[ix]+\"\")==(x+\"\")) retVal = ix;\n  }\n\n  //x is an object...\n  else {\n    var sx=JSON.stringify(x);\n    for(var ix in this){\n      if(typeof this[ix] ==\"object\" && JSON.stringify(this[ix])==sx) retVal = ix;\n    }\n  }\n\n  //Return False if -1 else number if numeric otherwise string\n  return (retVal === -1)?false : ( isNaN(+retVal) ? retVal : +retVal);\n}  I know it's not the best way to go, but since there is no native IComparable way to interact between objects, I guess this is as close as you can get to compare two entities in an array. Also, extending Array object might not be a wise thing to do, but sometimes it's OK (if you are aware of it and the trade-off). "}, {"answer_votes": "3", "answer_comments": [" I think return proxy.has(obj) is much cleaner than two lines with if-else statement here \u2013 Maciej Bukowski  Aug 18 '16 at 23:30 "], "answer_body": " One can use Set that has the method \"has()\":  function contains(arr, obj) {\n  var proxy = new Set(arr);\n  if (proxy.has(obj))\n    return true;\n  else\n    return false;\n}\n\nvar arr = ['Happy', 'New', 'Year'];\nconsole.log(contains(arr, 'Happy')); "}, {"answer_votes": "2", "answer_comments": null, "answer_body": " Here's how Prototype does it :  /**\n *  Array#indexOf(item[, offset = 0]) -> Number\n *  - item (?): A value that may or may not be in the array.\n *  - offset (Number): The number of initial items to skip before beginning the\n *      search.\n *\n *  Returns the position of the first occurrence of `item` within the array &mdash; or\n *  `-1` if `item` doesn't exist in the array.\n**/\nfunction indexOf(item, i) {\n  i || (i = 0);\n  var length = this.length;\n  if (i < 0) i = length + i;\n  for (; i < length; i++)\n    if (this[i] === item) return i;\n  return -1;\n}  Also see here for how they hook it up. "}, {"answer_votes": "2", "answer_comments": null, "answer_body": " As others have mentioned you can use Array.indexOf , but it isn't available in all browsers. Here's the code from https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/indexOf to make it work the same in older browsers.   indexOf is a recent addition to the ECMA-262 standard; as such it may\n  not be present in all browsers. You can work around this by inserting\n  the following code at the beginning of your scripts, allowing use of\n  indexOf in implementations which do not natively support it. This\n  algorithm is exactly the one specified in ECMA-262, 5th edition,\n  assuming Object, TypeError, Number, Math.floor, Math.abs, and Math.max\n  have their original value.   if (!Array.prototype.indexOf) {\n    Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {\n        \"use strict\";\n        if (this == null) {\n            throw new TypeError();\n        }\n        var t = Object(this);\n        var len = t.length >>> 0;\n        if (len === 0) {\n            return -1;\n        }\n        var n = 0;\n        if (arguments.length > 1) {\n            n = Number(arguments[1]);\n            if (n != n) { // shortcut for verifying if it's NaN\n                n = 0;\n            } else if (n != 0 && n != Infinity && n != -Infinity) {\n                n = (n > 0 || -1) * Math.floor(Math.abs(n));\n            }\n        }\n        if (n >= len) {\n            return -1;\n        }\n        var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);\n        for (; k < len; k++) {\n            if (k in t && t[k] === searchElement) {\n                return k;\n            }\n        }\n        return -1;\n    }\n} "}, {"answer_votes": "2", "answer_comments": [" What should you use if not this? \u2013 bryc  Feb 20 '17 at 17:36 ", " @bryc maybe the accepted solution, or another solution from here. If you don't care much for performance, than you can use this \u2013 sqram  Mar 16 '17 at 19:49 "], "answer_body": " By no means the best, but I was just getting creative and adding to the repertoire.  Do not use this    Object.defineProperty(Array.prototype, 'exists', {\r\n  value: function(element, index) {\r\n\r\n    var index = index || 0\r\n\r\n    return index === this.length ? -1 : this[index] === element ? index : this.exists(element, ++index)\r\n  }\r\n})\r\n\r\n\r\n// Outputs 1\r\nconsole.log(['one', 'two'].exists('two'));\r\n\r\n// Outputs -1\r\nconsole.log(['one', 'two'].exists('three'));\r\n\r\nconsole.log(['one', 'two', 'three', 'four'].exists('four'));    "}, {"answer_votes": "2", "answer_comments": [" this seems convoluted.   'object' is a poor name, 'item' might be better.   the filter function logic should just be return currentObject === item; and the ternary operator is uncessary.. \u2013 TygerKrash  Aug 5 '16 at 11:15  "], "answer_body": " You can also use this trick:  var arrayContains = function(object) {\n  return (serverList.filter(function(currentObject) {\n    if (currentObject === object) {\n      return currentObject\n    }\n    else {\n      return false;\n    }\n  }).length > 0) ? true : false\n} "}, {"answer_votes": "2", "answer_comments": null, "answer_body": "  Either use Array.indexOf(Object).  With ECMA 7 one can use the Array.includes(Object).  With ECMA 6 you can use Array.find(FunctionName) where FunctionName is a user \ndefined function to search for the object in the array.  Hope this helps!  "}, {"answer_votes": "2", "answer_comments": null, "answer_body": " OK, you can just optimise your code to get the result! There are many ways to do this which are cleaner and better, but I just wanted to get your pattern and apply to that using JSON.stringify , just simply do something like this in your case:  function contains(a, obj) {\n    for (var i = 0; i < a.length; i++) {\n        if (JSON.stringify(a[i]) === JSON.stringify(obj)) {\n            return true;\n        }\n    }\n    return false;\n} "}, {"answer_votes": "1", "answer_comments": [" This certainly is much more flexible than many of the other approaches. If one is uncomfortable with the prototype one might consider something like \tvar positionIf = function (predicate,sequence) {return sequence.map(predicate).indexOf(true);}; \u2013 dat  Jun 5 '13 at 21:28 ", " A more efficient way to implement this method would be to use a loop and stop applying search_lambda once something is found. \u2013 Casey Chu  Oct 10 '13 at 4:49 "], "answer_body": " Similar thing: Finds the first element by a \"search lambda\":  Array.prototype.find = function(search_lambda) {\n  return this[this.map(search_lambda).indexOf(true)];\n};  Usage:  [1,3,4,5,8,3,5].find(function(item) { return item % 2 == 0 })\n=> 4  Same in coffeescript:  Array.prototype.find = (search_lambda) -> @[@map(search_lambda).indexOf(true)] "}, {"answer_votes": "1", "answer_comments": null, "answer_body": " I looked through submitted answers and got that they only apply if you search for the object via reference. A simple linear search with reference object comparison.  But lets say you don't have the reference to an object, how will you find the correct object in the array? You will have to go linearly and deep compare with each object. Imagine if the list is too large, and the objects in it are very big containing big pieces of text. The performance drops drastically with the number and size of the elements in the array.  You can stringify objects and put them in the native hash table, but then you will have data redundancy remembering these keys cause JavaScript keeps them for 'for i in obj', and you only want to check if the object exists or not, that is, you have the key.  I thought about this for some time constructing a JSON Schema validator, and I devised a simple wrapper for the native hash table, similar to the sole hash table implementation, with some optimization exceptions which I left to the native hash table to deal with. It only needs performance benchmarking...\nAll the details and code can be found on my blog: http://stamat.wordpress.com/javascript-quickly-find-very-large-objects-in-a-large-array/ I will soon post benchmark results.  The complete solution works like this:  var a = {'a':1,\n 'b':{'c':[1,2,[3,45],4,5],\n 'd':{'q':1, 'b':{'q':1, 'b':8},'c':4},\n 'u':'lol'},\n 'e':2};\n\n var b = {'a':1, \n 'b':{'c':[2,3,[1]],\n 'd':{'q':3,'b':{'b':3}}},\n 'e':2};\n\n var c = \"Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.\";\n\n var hc = new HashCache([{a:3, b:2, c:5}, {a:15, b:2, c:'foo'}]); //init\n\n hc.put({a:1, b:1});\n hc.put({b:1, a:1});\n hc.put(true);\n hc.put('true');\n hc.put(a);\n hc.put(c);\n hc.put(d);\n console.log(hc.exists('true'));\n console.log(hc.exists(a));\n console.log(hc.exists(c));\n console.log(hc.exists({b:1, a:1}));\n hc.remove(a);\n console.log(hc.exists(c)); "}, {"answer_votes": "1", "answer_comments": null, "answer_body": " Or this solution:  Array.prototype.includes = function (object) {\n  return !!+~this.indexOf(object);\n}; "}, {"answer_votes": "1", "answer_comments": null, "answer_body": " If you're working with ES6 You can use a set:  function arrayHas( array, element ) {\n    const s = new Set(array);\n    return s.has(element)\n}  This should be more performant than just about any other method "}, {"answer_votes": "0", "answer_comments": null, "answer_body": " Using idnexOf() it is a good solution, but you should hide embedded implementation indexOf() function which returns -1 with ~ operator:  function include(arr,obj) { \n    return !!(~arr.indexOf(obj)); \n} "}, {"answer_votes": "0", "answer_comments": null, "answer_body": " I was working on a project that I needed a functionality like python set which removes all duplicates values and returns a new list, so I wrote this function maybe useful to someone  function set(arr) {\n    var res = [];\n    for (var i = 0; i < arr.length; i++) {\n        if (res.indexOf(arr[i]) === -1) {\n            res.push(arr[i]);\n        }\n    }\n    return res;\n} "}, {"answer_votes": "0", "answer_comments": null, "answer_body": " It has one parameter: an array numbers of objects. Each object in the array has two integer properties denoted by x and y. The function must return a count of all such objects in the array that satisfy numbers.x == numbers.y  var numbers = [ { x: 1, y: 1 },\n                 { x: 2, y: 3 },\n                 { x: 3, y: 3 },\n                 { x: 3, y: 4 },\n                 { x: 4, y: 5 } ];\n    count = 0; \nvar n = numbers.length;\nfor (var i =0;i<n;i++)\n{\n  if(numbers[i].x==numbers[i].y)\n  {count+=1;}\n}\n\nalert(count); "}, {"answer_votes": "-3", "answer_comments": null, "answer_body": " Literally:  (using Firefox v3.6, with for-in caveats as previously noted \n(HOWEVER the use below might endorse for-in for this very purpose! That is, enumerating array elements that ACTUALLY exist via a property index (HOWEVER, in particular, the array length property is NOT enumerated in the for-in property list!).).)  (Drag & drop the following complete URI's for immediate mode browser testing.)  JavaScript:  function ObjInRA(ra){var has=false; for(i in ra){has=true; break;} return has;}\n\n  function check(ra){\n      return ['There is ',ObjInRA(ra)?'an':'NO',' object in [',ra,'].'].join('')\n  }\n  alert([\n            check([{}]), check([]), check([,2,3]),\n            check(['']), '\\t (a null string)', check([,,,])\n        ].join('\\n'));  which displays:  There is an object in [[object Object]].\nThere is NO object in [].\nThere is an object in [,2,3].\nThere is an object in [].\n     (a null string)\nThere is NO object in [,,].  Wrinkles: if looking for a \"specific\" object consider:  JavaScript: alert({}!={}); alert({}!=={});  And thus:  JavaScript:  obj = {prop:\"value\"}; \n ra1 = [obj]; \n ra2 = [{prop:\"value\"}];\n alert(ra1[0] == obj); \n alert(ra2[0] == obj);  Often ra2 is considered to \"contain\" obj as the literal entity {prop:\"value\"} .  A very coarse, rudimentary, naive (as in code needs qualification enhancing) solution:  JavaScript:  obj={prop:\"value\"};   ra2=[{prop:\"value\"}];\n  alert(\n    ra2 . toSource() . indexOf( obj.toSource().match(/^.(.*).$/)[1] ) != -1 ?\n      'found' :\n      'missing' );  See ref: Searching for objects in JavaScript arrays . "}, {"answer_votes": "-4", "answer_comments": [" But be careful: stackoverflow.com/questions/237104/javascript-array-containsobj/\u2026 \u2013 MatrixFrog  Aug 12 '10 at 23:18 ", " Please don't use a for in loop to iterate over an array - for in loops should be used strictly for objects only. \u2013 Yi Jiang  Jan 20 '11 at 16:33 "], "answer_body": " Just another option  // usage: if ( ['a','b','c','d'].contains('b') ) { ... }\nArray.prototype.contains = function(value){\n    for (var key in this)\n        if (this[key] === value) return true;\n    return false;\n} "}], "question_code": ["function contains(a, obj) {\n    for (var i = 0; i < a.length; i++) {\n        if (a[i] === obj) {\n            return true;\n        }\n    }\n    return false;\n}\n", "indexOf"], "question_body": " What is the most concise and efficient way to find out if a JavaScript array contains an object?  This is the only way I know to do it:   Is there a better and more concise way to accomplish this?  This is very closely related to Stack Overflow question Best way to find an item in a JavaScript Array? which addresses finding objects in an array using . "}